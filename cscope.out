cscope 15 /root/workspace/openssd_hj_ftl_src/src               0000302735
	@address_translation.c

48 
	~<as.h
>

49 
	~"memy_m.h
"

50 
	~"x_tf.h
"

52 
P_LOGICAL_SLICE_MAP
 
	glogilSliMP
;

53 
P_VIRTUAL_SLICE_MAP
 
	gvtuSliMP
;

54 
P_VIRTUAL_BLOCK_MAP
 
	gvtuBlockMP
;

55 
P_VIRTUAL_DIE_MAP
 
	gvtuDMP
;

56 
P_PHY_BLOCK_MAP
 
	gphyBlockMP
;

57 
P_BAD_BLOCK_TABLE_INFO_MAP
 
	gbbtInfoMP
;

59 
	giAotiTgD
;

60 
	gmbPbadBlockS
;

63 
	$InAddssM
()

65 
blockNo
, 
dNo
;

67 
logilSliMP
 = (
P_LOGICAL_SLICE_MAP
 ) 
LOGICAL_SLICE_MAP_ADDR
;

68 
vtuSliMP
 = (
P_VIRTUAL_SLICE_MAP

VIRTUAL_SLICE_MAP_ADDR
;

69 
vtuBlockMP
 = (
P_VIRTUAL_BLOCK_MAP

VIRTUAL_BLOCK_MAP_ADDR
;

70 
vtuDMP
 = (
P_VIRTUAL_DIE_MAP

VIRTUAL_DIE_MAP_ADDR
;

71 
phyBlockMP
 = (
P_PHY_BLOCK_MAP

PHY_BLOCK_MAP_ADDR
;

72 
bbtInfoMP
 = (
P_BAD_BLOCK_TABLE_INFO_MAP

BAD_BLOCK_TABLE_INFO_MAP_ADDR
;

75 
dNo
=0 ; dNo<
USER_DIES
 ; dieNo++)

77 
blockNo
=0 ; blockNo<
TOTAL_BLOCKS_PER_DIE
 ; blockNo++)

78 
phyBlockMP
->
phyBlock
[
dNo
][
blockNo
].
mdPhyBlock
 = blockNo;

80 
bbtInfoMP
->
bbtInfo
[
dNo
].
phyBlock
 = 0;

81 
bbtInfoMP
->
bbtInfo
[
dNo
].
grownBadUpde
 = 
BBT_INFO_GROWN_BAD_UPDATE_NONE
;

84 
iAotiTgD
 = 
	`FdDFFeSliAoti
();

86 
	`InSliM
();

87 
	`InBlockDM
();

88 
	}
}

90 
	$InSliM
()

92 
iAddr
;

93 
iAddr
=0; sliAddr<
SLICES_PER_SSD
 ; sliceAddr++)

95 
logilSliMP
->
logilSli
[
iAddr
].
vtuSliAddr
 = 
VSA_NONE
;

96 
vtuSliMP
->
vtuSli
[
iAddr
].
logilSliAddr
 = 
LSA_NONE
;

98 
	}
}

100 
	$RemBadBlock
()

102 
blockNo
, 
dNo
, 
mFg
, 
maxBadBlockCou
;

103 
rvedBlockOfLun0
[
USER_DIES
];

104 
rvedBlockOfLun1
[
USER_DIES
];

105 
badBlockCou
[
USER_DIES
];

107 
	`x_tf
("Bad blockemapping start...\r\n");

109 
dNo
=0 ; dNo<
USER_DIES
 ; dieNo++)

111 
rvedBlockOfLun0
[
dNo
] = 
USER_BLOCKS_PER_LUN
;

112 
rvedBlockOfLun1
[
dNo
] = 
TOTAL_BLOCKS_PER_LUN
 + 
USER_BLOCKS_PER_LUN
;

113 
badBlockCou
[
dNo
] = 0;

117 
blockNo
=0 ; blockNo<
USER_BLOCKS_PER_LUN
 ; blockNo++)

119 
dNo
=0 ; dNo<
USER_DIES
 ; dieNo++)

122 if(
phyBlockMP
->
phyBlock
[
dNo
][
blockNo
].
bad
)

124 if(
rvedBlockOfLun0
[
dNo
] < 
TOTAL_BLOCKS_PER_LUN
)

126 
mFg
 = 1;

127 
phyBlockMP
->
phyBlock
[
dNo
][
rvedBlockOfLun0
[dNo]].
bad
)

129 
rvedBlockOfLun0
[
dNo
]++;

130 if(
rvedBlockOfLun0
[
dNo
] >
TOTAL_BLOCKS_PER_LUN
)

132 
mFg
 = 0;

137 if(
mFg
)

139 
phyBlockMP
->
phyBlock
[
dNo
][
blockNo
].
mdPhyBlock
 = 
rvedBlockOfLun0
[dieNo];

140 
rvedBlockOfLun0
[
dNo
]++;

144 
	`x_tf
("Nػrved block - Ch %d Way %d vtuBlock %d ibad block \r\n", 
	`Vd2PchTni
(
dNo
), 
	`Vd2PwayTni
(dNo), 
blockNo
);

145 
badBlockCou
[
dNo
]++;

150 
	`x_tf
("Nػrved block - Ch %d Way %d vtuBlock %d ibad block \r\n", 
	`Vd2PchTni
(
dNo
), 
	`Vd2PwayTni
(dNo), 
blockNo
);

151 
badBlockCou
[
dNo
]++;

155 i(
LUNS_PER_DIE
 > 1)

158 if(
phyBlockMP
->
phyBlock
[
dNo
][
blockNo
+
TOTAL_BLOCKS_PER_LUN
].
bad
)

160 if(
rvedBlockOfLun1
[
dNo
] < 
TOTAL_BLOCKS_PER_DIE
)

162 
mFg
 = 1;

163 
phyBlockMP
->
phyBlock
[
dNo
][
rvedBlockOfLun1
[dNo]].
bad
)

165 
rvedBlockOfLun1
[
dNo
]++;

166 if(
rvedBlockOfLun1
[
dNo
] >
TOTAL_BLOCKS_PER_DIE
)

168 
mFg
 = 0;

173 if(
mFg
)

175 
phyBlockMP
->
phyBlock
[
dNo
][
blockNo
+
TOTAL_BLOCKS_PER_LUN
].
mdPhyBlock
 = 
rvedBlockOfLun1
[dieNo];

176 
rvedBlockOfLun1
[
dNo
]++;

180 
	`x_tf
("Nػrved block - Ch %x Way %x vtuBlock %d ibad block \r\n", 
	`Vd2PchTni
(
dNo
), 
	`Vd2PwayTni
(dNo), 
blockNo
+
USER_BLOCKS_PER_LUN
);

181 
badBlockCou
[
dNo
]++;

186 
	`x_tf
("Nػrved block - Ch %x Way %x vtuBlock %d ibad block \r\n", 
	`Vd2PchTni
(
dNo
), 
	`Vd2PwayTni
(dNo), 
blockNo
+
USER_BLOCKS_PER_LUN
);

187 
badBlockCou
[
dNo
]++;

194 
	`x_tf
("Bad blockemappingnd\r\n");

197 
maxBadBlockCou
 = 0;

198 
dNo
=0; dN< 
USER_DIES
; dieNo++)

200 if(
maxBadBlockCou
 < 
badBlockCou
[
dNo
])

201 
maxBadBlockCou
 = 
badBlockCou
[
dNo
];

204 
mbPbadBlockS
 = (
maxBadBlockCou
 * 
USER_DIES
 * 
KB_PER_BLOCK
)/(1024);

205 
	}
}

207 
	$InDM
()

209 
dNo
;

211 
dNo
=0 ; dNo<
USER_DIES
 ; dieNo++)

213 
vtuDMP
->
d
[
dNo
].
hdFeBlock
 = 
BLOCK_NONE
;

214 
vtuDMP
->
d
[
dNo
].
FeBlock
 = 
BLOCK_NONE
;

215 
vtuDMP
->
d
[
dNo
].
BlockC
 = 0;

217 
	}
}

219 
	$InBlockM
()

221 
dNo
, 
phyBlockNo
, 
vtuBlockNo
, 
mdPhyBlock
;

223 
dNo
=0 ; dNo<
USER_DIES
 ; dieNo++)

225 
vtuBlockNo
=0; vtuBlockNo<
USER_BLOCKS_PER_DIE
 ; virtualBlockNo++)

227 
phyBlockNo
 = 
	`Vblock2PblockOfTbsTni
(
vtuBlockNo
);

228 
mdPhyBlock
 = 
phyBlockMP
->
phyBlock
[
dNo
][
phyBlockNo
].remappedPhyBlock;

229 
vtuBlockMP
->
block
[
dNo
][
vtuBlockNo
].
bad
 = 
phyBlockMP
->
phyBlock
[dNo][
mdPhyBlock
].bad;

231 
vtuBlockMP
->
block
[
dNo
][
vtuBlockNo
].

 = 1;

232 
vtuBlockMP
->
block
[
dNo
][
vtuBlockNo
].
vidSliC
 = 0;

233 
vtuBlockMP
->
block
[
dNo
][
vtuBlockNo
].
cutPage
 = 0;

234 
vtuBlockMP
->
block
[
dNo
][
vtuBlockNo
].
aC
 = 0;

236 if(
vtuBlockMP
->
block
[
dNo
][
vtuBlockNo
].
bad
)

238 
vtuBlockMP
->
block
[
dNo
][
vtuBlockNo
].
evBlock
 = 
BLOCK_NONE
;

239 
vtuBlockMP
->
block
[
dNo
][
vtuBlockNo
].
xtBlock
 = 
BLOCK_NONE
;

242 
	`PutToFbLi
(
dNo
, 
vtuBlockNo
);

245 
	}
}

247 
	$InCutBlockOfDM
()

249 
dNo
;

251 
dNo
=0 ; dNo<
USER_DIES
 ; dieNo++)

253 
vtuDMP
->
d
[
dNo
].
cutBlock
 = 
	`GFromFbLi
(dNo, 
GET_FREE_BLOCK_NORMAL
);

254 if(
vtuDMP
->
d
[
dNo
].
cutBlock
 =
BLOCK_FAIL
)

255 
	`as
(!"[WARNING] There iso free block [WARNING]");

257 
	}
}

259 
	$RdBadBlockTab
(
mpBbtBufAddr
[], 
mpBbtBufErySize
)

261 
mpPage
, 
qSlTag
, 
dNo
;

262 
lo
, 
daSize
;

264 
lo
 = 0;

265 
daSize
 = 
DATA_SIZE_OF_BAD_BLOCK_TABLE_PER_DIE
;

266 
mpPage
 = 
	`PlsbPage2VgeTni
(
START_PAGE_NO_OF_BAD_BLOCK_TABLE_BLOCK
);

268 
daSize
>0)

270 
dNo
 = 0; dN< 
USER_DIES
; dieNo++)

272 
qSlTag
 = 
	`GFromFeReqQ
();

274 
qPoP
->
qPo
[
qSlTag
].
qTy
 = 
REQ_TYPE_NAND
;

275 
qPoP
->
qPo
[
qSlTag
].
qCode
 = 
REQ_CODE_READ
;

276 
qPoP
->
qPo
[
qSlTag
].
qO
.
daBufFm
 = 
REQ_OPT_DATA_BUF_ADDR
;

277 
qPoP
->
qPo
[
qSlTag
].
qO
.
ndAddr
 = 
REQ_OPT_NAND_ADDR_PHY_ORG
;

278 
qPoP
->
qPo
[
qSlTag
].
qO
.
ndEcc
 = 
REQ_OPT_NAND_ECC_ON
;

279 
qPoP
->
qPo
[
qSlTag
].
qO
.
ndEccWng
 = 
REQ_OPT_NAND_ECC_WARNING_OFF
;

280 
qPoP
->
qPo
[
qSlTag
].
qO
.
rowAddrDdcyCheck
 = 
REQ_OPT_ROW_ADDR_DEPENDENCY_NONE
;

281 
qPoP
->
qPo
[
qSlTag
].
qO
.
blockS
 = 
REQ_OPT_BLOCK_SPACE_TOTAL
;

282 
qPoP
->
qPo
[
qSlTag
].
qO
.
fUnAcss
 = 
REQ_OPT_FORCE_UNIT_ACCESS_OFF
;

284 
qPoP
->
qPo
[
qSlTag
].
daBufInfo
.
addr
 = 
mpBbtBufAddr
[
dNo
] + 
lo
 * 
mpBbtBufErySize
;

286 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
physilCh
 = 
	`Vd2PchTni
(
dNo
);

287 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
physilWay
 = 
	`Vd2PwayTni
(
dNo
);

288 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
physilBlock
 = 
bbtInfoMP
->
bbtInfo
[
dNo
].
phyBlock
;

289 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
physilPage
 = 
	`Vge2PlsbPageTni
(
mpPage
);

291 
	`SeLowLevReqQ
(
qSlTag
);

294 
mpPage
++;

295 
lo
++;

296 
daSize
 -
BYTES_PER_DATA_REGION_OF_PAGE_FOR_BB
;

299 
	`SyncALowLevReqDe
();

300 
	}
}

302 
	$FdBadBlock
(
dS
[], 
mpBbtBufAddr
[], 
mpBbtBufErySize
, 
mpRdBufAddr
[], 
mpRdBufErySize
)

304 
phyBlockNo
, 
dNo
, 
qSlTag
;

305 
blockCheck
[
USER_DIES
];

306 * 
mkPor0
;

307 * 
mkPor1
;

308 * 
bbtUpd
;

311 
phyBlockNo
 = 0;hyBlockN< 
TOTAL_BLOCKS_PER_DIE
;hyBlockNo++)

313 
dNo
=0; dN< 
USER_DIES
; dieNo++)

314 if(!
dS
[
dNo
])

316 
blockCheck
[
dNo
] = 
BLOCK_STATE_NORMAL
;

318 
qSlTag
 = 
	`GFromFeReqQ
();

320 
qPoP
->
qPo
[
qSlTag
].
qTy
 = 
REQ_TYPE_NAND
;

321 
qPoP
->
qPo
[
qSlTag
].
qCode
 = 
REQ_CODE_READ
;

322 
qPoP
->
qPo
[
qSlTag
].
qO
.
daBufFm
 = 
REQ_OPT_DATA_BUF_ADDR
;

323 
qPoP
->
qPo
[
qSlTag
].
qO
.
ndAddr
 = 
REQ_OPT_NAND_ADDR_PHY_ORG
;

324 
qPoP
->
qPo
[
qSlTag
].
qO
.
ndEcc
 = 
REQ_OPT_NAND_ECC_OFF
;

325 
qPoP
->
qPo
[
qSlTag
].
qO
.
ndEccWng
 = 
REQ_OPT_NAND_ECC_WARNING_OFF
;

326 
qPoP
->
qPo
[
qSlTag
].
qO
.
rowAddrDdcyCheck
 = 
REQ_OPT_ROW_ADDR_DEPENDENCY_NONE
;

327 
qPoP
->
qPo
[
qSlTag
].
qO
.
blockS
 = 
REQ_OPT_BLOCK_SPACE_TOTAL
;

328 
qPoP
->
qPo
[
qSlTag
].
qO
.
fUnAcss
 = 
REQ_OPT_FORCE_UNIT_ACCESS_OFF
;

330 
qPoP
->
qPo
[
qSlTag
].
daBufInfo
.
addr
 = 
mpRdBufAddr
[
dNo
];

332 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
physilCh
 = 
	`Vd2PchTni
(
dNo
);

333 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
physilWay
 = 
	`Vd2PwayTni
(
dNo
);

334 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
physilBlock
 = 
phyBlockNo
;

335 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
physilPage
 = 
BAD_BLOCK_MARK_PAGE0
;

337 
	`SeLowLevReqQ
(
qSlTag
);

340 
	`SyncALowLevReqDe
();

342 
dNo
=0; dN< 
USER_DIES
; dieNo++)

343 if(!
dS
[
dNo
])

345 
mkPor0
 = (*)(
mpRdBufAddr
[
dNo
] + 
BAD_BLOCK_MARK_BYTE0
);

346 
mkPor1
 = (*)(
mpRdBufAddr
[
dNo
] + 
BAD_BLOCK_MARK_BYTE1
);

348 if((*
mkPor0
 =
CLEAN_DATA_IN_BYTE
&& (*
mkPor1
 == CLEAN_DATA_IN_BYTE))

350 
qSlTag
 = 
	`GFromFeReqQ
();

352 
qPoP
->
qPo
[
qSlTag
].
qTy
 = 
REQ_TYPE_NAND
;

353 
qPoP
->
qPo
[
qSlTag
].
qCode
 = 
REQ_CODE_READ
;

354 
qPoP
->
qPo
[
qSlTag
].
qO
.
daBufFm
 = 
REQ_OPT_DATA_BUF_ADDR
;

355 
qPoP
->
qPo
[
qSlTag
].
qO
.
ndAddr
 = 
REQ_OPT_NAND_ADDR_PHY_ORG
;

356 
qPoP
->
qPo
[
qSlTag
].
qO
.
ndEcc
 = 
REQ_OPT_NAND_ECC_OFF
;

357 
qPoP
->
qPo
[
qSlTag
].
qO
.
ndEccWng
 = 
REQ_OPT_NAND_ECC_WARNING_OFF
;

358 
qPoP
->
qPo
[
qSlTag
].
qO
.
rowAddrDdcyCheck
 = 
REQ_OPT_ROW_ADDR_DEPENDENCY_NONE
;

359 
qPoP
->
qPo
[
qSlTag
].
qO
.
blockS
 = 
REQ_OPT_BLOCK_SPACE_TOTAL
;

360 
qPoP
->
qPo
[
qSlTag
].
qO
.
fUnAcss
 = 
REQ_OPT_FORCE_UNIT_ACCESS_OFF
;

362 
qPoP
->
qPo
[
qSlTag
].
daBufInfo
.
addr
 = 
mpRdBufAddr
[
dNo
];

364 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
physilCh
 = 
	`Vd2PchTni
(
dNo
);

365 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
physilWay
 = 
	`Vd2PwayTni
(
dNo
);

366 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
physilBlock
 = 
phyBlockNo
;

367 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
physilPage
 = 
BAD_BLOCK_MARK_PAGE1
;

369 
	`SeLowLevReqQ
(
qSlTag
);

373 
	`x_tf
(" bad block ideed: Ch %d Way %dhyBlock %d \r\n",
	`Vd2PchTni
(
dNo
), 
	`Vd2PwayTni
(dNo), 
phyBlockNo
);

375 
blockCheck
[
dNo
] = 
BLOCK_STATE_BAD
;

379 
	`SyncALowLevReqDe
();

381 
dNo
=0; dN< 
USER_DIES
; dieNo++)

382 if(!
dS
[
dNo
])

384 
mkPor0
 = (*)(
mpRdBufAddr
[
dNo
] + 
BAD_BLOCK_MARK_BYTE0
);

385 
mkPor1
 = (*)(
mpRdBufAddr
[
dNo
] + 
BAD_BLOCK_MARK_BYTE1
);

387 if(!((*
mkPor0
 =
CLEAN_DATA_IN_BYTE
&& (*
mkPor1
 == CLEAN_DATA_IN_BYTE)))

388 if(
blockCheck
[
dNo
] =
BLOCK_STATE_NORMAL
)

390 
	`x_tf
(" bad block ideed: Ch %d Way %dhyBlock %d \r\n",
	`Vd2PchTni
(
dNo
), 
	`Vd2PwayTni
(dNo), 
phyBlockNo
);

392 
blockCheck
[
dNo
] = 
BLOCK_STATE_BAD
;

396 
bbtUpd
(*)(
mpBbtBufAddr
[
dNo
] + 
phyBlockNo
);

397 *
bbtUpd
 = 
blockCheck
[
dNo
];

398 
phyBlockMP
->
phyBlock
[
dNo
][
phyBlockNo
].
bad
 = 
blockCheck
[dieNo];

401 
	}
}

404 
	$SaveBadBlockTab
(
dS
[], 
mpBbtBufAddr
[], 
mpBbtBufErySize
)

406 
dNo
, 
qSlTag
;

407 
lo
, 
daSize
, 
mpPage
;

409 
lo
 = 0;

410 
daSize
 = 
DATA_SIZE_OF_BAD_BLOCK_TABLE_PER_DIE
;

411 
mpPage
 = 
	`PlsbPage2VgeTni
(
START_PAGE_NO_OF_BAD_BLOCK_TABLE_BLOCK
);

413 
daSize
>0)

415 
dNo
 = 0; dN< 
USER_DIES
; dieNo++)

416 if((
dS
[
dNo
] =
DIE_STATE_BAD_BLOCK_TABLE_NOT_EXIST
|| (dS[dNo] =
DIE_STATE_BAD_BLOCK_TABLE_UPDATE
))

418 if(
lo
 == 0)

420 
qSlTag
 = 
	`GFromFeReqQ
();

422 
qPoP
->
qPo
[
qSlTag
].
qTy
 = 
REQ_TYPE_NAND
;

423 
qPoP
->
qPo
[
qSlTag
].
qCode
 = 
REQ_CODE_ERASE
;

424 
qPoP
->
qPo
[
qSlTag
].
qO
.
ndAddr
 = 
REQ_OPT_NAND_ADDR_PHY_ORG
;

425 
qPoP
->
qPo
[
qSlTag
].
qO
.
daBufFm
 = 
REQ_OPT_DATA_BUF_NONE
;

426 
qPoP
->
qPo
[
qSlTag
].
qO
.
rowAddrDdcyCheck
 = 
REQ_OPT_ROW_ADDR_DEPENDENCY_NONE
;

427 
qPoP
->
qPo
[
qSlTag
].
qO
.
blockS
 = 
REQ_OPT_BLOCK_SPACE_TOTAL
;

428 
qPoP
->
qPo
[
qSlTag
].
qO
.
fUnAcss
 = 
REQ_OPT_FORCE_UNIT_ACCESS_OFF
;

430 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
physilCh
 = 
	`Vd2PchTni
(
dNo
);

431 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
physilWay
 = 
	`Vd2PwayTni
(
dNo
);

432 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
physilBlock
 = 
bbtInfoMP
->
bbtInfo
[
dNo
].
phyBlock
;

433 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
physilPage
 = 0;

435 
	`SeLowLevReqQ
(
qSlTag
);

438 
qSlTag
 = 
	`GFromFeReqQ
();

440 
qPoP
->
qPo
[
qSlTag
].
qTy
 = 
REQ_TYPE_NAND
;

441 
qPoP
->
qPo
[
qSlTag
].
qCode
 = 
REQ_CODE_WRITE
;

442 
qPoP
->
qPo
[
qSlTag
].
qO
.
daBufFm
 = 
REQ_OPT_DATA_BUF_ADDR
;

443 
qPoP
->
qPo
[
qSlTag
].
qO
.
ndAddr
 = 
REQ_OPT_NAND_ADDR_PHY_ORG
;

444 
qPoP
->
qPo
[
qSlTag
].
qO
.
ndEcc
 = 
REQ_OPT_NAND_ECC_ON
;

445 
qPoP
->
qPo
[
qSlTag
].
qO
.
ndEccWng
 = 
REQ_OPT_NAND_ECC_WARNING_OFF
;

446 
qPoP
->
qPo
[
qSlTag
].
qO
.
rowAddrDdcyCheck
 = 
REQ_OPT_ROW_ADDR_DEPENDENCY_NONE
;

447 
qPoP
->
qPo
[
qSlTag
].
qO
.
blockS
 = 
REQ_OPT_BLOCK_SPACE_TOTAL
;

448 
qPoP
->
qPo
[
qSlTag
].
qO
.
fUnAcss
 = 
REQ_OPT_FORCE_UNIT_ACCESS_OFF
;

450 
qPoP
->
qPo
[
qSlTag
].
daBufInfo
.
addr
 = 
mpBbtBufAddr
[
dNo
] + 
lo
 * 
mpBbtBufErySize
;

452 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
physilCh
 = 
	`Vd2PchTni
(
dNo
);

453 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
physilWay
 = 
	`Vd2PwayTni
(
dNo
);

454 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
physilBlock
 = 
bbtInfoMP
->
bbtInfo
[
dNo
].
phyBlock
;

455 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
physilPage
 = 
	`Vge2PlsbPageTni
(
mpPage
);

457 
	`SeLowLevReqQ
(
qSlTag
);

460 
lo
++;

461 
mpPage
++;

462 
daSize
 -
BYTES_PER_DATA_REGION_OF_PAGE_FOR_BB
;

465 
	`SyncALowLevReqDe
();

468 
dNo
=0; dN< 
USER_DIES
; dieNo++)

469 if(
dS
[
dNo
] =
DIE_STATE_BAD_BLOCK_TABLE_NOT_EXIST
)

470 
	`x_tf
("[ bad blockab oCh %d Way %d ived. ]\r\n", 
dNo
%
USER_CHANNELS
, dieNo/USER_CHANNELS);

471 
	}
}

474 
	$RecovBadBlockTab
(
mpBufAddr
)

476 
dNo
, 
phyBlockNo
, 
bbtMak
, 
mpBbtBufBaAddr
, 
mpBbtBufErySize
, 
mpRdBufBaAddr
, 
mpRdBufErySize
;

477 
mpBbtBufAddr
[
USER_DIES
];

478 
mpRdBufAddr
[
USER_DIES
];

479 
dS
[
USER_DIES
];

480 * 
bbtTabCheck
;

483 
mpBbtBufBaAddr
 = 
mpBufAddr
;

484 
mpBbtBufErySize
 = 
BYTES_PER_DATA_REGION_OF_PAGE_FOR_BB
 + 
BYTES_PER_SPARE_REGION_OF_PAGE
;

485 
mpRdBufBaAddr
 = 
mpBbtBufBaAddr
 + 
USER_DIES
 * 
USED_PAGES_FOR_BAD_BLOCK_TABLE_PER_DIE
 * 
mpBbtBufErySize
;

486 
mpRdBufErySize
 = 
BYTES_PER_NAND_ROW
;

487 
dNo
 = 0; dN< 
USER_DIES
; dieNo++)

489 
mpBbtBufAddr
[
dNo
] = 
mpBbtBufBaAddr
 + dN* 
USED_PAGES_FOR_BAD_BLOCK_TABLE_PER_DIE
 * 
mpBbtBufErySize
;

490 
mpRdBufAddr
[
dNo
] = 
mpRdBufBaAddr
 + dN* 
mpRdBufErySize
;

494 
	`RdBadBlockTab
(
mpBbtBufAddr
, 
mpBbtBufErySize
);

497 
bbtMak
 = 
BAD_BLOCK_TABLE_MAKER_IDLE
;

498 
dNo
=0; dNo<
USER_DIES
; dieNo++)

500 
bbtTabCheck
 = (*)(
mpBbtBufAddr
[
dNo
]);

502 if((*
bbtTabCheck
 =
BLOCK_STATE_NORMAL
)||(*bbtTabCheck =
BLOCK_STATE_BAD
))

504 
	`x_tf
("[ bad blockab och %d way %dxis.]\r\n",
	`Vd2PchTni
(
dNo
), 
	`Vd2PwayTni
(dieNo));

506 
dS
[
dNo
] = 
DIE_STATE_BAD_BLOCK_TABLE_EXIST
;

507 
phyBlockNo
=0;hyBlockNo<
TOTAL_BLOCKS_PER_DIE
;hyBlockNo++)

509 
bbtTabCheck
 = (*)(
mpBbtBufAddr
[
dNo
] + 
phyBlockNo
);

511 
phyBlockMP
->
phyBlock
[
dNo
][
phyBlockNo
].
bad
 = *
bbtTabCheck
;

512 if(
phyBlockMP
->
phyBlock
[
dNo
][
phyBlockNo
].
bad
 =
BLOCK_STATE_BAD
)

513 
	`x_tf
(" bad block: ch %d way %dhyBlock %d \r\n", 
	`Vd2PchTni
(
dNo
), 
	`Vd2PwayTni
(dNo), 
phyBlockNo
);

516 
	`x_tf
("[ bad blockoch %d way %d checked. ]\r\n",
	`Vd2PchTni
(
dNo
), 
	`Vd2PwayTni
(dieNo));

520 
	`x_tf
("[ bad blockab och %d way %d d۠nكxi.]\r\n",
	`Vd2PchTni
(
dNo
), 
	`Vd2PwayTni
(dieNo));

521 
dS
[
dNo
] = 
DIE_STATE_BAD_BLOCK_TABLE_NOT_EXIST
;

522 
bbtMak
 = 
BAD_BLOCK_TABLE_MAKER_TRIGGER
;

527 if(
bbtMak
 =
BAD_BLOCK_TABLE_MAKER_TRIGGER
)

529 
	`FdBadBlock
(
dS
, 
mpBbtBufAddr
, 
mpBbtBufErySize
, 
mpRdBufAddr
, 
mpRdBufErySize
);

530 
	`SaveBadBlockTab
(
dS
, 
mpBbtBufAddr
, 
mpBbtBufErySize
);

534 
dNo
=0; dNo<
USER_DIES
; dieNo++)

535 
bbtInfoMP
->
bbtInfo
[
dNo
].
grownBadUpde
 = 
BBT_INFO_GROWN_BAD_UPDATE_NONE
;

536 
	}
}

540 
	$ETٮBlockS
()

542 
blockNo
, 
dNo
, 
qSlTag
;

544 
	`x_tf
("Eraseotal block space...wait for minute...\r\n");

546 
blockNo
=0 ; blockNo<
TOTAL_BLOCKS_PER_DIE
 ; blockNo++)

547 
dNo
=0 ; dNo<
USER_DIES
 ; dieNo++)

549 
qSlTag
 = 
	`GFromFeReqQ
();

551 
qPoP
->
qPo
[
qSlTag
].
qTy
 = 
REQ_TYPE_NAND
;

552 
qPoP
->
qPo
[
qSlTag
].
qCode
 = 
REQ_CODE_ERASE
;

553 
qPoP
->
qPo
[
qSlTag
].
qO
.
ndAddr
 = 
REQ_OPT_NAND_ADDR_PHY_ORG
;

554 
qPoP
->
qPo
[
qSlTag
].
qO
.
daBufFm
 = 
REQ_OPT_DATA_BUF_NONE
;

555 
qPoP
->
qPo
[
qSlTag
].
qO
.
rowAddrDdcyCheck
 = 
REQ_OPT_ROW_ADDR_DEPENDENCY_NONE
;

556 
qPoP
->
qPo
[
qSlTag
].
qO
.
blockS
 = 
REQ_OPT_BLOCK_SPACE_TOTAL
;

557 
qPoP
->
qPo
[
qSlTag
].
qO
.
fUnAcss
 = 
REQ_OPT_FORCE_UNIT_ACCESS_OFF
;

559 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
physilCh
 = 
	`Vd2PchTni
(
dNo
);

560 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
physilWay
 = 
	`Vd2PwayTni
(
dNo
);

561 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
physilBlock
 = 
blockNo
;

562 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
physilPage
 = 0;

564 
	`SeLowLevReqQ
(
qSlTag
);

567 
	`SyncALowLevReqDe
();

568 
	`x_tf
("Done.\r\n");

569 
	}
}

572 
	$EUrBlockS
()

574 
blockNo
, 
dNo
, 
qSlTag
;

576 
	`x_tf
("Erase User block space...wait for minute...\r\n");

578 
blockNo
=0 ; blockNo<
USER_BLOCKS_PER_DIE
 ; blockNo++)

579 
dNo
=0 ; dNo<
USER_DIES
 ; dieNo++)

580 if(!
vtuBlockMP
->
block
[
dNo
][
blockNo
].
bad
)

582 
qSlTag
 = 
	`GFromFeReqQ
();

584 
qPoP
->
qPo
[
qSlTag
].
qTy
 = 
REQ_TYPE_NAND
;

585 
qPoP
->
qPo
[
qSlTag
].
qCode
 = 
REQ_CODE_ERASE
;

586 
qPoP
->
qPo
[
qSlTag
].
qO
.
ndAddr
 = 
REQ_OPT_NAND_ADDR_VSA
;

587 
qPoP
->
qPo
[
qSlTag
].
qO
.
daBufFm
 = 
REQ_OPT_DATA_BUF_NONE
;

588 
qPoP
->
qPo
[
qSlTag
].
qO
.
rowAddrDdcyCheck
 = 
REQ_OPT_ROW_ADDR_DEPENDENCY_NONE
;

589 
qPoP
->
qPo
[
qSlTag
].
qO
.
blockS
 = 
REQ_OPT_BLOCK_SPACE_MAIN
;

591 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
vtuSliAddr
 = 
	`Vg2VTni
(
dNo
, 
blockNo
, 0);

593 
	`SeLowLevReqQ
(
qSlTag
);

596 
	`SyncALowLevReqDe
();

597 
	`x_tf
("Done.\r\n");

598 
	}
}

601 
	$InBlockDM
()

603 
dNo
;

604 
aFg
 = 1;

606 
	`x_tf
("Press 'X'oe-makehe bad blockable.\r\n");

607 i(
	`by
() == 'X')

609 
	`ETٮBlockS
();

610 
aFg
 = 0;

613 
	`InDM
();

616 
	`RecovBadBlockTab
(
RESERVED_DATA_BUFFER_BASE_ADDR
);

619 
dNo
=0 ; dNo<
USER_DIES
 ; dieNo++)

620 
phyBlockMP
->
phyBlock
[
dNo
][
bbtInfoMP
->
bbtInfo
[dNo].phyBlock].
bad
 = 1;

622 
	`RemBadBlock
();

624 
	`InBlockM
();

626 if(
aFg
)

627 
	`EUrBlockS
();

629 
	`InCutBlockOfDM
();

630 
	}
}

632 
	$AddrTnsRd
(
logilSliAddr
)

634 
vtuSliAddr
;

636 if(
logilSliAddr
 < 
SLICES_PER_SSD
)

638 
vtuSliAddr
 = 
logilSliMP
->
logilSli
[
logilSliAddr
].virtualSliceAddr;

640 if(
vtuSliAddr
 !
VSA_NONE
)

641  
vtuSliAddr
;

643  
VSA_FAIL
;

646 
	`as
(!"[WARNING] Logicalddress isargerhan maximumogicalddress served by SSD [WARNING]");

647 
	}
}

649 
	$AddrTnsWre
(
logilSliAddr
)

651 
vtuSliAddr
;

653 if(
logilSliAddr
 < 
SLICES_PER_SSD
)

655 
	`InvideOldV
(
logilSliAddr
);

657 
vtuSliAddr
 = 
	`FdFeVtuSli
();

663 
logilSliMP
->
logilSli
[
logilSliAddr
].
vtuSliAddr
 = virtualSliceAddr;

664 
vtuSliMP
->
vtuSli
[
vtuSliAddr
].
logilSliAddr
 =ogicalSliceAddr;

666  
vtuSliAddr
;

669 
	`as
(!"[WARNING] Logicalddress isargerhan maximumogicalddress served by SSD [WARNING]");

670 
	}
}

673 
	$FdFeVtuSli
()

675 
cutBlock
, 
vtuSliAddr
, 
dNo
;

677 
dNo
 = 
iAotiTgD
;

678 
cutBlock
 = 
vtuDMP
->
d
[
dNo
].currentBlock;

680 if(
vtuBlockMP
->
block
[
dNo
][
cutBlock
].
cutPage
 =
USER_PAGES_PER_BLOCK
)

682 
cutBlock
 = 
	`GFromFbLi
(
dNo
, 
GET_FREE_BLOCK_NORMAL
);

684 if(
cutBlock
 !
BLOCK_FAIL
)

685 
vtuDMP
->
d
[
dNo
].
cutBlock
 = currentBlock;

688 
	`GbageCi
(
dNo
);

689 
cutBlock
 = 
vtuDMP
->
d
[
dNo
].currentBlock;

691 if(
vtuBlockMP
->
block
[
dNo
][
cutBlock
].
cutPage
 =
USER_PAGES_PER_BLOCK
)

693 
cutBlock
 = 
	`GFromFbLi
(
dNo
, 
GET_FREE_BLOCK_NORMAL
);

694 if(
cutBlock
 !
BLOCK_FAIL
)

695 
vtuDMP
->
d
[
dNo
].
cutBlock
 = currentBlock;

697 
	`as
(!"[WARNING] There isovailable block [WARNING]");

699 if(
vtuBlockMP
->
block
[
dNo
][
cutBlock
].
cutPage
 > 
USER_PAGES_PER_BLOCK
)

700 
	`as
(!"[WARNING] Currentage management fail [WARNING]");

703 if(
vtuBlockMP
->
block
[
dNo
][
cutBlock
].
cutPage
 > 
USER_PAGES_PER_BLOCK
)

704 
	`as
(!"[WARNING] Currentage management fail [WARNING]");

707 
vtuSliAddr
 = 
	`Vg2VTni
(
dNo
, 
cutBlock
, 
vtuBlockMP
->
block
[dNo][cutBlock].
cutPage
);

708 
vtuBlockMP
->
block
[
dNo
][
cutBlock
].
cutPage
++;

709 
iAotiTgD
 = 
	`FdDFFeSliAoti
();

710 
dNo
 = 
iAotiTgD
;

711  
vtuSliAddr
;

712 
	}
}

715 
	$FdFeVtuSliFGc
(
cyTgDNo
, 
viimBlockNo
)

717 
cutBlock
, 
vtuSliAddr
, 
dNo
;

719 
dNo
 = 
cyTgDNo
;

720 if(
viimBlockNo
 =
vtuDMP
->
d
[
dNo
].
cutBlock
)

722 
vtuDMP
->
d
[
dNo
].
cutBlock
 = 
	`GFromFbLi
(dNo, 
GET_FREE_BLOCK_GC
);

723 if(
vtuDMP
->
d
[
dNo
].
cutBlock
 =
BLOCK_FAIL
)

724 
	`as
(!"[WARNING] There isovailable block [WARNING]");

726 
cutBlock
 = 
vtuDMP
->
d
[
dNo
].currentBlock;

728 if(
vtuBlockMP
->
block
[
dNo
][
cutBlock
].
cutPage
 =
USER_PAGES_PER_BLOCK
)

731 
cutBlock
 = 
	`GFromFbLi
(
dNo
, 
GET_FREE_BLOCK_GC
);

733 if(
cutBlock
 !
BLOCK_FAIL
)

734 
vtuDMP
->
d
[
dNo
].
cutBlock
 = currentBlock;

736 
	`as
(!"[WARNING] There isovailable block [WARNING]");

738 if(
vtuBlockMP
->
block
[
dNo
][
cutBlock
].
cutPage
 > 
USER_PAGES_PER_BLOCK
)

739 
	`as
(!"[WARNING] Currentage management fail [WARNING]");

742 
vtuSliAddr
 = 
	`Vg2VTni
(
dNo
, 
cutBlock
, 
vtuBlockMP
->
block
[dNo][cutBlock].
cutPage
);

743 
vtuBlockMP
->
block
[
dNo
][
cutBlock
].
cutPage
++;

744  
vtuSliAddr
;

745 
	}
}

748 
	$FdDFFeSliAoti
()

750 
rgCh
 = 0;

751 
rgWay
 = 0;

752 
rgD
;

754 
rgD
 = 
	`Pcw2VdTni
(
rgCh
, 
rgWay
);

756 if(
rgCh
 !(
USER_CHANNELS
 - 1))

757 
rgCh
 =argetCh + 1;

760 
rgCh
 = 0;

761 
rgWay
 = (rgWay + 1% 
USER_WAYS
;

764  
rgD
;

765 
	}
}

767 
	$InvideOldV
(
logilSliAddr
)

769 
vtuSliAddr
, 
dNo
, 
blockNo
;

771 
vtuSliAddr
 = 
logilSliMP
->
logilSli
[
logilSliAddr
].virtualSliceAddr;

773 if(
vtuSliAddr
 !
VSA_NONE
)

775 if(
vtuSliMP
->
vtuSli
[
vtuSliAddr
].
logilSliAddr
 !=ogicalSliceAddr)

778 
dNo
 = 
	`V2VdTni
(
vtuSliAddr
);

779 
blockNo
 = 
	`V2VblockTni
(
vtuSliAddr
);

782 
	`SeiveGFromGcViimLi
(
dNo
, 
blockNo
);

783 
vtuBlockMP
->
block
[
dNo
][
blockNo
].
vidSliC
++;

784 
logilSliMP
->
logilSli
[
logilSliAddr
].
vtuSliAddr
 = 
VSA_NONE
;

786 
	`PutToGcViimLi
(
dNo
, 
blockNo
, 
vtuBlockMP
->
block
[dNo][blockNo].
vidSliC
);

789 
	}
}

792 
	$EBlock
(
dNo
, 
blockNo
)

794 
geNo
, 
vtuSliAddr
, 
qSlTag
;

796 
qSlTag
 = 
	`GFromFeReqQ
();

798 
qPoP
->
qPo
[
qSlTag
].
qTy
 = 
REQ_TYPE_NAND
;

799 
qPoP
->
qPo
[
qSlTag
].
qCode
 = 
REQ_CODE_ERASE
;

800 
qPoP
->
qPo
[
qSlTag
].
qO
.
ndAddr
 = 
REQ_OPT_NAND_ADDR_VSA
;

801 
qPoP
->
qPo
[
qSlTag
].
qO
.
daBufFm
 = 
REQ_OPT_DATA_BUF_NONE
;

802 
qPoP
->
qPo
[
qSlTag
].
qO
.
rowAddrDdcyCheck
 = 
REQ_OPT_ROW_ADDR_DEPENDENCY_CHECK
;

803 
qPoP
->
qPo
[
qSlTag
].
qO
.
blockS
 = 
REQ_OPT_BLOCK_SPACE_MAIN
;

804 
qPoP
->
qPo
[
qSlTag
].
qO
.
fUnAcss
 = 
REQ_OPT_FORCE_UNIT_ACCESS_OFF
;

805 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
vtuSliAddr
 = 
	`Vg2VTni
(
dNo
, 
blockNo
, 0);

806 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
ogmmedPageC
 = 
vtuBlockMP
->
block
[
dNo
][
blockNo
].
cutPage
;

808 
	`SeLowLevReqQ
(
qSlTag
);

811 
vtuBlockMP
->
block
[
dNo
][
blockNo
].

 = 1;

812 
vtuBlockMP
->
block
[
dNo
][
blockNo
].
aC
++;

813 
vtuBlockMP
->
block
[
dNo
][
blockNo
].
vidSliC
 = 0;

814 
vtuBlockMP
->
block
[
dNo
][
blockNo
].
cutPage
 = 0;

816 
	`PutToFbLi
(
dNo
, 
blockNo
);

818 
geNo
=0;ageNo<
USER_PAGES_PER_BLOCK
;ageNo++)

820 
vtuSliAddr
 = 
	`Vg2VTni
(
dNo
, 
blockNo
, 
geNo
);

821 
vtuSliMP
->
vtuSli
[
vtuSliAddr
].
logilSliAddr
 = 
LSA_NONE
;

823 
	}
}

825 
	$PutToFbLi
(
dNo
, 
blockNo
)

827 if(
vtuDMP
->
d
[
dNo
].
FeBlock
 !
BLOCK_NONE
)

829 
vtuBlockMP
->
block
[
dNo
][
blockNo
].
evBlock
 = 
vtuDMP
->
d
[dNo].
FeBlock
;

830 
vtuBlockMP
->
block
[
dNo
][
blockNo
].
xtBlock
 = 
BLOCK_NONE
;

831 
vtuBlockMP
->
block
[
dNo
][
vtuDMP
->
d
[dNo].
FeBlock
].
xtBlock
 = 
blockNo
;

832 
vtuDMP
->
d
[
dNo
].
FeBlock
 = 
blockNo
;

836 
vtuBlockMP
->
block
[
dNo
][
blockNo
].
evBlock
 = 
BLOCK_NONE
;

837 
vtuBlockMP
->
block
[
dNo
][
blockNo
].
xtBlock
 = 
BLOCK_NONE
;

838 
vtuDMP
->
d
[
dNo
].
hdFeBlock
 = 
blockNo
;

839 
vtuDMP
->
d
[
dNo
].
FeBlock
 = 
blockNo
;

842 
vtuDMP
->
d
[
dNo
].
BlockC
++;

843 
	}
}

845 
	$GFromFbLi
(
dNo
, 
gFeBlockOi
)

847 
eviedBlockNo
;

849 
eviedBlockNo
 = 
vtuDMP
->
d
[
dNo
].
hdFeBlock
;

851 if(
gFeBlockOi
 =
GET_FREE_BLOCK_NORMAL
)

853 if(
vtuDMP
->
d
[
dNo
].
BlockC
 <
RESERVED_FREE_BLOCK_COUNT
)

854  
BLOCK_FAIL
;

856 if(
gFeBlockOi
 =
GET_FREE_BLOCK_GC
)

858 if(
eviedBlockNo
 =
BLOCK_NONE
)

859  
BLOCK_FAIL
;

862 
	`as
(!"[WARNING] Wrong getFreeBlockOption [WARNING]");

864 if(
vtuBlockMP
->
block
[
dNo
][
eviedBlockNo
].
xtBlock
 !
BLOCK_NONE
)

866 
vtuDMP
->
d
[
dNo
].
hdFeBlock
 = 
vtuBlockMP
->
block
[dNo][
eviedBlockNo
].
xtBlock
;

867 
vtuBlockMP
->
block
[
dNo
][vtuBlockMP->block[dNo][
eviedBlockNo
].
xtBlock
].
evBlock
 = 
BLOCK_NONE
;

871 
vtuDMP
->
d
[
dNo
].
hdFeBlock
 = 
BLOCK_NONE
;

872 
vtuDMP
->
d
[
dNo
].
FeBlock
 = 
BLOCK_NONE
;

875 
vtuBlockMP
->
block
[
dNo
][
eviedBlockNo
].

 = 0;

876 
vtuDMP
->
d
[
dNo
].
BlockC
--;

878 
vtuBlockMP
->
block
[
dNo
][
eviedBlockNo
].
xtBlock
 = 
BLOCK_NONE
;

879 
vtuBlockMP
->
block
[
dNo
][
eviedBlockNo
].
evBlock
 = 
BLOCK_NONE
;

881  
eviedBlockNo
;

882 
	}
}

885 
	$UpdePhyBlockMFGrownBadBlock
(
dNo
, 
phyBlockNo
)

887 
phyBlockMP
->
phyBlock
[
dNo
][
phyBlockNo
].
bad
 = 
BLOCK_STATE_BAD
;

889 
bbtInfoMP
->
bbtInfo
[
dNo
].
grownBadUpde
 = 
BBT_INFO_GROWN_BAD_UPDATE_BOOKED
;

890 
	}
}

893 
	$UpdeBadBlockTabFGrownBadBlock
(
mpBufAddr
)

895 
dNo
, 
phyBlockNo
, 
mpBbtBufBaAddr
, 
mpBbtBufErySize
;

896 
mpBbtBufAddr
[
USER_DIES
];

897 
dS
[
USER_DIES
];

898 * 
bbtUpd
;

901 
mpBbtBufBaAddr
 = 
mpBufAddr
;

902 
mpBbtBufErySize
 = 
BYTES_PER_DATA_REGION_OF_PAGE_FOR_BB
 + 
BYTES_PER_SPARE_REGION_OF_PAGE
;

903 
dNo
 = 0; dN< 
USER_DIES
; dieNo++)

904 
mpBbtBufAddr
[
dNo
] = 
mpBbtBufBaAddr
 + dN* 
USED_PAGES_FOR_BAD_BLOCK_TABLE_PER_DIE
 * 
mpBbtBufErySize
;

907 
dNo
 = 0; dN< 
USER_DIES
; dieNo++)

909 if(
bbtInfoMP
->
bbtInfo
[
dNo
].
grownBadUpde
 =
BBT_INFO_GROWN_BAD_UPDATE_BOOKED
)

911 
phyBlockNo
 = 0;hyBlockN< 
TOTAL_BLOCKS_PER_DIE
;hyBlockNo++)

913 
bbtUpd
 = (*)(
mpBbtBufAddr
[
dNo
] + 
phyBlockNo
);

915 if(
phyBlockNo
 !
bbtInfoMP
->
bbtInfo
[
dNo
].
phyBlock
)

916 *
bbtUpd
 = 
phyBlockMP
->
phyBlock
[
dNo
][
phyBlockNo
].
bad
;

918 *
bbtUpd
 = 
BLOCK_STATE_NORMAL
;

921 
dS
[
dNo
] = 
DIE_STATE_BAD_BLOCK_TABLE_UPDATE
;

924 
dS
[
dNo
] = 
DIE_STATE_BAD_BLOCK_TABLE_HOLD
;

928 
	`SaveBadBlockTab
(
dS
, 
mpBbtBufAddr
, 
mpBbtBufErySize
);

929 
	}
}

	@address_translation.h

47 #ide
ADDRESS_TRANSLATION_H_


48 
	#ADDRESS_TRANSLATION_H_


	)

50 
	~"l_cfig.h
"

51 
	~"nvme/nvme.h
"

53 
	#LSA_NONE
 0xffffffff

	)

54 
	#LSA_FAIL
 0xffffffff

	)

56 
	#VSA_NONE
 0xffffffff

	)

57 
	#VSA_FAIL
 0xffffffff

	)

59 
	#PAGE_NONE
 0xffff

	)

61 
	#BLOCK_NONE
 0xffff

	)

62 
	#BLOCK_FAIL
 0xffff

	)

64 
	#DIE_NONE
 0xff

	)

65 
	#DIE_FAIL
 0xff

	)

67 
	#RESERVED_FREE_BLOCK_COUNT
 0x1

	)

69 
	#GET_FREE_BLOCK_NORMAL
 0x0

	)

70 
	#GET_FREE_BLOCK_GC
 0x1

	)

72 
	#BLOCK_STATE_NORMAL
 0

	)

73 
	#BLOCK_STATE_BAD
 1

	)

75 
	#DIE_STATE_BAD_BLOCK_TABLE_NOT_EXIST
 0

	)

76 
	#DIE_STATE_BAD_BLOCK_TABLE_EXIST
 1

	)

78 
	#BAD_BLOCK_TABLE_MAKER_IDLE
 0

	)

79 
	#BAD_BLOCK_TABLE_MAKER_TRIGGER
 1

	)

80 
	#DIE_STATE_BAD_BLOCK_TABLE_HOLD
 2

	)

81 
	#DIE_STATE_BAD_BLOCK_TABLE_UPDATE
 3

	)

83 
	#CLEAN_DATA_IN_BYTE
 0xff

	)

85 
	#USED_PAGES_FOR_BAD_BLOCK_TABLE_PER_DIE
 (
TOTAL_BLOCKS_PER_DIE
 / 
BYTES_PER_DATA_REGION_OF_PAGE_FOR_BB
 + 1)

	)

86 
	#DATA_SIZE_OF_BAD_BLOCK_TABLE_PER_DIE
 (
TOTAL_BLOCKS_PER_DIE
)

	)

87 
	#START_PAGE_NO_OF_BAD_BLOCK_TABLE_BLOCK
 (1)

88 

	)

89 
	#BBT_INFO_GROWN_BAD_UPDATE_NONE
 0

	)

90 
	#BBT_INFO_GROWN_BAD_UPDATE_BOOKED
 1

	)

93 
	#V2VdTni
(
vtuSliAddr
((vtuSliAddr% (
USER_DIES
))

	)

94 
	#V2VblockTni
(
vtuSliAddr
(((vtuSliAddr/ (
USER_DIES
)/ (
SLICES_PER_BLOCK
))

	)

95 
	#V2VgeTni
(
vtuSliAddr
(((vtuSliAddr/ (
USER_DIES
)% (
SLICES_PER_BLOCK
))

	)

98 
	#Vg2VTni
(
dNo
, 
blockNo
, 
geNo
((dNo+ (
USER_DIES
)*((blockNo)*(
SLICES_PER_BLOCK
+ (geNo)))

	)

101 
	#Vd2PchTni
(
dNo
((dNo% (
USER_CHANNELS
))

	)

102 
	#Vd2PwayTni
(
dNo
((dNo/ (
USER_CHANNELS
))

	)

103 
	#Vblock2PblockOfTbsTni
(
blockNo
(((blockNo/ (
USER_BLOCKS_PER_LUN
)* (
TOTAL_BLOCKS_PER_LUN
) + ((blockNo) % (USER_BLOCKS_PER_LUN)))

104 
	#Vblock2PblockOfMbsTni
(
blockNo
(((blockNo/ (
USER_BLOCKS_PER_LUN
)* (
MAIN_BLOCKS_PER_LUN
) + ((blockNo) % (USER_BLOCKS_PER_LUN)))

105 
	#Vge2PlsbPageTni
(
geNo
(ageNo> (0? (2 * (geNo- 1): (0))

	)

108 
	#Pcw2VdTni
(
chNo
, 
wayNo
((chNo+ (wayNo* (
USER_CHANNELS
))

	)

109 
	#PlsbPage2VgeTni
(
geNo
(ageNo> (0? ( (ageNo+ 1/ 2): (0))

	)

112 
	s_LOGICAL_SLICE_ENTRY
 {

113 
	mvtuSliAddr
;

114 } 
	tLOGICAL_SLICE_ENTRY
, *
	tP_LOGICAL_SLICE_ENTRY
;

116 
	s_LOGICAL_SLICE_MAP
 {

117 
LOGICAL_SLICE_ENTRY
 
	mlogilSli
[
SLICES_PER_SSD
];

118 } 
	tLOGICAL_SLICE_MAP
, *
	tP_LOGICAL_SLICE_MAP
;

122 
	s_VIRTUAL_SLICE_ENTRY
 {

123 
	mlogilSliAddr
;

124 } 
	tVIRTUAL_SLICE_ENTRY
, *
	tP_VIRTUAL_SLICE_ENTRY
;

126 
	s_VIRTUAL_SLICE_MAP
 {

127 
VIRTUAL_SLICE_ENTRY
 
	mvtuSli
[
SLICES_PER_SSD
];

128 } 
	tVIRTUAL_SLICE_MAP
, *
	tP_VIRTUAL_SLICE_MAP
;

130 
	s_VIRTUAL_BLOCK_ENTRY
 {

131 
	mbad
 : 1;

132 
	m
 : 1;

133 
	mvidSliC
 : 16;

134 
	mrved0
 :10;

135 
	mcutPage
 : 16;

136 
	maC
 : 16;

137 
	mevBlock
 : 16;

138 
	mxtBlock
 :16;

139 } 
	tVIRTUAL_BLOCK_ENTRY
, *
	tP_VIRTUAL_BLOCK_ENTRY
;

141 
	s_VIRTUAL_BLOCK_MAP
 {

142 
VIRTUAL_BLOCK_ENTRY
 
	mblock
[
USER_DIES
][
USER_BLOCKS_PER_DIE
];

143 } 
	tVIRTUAL_BLOCK_MAP
, *
	tP_VIRTUAL_BLOCK_MAP
;

146 
	s_VIRTUAL_DIE_ENTRY
 {

147 
	mcutBlock
 : 16;

148 
	mhdFeBlock
 : 16;

149 
	mFeBlock
 : 16;

150 
	mBlockC
 : 16;

151 
	mevD
 : 8;

152 
	mxtD
 : 8;

153 
	mrved0
 : 16;

154 } 
	tVIRTUAL_DIE_ENTRY
, *
	tP_VIRTUAL_DIE_ENTRY
;

156 
	s_VIRTUAL_DIE_MAP
 {

157 
VIRTUAL_DIE_ENTRY
 
	md
[
USER_DIES
];

158 } 
	tVIRTUAL_DIE_MAP
, *
	tP_VIRTUAL_DIE_MAP
;

160 
	s_FRRE_BLOCK_ALLOCATION_LIST
 {

161 
	mhdD
 : 8;

162 
	mD
 : 8;

163 
	mrved0
 : 16;

164 } 
	tFRRE_BLOCK_ALLOCATION_LIST
, *
	tP_FRRE_BLOCK_ALLOCATION_LIST
;

166 
	s_BAD_BLOCK_TABLE_INFO_ENTRY
{

167 
	mphyBlock
 : 16;

168 
	mgrownBadUpde
 : 1;

169 
	mrved0
 : 15;

170 } 
	tBAD_BLOCK_TABLE_INFO_ENTRY
, *
	tP_BAD_BLOCK_TABLE_ENTRY
;

172 
	s_BAD_BLOCK_TABLE_INFO_MAP
{

173 
BAD_BLOCK_TABLE_INFO_ENTRY
 
	mbbtInfo
[
USER_DIES
];

174 } 
	tBAD_BLOCK_TABLE_INFO_MAP
, *
	tP_BAD_BLOCK_TABLE_INFO_MAP
;

176 
	s_PHY_BLOCK_ENTRY
 {

177 
	mmdPhyBlock
 : 16;

178 
	mbad
 :1;

179 
	mrved0
 :15;

180 } 
	tPHY_BLOCK_ENTRY
, *
	tP_PHY_BLOCK_ENTRY
;

182 
	s_PHY_BLOCK_MAP
 {

183 
PHY_BLOCK_ENTRY
 
	mphyBlock
[
USER_DIES
][
TOTAL_BLOCKS_PER_DIE
];

184 } 
	tPHY_BLOCK_MAP
, *
	tP_PHY_BLOCK_MAP
;

187 
InAddssM
();

188 
InSliM
();

189 
InBlockDM
();

191 
AddrTnsRd
(
logilSliAddr
);

192 
AddrTnsWre
(
logilSliAddr
);

193 
FdFeVtuSli
();

194 
FdFeVtuSliFGc
(
cyTgDNo
, 
viimBlockNo
);

195 
FdDFFeSliAoti
();

197 
InvideOldV
(
logilSliAddr
);

198 
EBlock
(
dNo
, 
blockNo
);

200 
PutToFbLi
(
dNo
, 
blockNo
);

201 
GFromFbLi
(
dNo
, 
gFeBlockOi
);

203 
UpdePhyBlockMFGrownBadBlock
(
dNo
, 
phyBlockNo
);

204 
UpdeBadBlockTabFGrownBadBlock
(
mpBufAddr
);

207 
P_LOGICAL_SLICE_MAP
 
logilSliMP
;

208 
P_VIRTUAL_SLICE_MAP
 
vtuSliMP
;

209 
P_VIRTUAL_BLOCK_MAP
 
vtuBlockMP
;

210 
P_VIRTUAL_DIE_MAP
 
vtuDMP
;

211 
P_PHY_BLOCK_MAP
 
phyBlockMP
;

212 
P_BAD_BLOCK_TABLE_INFO_MAP
 
bbtInfoMP
;

214 
iAotiTgD
;

215 
mbPbadBlockS
;

216 
	gque_wre
;

	@data_buffer.c

47 
	~"x_tf.h
"

48 
	~<as.h
>

49 
	~"memy_m.h
"

52 
P_DATA_BUF_MAP
 
	gdaBufMP
;

53 
DATA_BUF_LRU_LIST
 
	gdaBufLruLi
;

54 
P_DATA_BUF_HASH_TABLE
 
	gdaBufHashTabP
;

55 
P_TEMPORARY_DATA_BUF_MAP
 
	gmpDaBufMP
;

57 
	$InDaBuf
()

59 
bufEry
;

61 
daBufMP
 = (
P_DATA_BUF_MAP

DATA_BUFFER_MAP_ADDR
;

62 
daBufHashTabP
 = (
P_DATA_BUF_HASH_TABLE
)
DATA_BUFFFER_HASH_TABLE_ADDR
;

63 
mpDaBufMP
 = (
P_TEMPORARY_DATA_BUF_MAP
)
TEMPORARY_DATA_BUFFER_MAP_ADDR
;

65 
bufEry
 = 0; bufEry < 
AVAILABLE_DATA_BUFFER_ENTRY_COUNT
; bufEntry++)

67 
daBufMP
->
daBuf
[
bufEry
].
logilSliAddr
 = 
LSA_NONE
;

68 
daBufMP
->
daBuf
[
bufEry
].
evEry
 = bufEntry-1;

69 
daBufMP
->
daBuf
[
bufEry
].
xtEry
 = bufEntry+1;

70 
daBufMP
->
daBuf
[
bufEry
].
dty
 = 
DATA_BUF_CLEAN
;

71 
daBufMP
->
daBuf
[
bufEry
].
blockgReqTa
 = 
REQ_SLOT_TAG_NONE
;

73 
daBufHashTabP
->
daBufHash
[
bufEry
].
hdEry
 = 
DATA_BUF_NONE
;

74 
daBufHashTabP
->
daBufHash
[
bufEry
].
Ery
 = 
DATA_BUF_NONE
;

75 
daBufMP
->
daBuf
[
bufEry
].
hashPvEry
 = 
DATA_BUF_NONE
;

76 
daBufMP
->
daBuf
[
bufEry
].
hashNextEry
 = 
DATA_BUF_NONE
;

79 
daBufMP
->
daBuf
[0].
evEry
 = 
DATA_BUF_NONE
;

80 
daBufMP
->
daBuf
[
AVAILABLE_DATA_BUFFER_ENTRY_COUNT
 - 1].
xtEry
 = 
DATA_BUF_NONE
;

81 
daBufLruLi
.
hdEry
 = 0 ;

82 
daBufLruLi
.
Ery
 = 
AVAILABLE_DATA_BUFFER_ENTRY_COUNT
 - 1;

84 
bufEry
 = 0; bufEry < 
AVAILABLE_TEMPORARY_DATA_BUFFER_ENTRY_COUNT
; bufEntry++)

85 
mpDaBufMP
->
mpDaBuf
[
bufEry
].
blockgReqTa
 = 
REQ_SLOT_TAG_NONE
;

86 
	}
}

89 
	$CheckDaBufHFShe
(
logilSliAddr
)

91 
bufEry
;

93 
bufEry
 = 
daBufHashTabP
->
daBufHash
[
	`FdDaBufHashTabEry
(
logilSliAddr
)].
hdEry
;

95 ; 
bufEry
 !
DATA_BUF_NONE
; bufEry = 
daBufMP
->
daBuf
[bufEry].
hashNextEry
)

97 if(
daBufMP
->
daBuf
[
bufEry
].
logilSliAddr
 ==ogicalSliceAddr)

99  
bufEry
;

102  
DATA_BUF_FAIL
;

103 
	}
}

105 
	$AoDaBufHfShe
(
logilSliAddr
)

107 
bufEry
;

109 
bufEry
 = 
daBufHashTabP
->
daBufHash
[
	`FdDaBufHashTabEry
(
logilSliAddr
)].
hdEry
;

111 
bufEry
 !
DATA_BUF_NONE
)

113 if(
daBufMP
->
daBuf
[
bufEry
].
logilSliAddr
 ==ogicalSliceAddr)

115 if((
daBufMP
->
daBuf
[
bufEry
].
xtEry
 !
DATA_BUF_NONE
&& (daBufMP->daBuf[bufEry].
evEry
 != DATA_BUF_NONE))

117 
daBufMP
->
daBuf
[daBufMP->daBuf[
bufEry
].
evEry
].
xtEry
 = dataBufMapPtr->dataBuf[bufEntry].nextEntry;

118 
daBufMP
->
daBuf
[daBufMP->daBuf[
bufEry
].
xtEry
].
evEry
 = dataBufMapPtr->dataBuf[bufEntry].prevEntry;

120 if((
daBufMP
->
daBuf
[
bufEry
].
xtEry
 =
DATA_BUF_NONE
&& (daBufMP->daBuf[bufEry].
evEry
 != DATA_BUF_NONE))

122 
daBufMP
->
daBuf
[daBufMP->daBuf[
bufEry
].
evEry
].
xtEry
 = 
DATA_BUF_NONE
;

123 
daBufLruLi
.
Ery
 = 
daBufMP
->
daBuf
[
bufEry
].
evEry
;

125 if((
daBufMP
->
daBuf
[
bufEry
].
xtEry
 !
DATA_BUF_NONE
&& (daBufMP->daBuf[bufEry].
evEry
== DATA_BUF_NONE))

127 
daBufMP
->
daBuf
[daBufMP->daBuf[
bufEry
].
xtEry
].
evEry
 = 
DATA_BUF_NONE
;

128 
daBufLruLi
.
hdEry
 = 
daBufMP
->
daBuf
[
bufEry
].
xtEry
;

132 
daBufLruLi
.
Ery
 = 
DATA_BUF_NONE
;

133 
daBufLruLi
.
hdEry
 = 
DATA_BUF_NONE
;

136 if(
daBufLruLi
.
hdEry
 !
DATA_BUF_NONE
)

138 
daBufMP
->
daBuf
[
bufEry
].
evEry
 = 
DATA_BUF_NONE
;

139 
daBufMP
->
daBuf
[
bufEry
].
xtEry
 = 
daBufLruLi
.
hdEry
;

140 
daBufMP
->
daBuf
[
daBufLruLi
.
hdEry
].
evEry
 = 
bufEry
;

141 
daBufLruLi
.
hdEry
 = 
bufEry
;

145 
daBufMP
->
daBuf
[
bufEry
].
evEry
 = 
DATA_BUF_NONE
;

146 
daBufMP
->
daBuf
[
bufEry
].
xtEry
 = 
DATA_BUF_NONE
;

147 
daBufLruLi
.
hdEry
 = 
bufEry
;

148 
daBufLruLi
.
Ery
 = 
bufEry
;

154  
bufEry
;

157 
bufEry
 = 
daBufMP
->
daBuf
[bufEry].
hashNextEry
;

160  
DATA_BUF_FAIL
;

161 
	}
}

162 
	$CheckDaBufH
(
qSlTag
)

164 
bufEry
, 
logilSliAddr
;

166 
logilSliAddr
 = 
qPoP
->
qPo
[
qSlTag
].logicalSliceAddr;

167 
bufEry
 = 
daBufHashTabP
->
daBufHash
[
	`FdDaBufHashTabEry
(
logilSliAddr
)].
hdEry
;

169 ; 
bufEry
 !
DATA_BUF_NONE
; bufEry = 
daBufMP
->
daBuf
[bufEry].
hashNextEry
)

171 if(
daBufMP
->
daBuf
[
bufEry
].
logilSliAddr
 ==ogicalSliceAddr)

173  
bufEry
;

176  
DATA_BUF_FAIL
;

177 
	}
}

179 
	$AoDaBufH
(
qSlTag
)

181 
bufEry
, 
logilSliAddr
;

183 
logilSliAddr
 = 
qPoP
->
qPo
[
qSlTag
].logicalSliceAddr;

184 
bufEry
 = 
daBufHashTabP
->
daBufHash
[
	`FdDaBufHashTabEry
(
logilSliAddr
)].
hdEry
;

186 
bufEry
 !
DATA_BUF_NONE
)

188 if(
daBufMP
->
daBuf
[
bufEry
].
logilSliAddr
 ==ogicalSliceAddr)

190 if((
daBufMP
->
daBuf
[
bufEry
].
xtEry
 !
DATA_BUF_NONE
&& (daBufMP->daBuf[bufEry].
evEry
 != DATA_BUF_NONE))

192 
daBufMP
->
daBuf
[daBufMP->daBuf[
bufEry
].
evEry
].
xtEry
 = dataBufMapPtr->dataBuf[bufEntry].nextEntry;

193 
daBufMP
->
daBuf
[daBufMP->daBuf[
bufEry
].
xtEry
].
evEry
 = dataBufMapPtr->dataBuf[bufEntry].prevEntry;

195 if((
daBufMP
->
daBuf
[
bufEry
].
xtEry
 =
DATA_BUF_NONE
&& (daBufMP->daBuf[bufEry].
evEry
 != DATA_BUF_NONE))

197 
daBufMP
->
daBuf
[daBufMP->daBuf[
bufEry
].
evEry
].
xtEry
 = 
DATA_BUF_NONE
;

198 
daBufLruLi
.
Ery
 = 
daBufMP
->
daBuf
[
bufEry
].
evEry
;

200 if((
daBufMP
->
daBuf
[
bufEry
].
xtEry
 !
DATA_BUF_NONE
&& (daBufMP->daBuf[bufEry].
evEry
== DATA_BUF_NONE))

202 
daBufMP
->
daBuf
[daBufMP->daBuf[
bufEry
].
xtEry
].
evEry
 = 
DATA_BUF_NONE
;

203 
daBufLruLi
.
hdEry
 = 
daBufMP
->
daBuf
[
bufEry
].
xtEry
;

207 
daBufLruLi
.
Ery
 = 
DATA_BUF_NONE
;

208 
daBufLruLi
.
hdEry
 = 
DATA_BUF_NONE
;

211 if(
daBufLruLi
.
hdEry
 !
DATA_BUF_NONE
)

213 
daBufMP
->
daBuf
[
bufEry
].
evEry
 = 
DATA_BUF_NONE
;

214 
daBufMP
->
daBuf
[
bufEry
].
xtEry
 = 
daBufLruLi
.
hdEry
;

215 
daBufMP
->
daBuf
[
daBufLruLi
.
hdEry
].
evEry
 = 
bufEry
;

216 
daBufLruLi
.
hdEry
 = 
bufEry
;

220 
daBufMP
->
daBuf
[
bufEry
].
evEry
 = 
DATA_BUF_NONE
;

221 
daBufMP
->
daBuf
[
bufEry
].
xtEry
 = 
DATA_BUF_NONE
;

222 
daBufLruLi
.
hdEry
 = 
bufEry
;

223 
daBufLruLi
.
Ery
 = 
bufEry
;

226  
bufEry
;

229 
bufEry
 = 
daBufMP
->
daBuf
[bufEry].
hashNextEry
;

232  
DATA_BUF_FAIL
;

233 
	}
}

235 
	$AoDaBufMiss
()

237 
eviedEry
 = 
daBufLruLi
.
Ery
;

239 if(
eviedEry
 =
DATA_BUF_NONE
)

240 
	`as
(!"[WARNING] There iso valid bufferntry [WARNING]");

242 if(
daBufMP
->
daBuf
[
eviedEry
].
evEry
 !
DATA_BUF_NONE
)

244 
daBufMP
->
daBuf
[daBufMP->daBuf[
eviedEry
].
evEry
].
xtEry
 = 
DATA_BUF_NONE
;

245 
daBufLruLi
.
Ery
 = 
daBufMP
->
daBuf
[
eviedEry
].
evEry
;

247 
daBufMP
->
daBuf
[
eviedEry
].
evEry
 = 
DATA_BUF_NONE
;

248 
daBufMP
->
daBuf
[
eviedEry
].
xtEry
 = 
daBufLruLi
.
hdEry
;

249 
daBufMP
->
daBuf
[
daBufLruLi
.
hdEry
].
evEry
 = 
eviedEry
;

250 
daBufLruLi
.
hdEry
 = 
eviedEry
;

255 
daBufMP
->
daBuf
[
eviedEry
].
evEry
 = 
DATA_BUF_NONE
;

256 
daBufMP
->
daBuf
[
eviedEry
].
xtEry
 = 
DATA_BUF_NONE
;

257 
daBufLruLi
.
hdEry
 = 
eviedEry
;

258 
daBufLruLi
.
Ery
 = 
eviedEry
;

261 
	`SeiveGFromDaBufHashLi
(
eviedEry
);

263  
eviedEry
;

264 
	}
}

267 
	$UpdeDaBufEryInfoBlockgReq
(
bufEry
, 
qSlTag
)

269 if(
daBufMP
->
daBuf
[
bufEry
].
blockgReqTa
 !
REQ_SLOT_TAG_NONE
)

271 
qPoP
->
qPo
[
qSlTag
].
evBlockgReq
 = 
daBufMP
->
daBuf
[
bufEry
].
blockgReqTa
;

272 
qPoP
->
qPo
[qPoP->qPo[
qSlTag
].
evBlockgReq
].
xtBlockgReq
 =eqSlotTag;

275 
daBufMP
->
daBuf
[
bufEry
].
blockgReqTa
 = 
qSlTag
;

276 
	}
}

279 
	$AoTempDaBuf
(
dNo
)

281  
dNo
;

282 
	}
}

285 
	$UpdeTempDaBufEryInfoBlockgReq
(
bufEry
, 
qSlTag
)

288 if(
mpDaBufMP
->
mpDaBuf
[
bufEry
].
blockgReqTa
 !
REQ_SLOT_TAG_NONE
)

290 
qPoP
->
qPo
[
qSlTag
].
evBlockgReq
 = 
mpDaBufMP
->
mpDaBuf
[
bufEry
].
blockgReqTa
;

291 
qPoP
->
qPo
[qPoP->qPo[
qSlTag
].
evBlockgReq
].
xtBlockgReq
 =eqSlotTag;

294 
mpDaBufMP
->
mpDaBuf
[
bufEry
].
blockgReqTa
 = 
qSlTag
;

295 
	}
}

297 
	$PutToDaBufHashLi
(
bufEry
)

299 
hashEry
;

301 
hashEry
 = 
	`FdDaBufHashTabEry
(
daBufMP
->
daBuf
[
bufEry
].
logilSliAddr
);

303 if(
daBufHashTabP
->
daBufHash
[
hashEry
].
Ery
 !
DATA_BUF_NONE
)

305 
daBufMP
->
daBuf
[
bufEry
].
hashPvEry
 = 
daBufHashTabP
->
daBufHash
[
hashEry
].
Ery
 ;

306 
daBufMP
->
daBuf
[
bufEry
].
hashNextEry
 = 
REQ_SLOT_TAG_NONE
;

307 
daBufMP
->
daBuf
[
daBufHashTabP
->
daBufHash
[
hashEry
].
Ery
].
hashNextEry
 = 
bufEry
;

308 
daBufHashTabP
->
daBufHash
[
hashEry
].
Ery
 = 
bufEry
;

312 
daBufMP
->
daBuf
[
bufEry
].
hashPvEry
 = 
REQ_SLOT_TAG_NONE
;

313 
daBufMP
->
daBuf
[
bufEry
].
hashNextEry
 = 
REQ_SLOT_TAG_NONE
;

314 
daBufHashTabP
->
daBufHash
[
hashEry
].
hdEry
 = 
bufEry
;

315 
daBufHashTabP
->
daBufHash
[
hashEry
].
Ery
 = 
bufEry
;

317 
	}
}

320 
	$SeiveGFromDaBufHashLi
(
bufEry
)

322 if(
daBufMP
->
daBuf
[
bufEry
].
logilSliAddr
 !
LSA_NONE
)

324 
evBufEry
, 
xtBufEry
, 
hashEry
;

326 
evBufEry
 = 
daBufMP
->
daBuf
[
bufEry
].
hashPvEry
;

327 
xtBufEry
 = 
daBufMP
->
daBuf
[
bufEry
].
hashNextEry
;

328 
hashEry
 = 
	`FdDaBufHashTabEry
(
daBufMP
->
daBuf
[
bufEry
].
logilSliAddr
);

330 if((
xtBufEry
 !
DATA_BUF_NONE
&& (
evBufEry
 != DATA_BUF_NONE))

332 
daBufMP
->
daBuf
[
evBufEry
].
hashNextEry
 = 
xtBufEry
;

333 
daBufMP
->
daBuf
[
xtBufEry
].
hashPvEry
 = 
evBufEry
;

335 if((
xtBufEry
 =
DATA_BUF_NONE
&& (
evBufEry
 != DATA_BUF_NONE))

337 
daBufMP
->
daBuf
[
evBufEry
].
hashNextEry
 = 
DATA_BUF_NONE
;

338 
daBufHashTabP
->
daBufHash
[
hashEry
].
Ery
 = 
evBufEry
;

340 if((
xtBufEry
 !
DATA_BUF_NONE
&& (
evBufEry
 == DATA_BUF_NONE))

342 
daBufMP
->
daBuf
[
xtBufEry
].
hashPvEry
 = 
DATA_BUF_NONE
;

343 
daBufHashTabP
->
daBufHash
[
hashEry
].
hdEry
 = 
xtBufEry
;

347 
daBufHashTabP
->
daBufHash
[
hashEry
].
hdEry
 = 
DATA_BUF_NONE
;

348 
daBufHashTabP
->
daBufHash
[
hashEry
].
Ery
 = 
DATA_BUF_NONE
;

351 
	}
}

	@data_buffer.h

47 #ide
DATA_BUFFER_H_


48 
	#DATA_BUFFER_H_


	)

50 
	~"l_cfig.h
"

52 
	#AVAILABLE_DATA_BUFFER_ENTRY_COUNT
 (16 * 
USER_DIES
)

	)

53 
	#AVAILABLE_TEMPORARY_DATA_BUFFER_ENTRY_COUNT
 (
USER_DIES
)

	)

55 
	#DATA_BUF_NONE
 0xffff

	)

56 
	#DATA_BUF_FAIL
 0xffff

	)

57 
	#DATA_BUF_DIRTY
 1

	)

58 
	#DATA_BUF_CLEAN
 0

	)

60 
	#FdDaBufHashTabEry
(
logilSliAddr
(ogilSliAddr% 
AVAILABLE_DATA_BUFFER_ENTRY_COUNT
)

	)

62 
	#BYTES_PER_DATA_REGION_OF_SLICE_FOR_DATA_BUFFER
 (16384)

63 

	)

64 
	s_DATA_BUF_ENTRY
 {

65 
	mlogilSliAddr
;

66 
	mevEry
 : 16;

67 
	mxtEry
 : 16;

68 
	mblockgReqTa
 : 16;

69 
	mhashPvEry
 : 16;

70 
	mhashNextEry
 : 16;

71 
	mdty
 : 1;

72 
	mrved0
 : 15;

73 } 
	tDATA_BUF_ENTRY
, *
	tP_DATA_BUF_ENTRY
;

75 
	s_DATA_BUF_MAP
{

76 
DATA_BUF_ENTRY
 
	mdaBuf
[
AVAILABLE_DATA_BUFFER_ENTRY_COUNT
];

77 } 
	tDATA_BUF_MAP
, *
	tP_DATA_BUF_MAP
;

79 
	s_DATA_BUF_LRU_LIST
 {

80 
	mhdEry
 : 16;

81 
	mEry
 : 16;

82 } 
	tDATA_BUF_LRU_LIST
, *
	tP_DATA_BUF_LRU_LIST
;

84 
	s_DATA_BUF_HASH_ENTRY
{

85 
	mhdEry
 : 16;

86 
	mEry
 : 16;

87 } 
	tDATA_BUF_HASH_ENTRY
, *
	tP_DATA_BUF_HASH_ENTRY
;

90 
	s_DATA_BUF_HASH_TABLE
{

91 
DATA_BUF_HASH_ENTRY
 
	mdaBufHash
[
AVAILABLE_DATA_BUFFER_ENTRY_COUNT
];

92 } 
	tDATA_BUF_HASH_TABLE
, *
	tP_DATA_BUF_HASH_TABLE
;

95 
	s_TEMPORARY_DATA_BUF_ENTRY
 {

96 
	mblockgReqTa
 : 16;

97 
	mrved0
 : 16;

98 } 
	tTEMPORARY_DATA_BUF_ENTRY
, *
	tP_TEMPORARY_DATA_BUF_ENTRY
;

100 
	s_TEMPORARY_DATA_BUF_MAP
{

101 
TEMPORARY_DATA_BUF_ENTRY
 
	mmpDaBuf
[
AVAILABLE_TEMPORARY_DATA_BUFFER_ENTRY_COUNT
];

102 } 
	tTEMPORARY_DATA_BUF_MAP
, *
	tP_TEMPORARY_DATA_BUF_MAP
;

104 
InDaBuf
();

105 
CheckDaBufH
(
qSlTag
);

106 
AoDaBufH
(
qSlTag
);

107 
AoDaBufMiss
();

108 
UpdeDaBufEryInfoBlockgReq
(
bufEry
, 
qSlTag
);

110 
AoTempDaBuf
(
dNo
);

111 
UpdeTempDaBufEryInfoBlockgReq
(
bufEry
, 
qSlTag
);

113 
PutToDaBufHashLi
(
bufEry
);

114 
SeiveGFromDaBufHashLi
(
bufEry
);

116 
P_DATA_BUF_MAP
 
daBufMP
;

117 
DATA_BUF_LRU_LIST
 
daBufLruLi
;

118 
P_DATA_BUF_HASH_TABLE
 
daBufHashTab
;

119 
P_TEMPORARY_DATA_BUF_MAP
 
mpDaBufMP
;

122 
CheckDaBufHFShe
(
logilSliAddr
);

123 
AoDaBufHfShe
(
logilSliAddr
);

	@ftl_config.c

50 
	~<as.h
>

51 
	~"x_tf.h
"

52 
	~"memy_m.h
"

53 
	~"t4nsc_ucode.h
"

54 
	~"nsc_driv.h
"

56 
	gageCacy_L
;

57 
T4REGS
 
	gchCReg
[
USER_CHANNELS
];

60 
	gg_l_num_wre
;

61 
	gg_l_num_gc
;

62 
	gg_l_num_a
;

63 
	gg_l_num_cy_back
;

64 
	gg_l_num_gh_gc
;

65 
	gg_l_num_gh_
;

66 
	gg_l_num_gh_wre
;

67 
	gg_l_num_ho_wre
;

69 
	gg_l_num_im
;

70 
	gim_ag
;

72 
	$InFTL
()

74 
	`CheckCfigRerii
();

76 
	`InChCReg
();

77 
	`InReqPo
();

78 
	`InDdcyTab
();

79 
	`InReqSchedur
();

80 
	`InNdAay
();

81 
	`InAddssM
();

82 
	`InDaBuf
();

83 
	`InGcViimM
();

86 
g_l_num_im
 = 0;

87 
im_ag
 = 1;

89 if(
USER_BLOCKS_PER_LUN
 > 3072)

90 
ageCacy_L
 = (
MB_PER_SSD
 - (
MB_PER_MIN_FREE_BLOCK_SPACE
 + 
mbPbadBlockS
 + 
MB_PER_OVER_PROVISION_BLOCK_SPACE
)* ((1024*1024/ 
BYTES_PER_NVME_BLOCK
);

92 
ageCacy_L
 = (
MB_PER_SSD
 - (
MB_PER_MIN_FREE_BLOCK_SPACE
 + 
MB_PER_OVER_PROVISION_BLOCK_SPACE
)* ((1024*1024/ 
BYTES_PER_NVME_BLOCK
);

94 
	`x_tf
("[ stagcy %d MB ]\r\n", 
ageCacy_L
 / ((1024*1024/ 
BYTES_PER_NVME_BLOCK
));

95 
	`x_tf
("[%d By/dgi oge]\r\n", 
BYTES_PER_DATA_REGION_OF_PAGE
);

96 
	`x_tf
("[ ftl configuration complete. ]\r\n");

97 
	}
}

99 
	$nfc_l_ucode
(* 
bm0
)

101 
i
;

102 
i
 = 0; i < 
T4NSCu_Comm_CodeWdLgth
; i++)

104 
bm0
[
i
] = 
T4NSCuCode_Comm
[i];

106 
i
 = 0; i < 
T4NSCu_PϚOps_CodeWdLgth
; i++)

108 
bm0
[
T4NSCu_Comm_CodeWdLgth
 + 
i
] = 
T4NSCuCode_PϚOps
[i];

110 
	}
}

112 
	gNSCS
[] = {

113 
NSC_0_BASEADDR
,

114 
NSC_1_BASEADDR
,

115 
NSC_2_BASEADDR
,

116 
NSC_3_BASEADDR
,

117 
NSC_4_BASEADDR
,

118 
NSC_5_BASEADDR
,

119 
NSC_6_BASEADDR
,

120 
NSC_7_BASEADDR
,

123 
	gNSC_UCODES
[] = {

124 
NSC_0_UCODEADDR
,

125 
NSC_1_UCODEADDR
,

126 
NSC_2_UCODEADDR
,

127 
NSC_3_UCODEADDR
,

128 
NSC_4_UCODEADDR
,

129 
NSC_5_UCODEADDR
,

130 
NSC_6_UCODEADDR
,

131 
NSC_7_UCODEADDR


134 
	$InChCReg
()

136 
i
;

137 if(
USER_CHANNELS
 < 1)

138 
	`as
(!"[WARNING] Configuration Error: Channel [WARNING]");

140 
i
 = 0; i < 
USER_CHANNELS
; i++)

142 
	`nfc_l_ucode
((*)
NSC_UCODES
[
i
]);

143 
	`V2FInlizeHd
(&
chCReg
[
i
], (*)
NSCS
[i]);

144 
	`nfc_t_dqs_day
(
i
, 28);

151 
	}
}

153 
	$InNdAay
()

155 
chNo
, 
wayNo
, 
qSlTag
;

156 
i
;

158 
chNo
=0; chNo<
USER_CHANNELS
; ++chNo)

159 
wayNo
=0; wayNo<
USER_WAYS
; ++wayNo)

161 
qSlTag
 = 
	`GFromFeReqQ
();

163 
qPoP
->
qPo
[
qSlTag
].
qTy
 = 
REQ_TYPE_NAND
;

164 
qPoP
->
qPo
[
qSlTag
].
qCode
 = 
REQ_CODE_RESET
;

165 
qPoP
->
qPo
[
qSlTag
].
qO
.
ndAddr
 = 
REQ_OPT_NAND_ADDR_PHY_ORG
;

166 
qPoP
->
qPo
[
qSlTag
].
qO
.
daBufFm
 = 
REQ_OPT_DATA_BUF_NONE
;

167 
qPoP
->
qPo
[
qSlTag
].
qO
.
rowAddrDdcyCheck
 = 
REQ_OPT_ROW_ADDR_DEPENDENCY_NONE
;

168 
qPoP
->
qPo
[
qSlTag
].
qO
.
blockS
 = 
REQ_OPT_BLOCK_SPACE_TOTAL
;

169 
qPoP
->
qPo
[
qSlTag
].
qO
.
fUnAcss
 = 
REQ_OPT_FORCE_UNIT_ACCESS_OFF
;

170 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
physilCh
 = 
chNo
;

171 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
physilWay
 = 
wayNo
;

172 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
physilBlock
 = 0;

173 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
physilPage
 = 0;

174 
qPoP
->
qPo
[
qSlTag
].
evBlockgReq
 = 
REQ_SLOT_TAG_NONE
;

176 
	`SeLowLevReqQ
(
qSlTag
);

178 
qSlTag
 = 
	`GFromFeReqQ
();

180 
qPoP
->
qPo
[
qSlTag
].
qTy
 = 
REQ_TYPE_NAND
;

181 
qPoP
->
qPo
[
qSlTag
].
qCode
 = 
REQ_CODE_SET_FEATURE
;

182 
qPoP
->
qPo
[
qSlTag
].
qO
.
ndAddr
 = 
REQ_OPT_NAND_ADDR_PHY_ORG
;

183 
qPoP
->
qPo
[
qSlTag
].
qO
.
daBufFm
 = 
REQ_OPT_DATA_BUF_NONE
;

184 
qPoP
->
qPo
[
qSlTag
].
qO
.
rowAddrDdcyCheck
 = 
REQ_OPT_ROW_ADDR_DEPENDENCY_NONE
;

185 
qPoP
->
qPo
[
qSlTag
].
qO
.
blockS
 = 
REQ_OPT_BLOCK_SPACE_TOTAL
;

186 
qPoP
->
qPo
[
qSlTag
].
qO
.
fUnAcss
 = 
REQ_OPT_FORCE_UNIT_ACCESS_OFF
;

187 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
physilCh
 = 
chNo
;

188 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
physilWay
 = 
wayNo
;

189 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
physilBlock
 = 0;

190 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
physilPage
 = 0;

191 
qPoP
->
qPo
[
qSlTag
].
evBlockgReq
 = 
REQ_SLOT_TAG_NONE
;

193 
	`SeLowLevReqQ
(
qSlTag
);

196 
	`SyncALowLevReqDe
();

198 
i
 = 0; i < 
USER_CHANNELS
; i++)

200 
j
;

201 * 
idDa
 = (*)(
TEMPORARY_PAY_LOAD_ADDR
 + 16);

202 
	`V2FRdIdSync
(&
chCReg
[
i
], 0, 
idDa
);

203 
	`tf
("Ch %d RdId: ", 
i
);

204 
j
 = 0; j < 6;j ++)

205 
	`tf
("%x ", 
idDa
[
j
]);

206 
	`tf
("\r\n");

209 
	`x_tf
("[ NAND deviceeset complete. ]\r\n");

210 
	}
}

213 
	$CheckCfigRerii
()

215 if(
USER_CHANNELS
 > 
NSC_MAX_CHANNELS
)

216 
	`as
(!"[WARNING] Configuration Error: Channel [WARNING]");

217 if(
USER_WAYS
 > 
NSC_MAX_WAYS
)

218 
	`as
(!"[WARNING] Configuration Error: WAY [WARNING]");

219 if(
USER_BLOCKS_PER_LUN
 > 
MAIN_BLOCKS_PER_LUN
)

220 
	`as
(!"[WARNING] Configuration Error: BLOCK [WARNING]");

221 if((
BITS_PER_FLASH_CELL
 !
SLC_MODE
))

222 
	`as
(!"[WARNING] Configuration Error: BIT_PER_FLASH_CELL [WARNING]");

224 if(
RESERVED_DATA_BUFFER_BASE_ADDR
 + 0x00200000 > 
COMPLETE_FLAG_TABLE_ADDR
)

225 
	`as
(!"[WARNING] Configuration Error: Data buffer size isooargeo bellocatedoredefinedange [WARNING]");

226 if(
TEMPORARY_PAY_LOAD_ADDR
 + 0x00001000 > 
DATA_BUFFER_MAP_ADDR
)

227 
	`as
(!"[WARNING] Configuration Error: Metadata for NANDequest completionrocess isooargeo bellocatedoredefinedange [WARNING]");

228 if(
FTL_MANAGEMENT_END_ADDR
 > 
DRAM_END_ADDR
)

229 
	`as
(!"[WARNING] Configuration Error: Metadata of FTL isooargeo bellocatedo DRAM [WARNING]");

230 
	}
}

	@ftl_config.h

47 #ide
FTL_CONFIG_H_


48 
	#FTL_CONFIG_H_


	)

50 
	~"nsc_driv.h
"

51 
	~"xms.h
"

52 
	~"nvme/nvme.h
"

55 #ifdef 
XPAR_T4NFC_HLPER_7_BASEADDR


56 
	#NSC_7_CONNECTED
 1

	)

57 
	#NSC_7_UCODEADDR
 
XPAR_AXI_BRAM_CTRL_7_S_AXI_BASEADDR


	)

58 
	#NSC_7_BASEADDR
 
XPAR_T4NFC_HLPER_7_BASEADDR


	)

60 
	#NSC_7_CONNECTED
 0

	)

61 
	#NSC_7_UCODEADDR
 0

	)

62 
	#NSC_7_BASEADDR
 0

	)

64 #ifdef 
XPAR_T4NFC_HLPER_6_BASEADDR


65 
	#NSC_6_CONNECTED
 1

	)

66 
	#NSC_6_UCODEADDR
 
XPAR_AXI_BRAM_CTRL_6_S_AXI_BASEADDR


	)

67 
	#NSC_6_BASEADDR
 
XPAR_T4NFC_HLPER_6_BASEADDR


	)

69 
	#NSC_6_CONNECTED
 0

	)

70 
	#NSC_6_UCODEADDR
 0

	)

71 
	#NSC_6_BASEADDR
 0

	)

73 #ifdef 
XPAR_T4NFC_HLPER_5_BASEADDR


74 
	#NSC_5_CONNECTED
 1

	)

75 
	#NSC_5_UCODEADDR
 
XPAR_AXI_BRAM_CTRL_5_S_AXI_BASEADDR


	)

76 
	#NSC_5_BASEADDR
 
XPAR_T4NFC_HLPER_5_BASEADDR


	)

78 
	#NSC_5_CONNECTED
 0

	)

79 
	#NSC_5_UCODEADDR
 0

	)

80 
	#NSC_5_BASEADDR
 0

	)

82 #ifdef 
XPAR_T4NFC_HLPER_4_BASEADDR


83 
	#NSC_4_CONNECTED
 1

	)

84 
	#NSC_4_UCODEADDR
 
XPAR_AXI_BRAM_CTRL_4_S_AXI_BASEADDR


	)

85 
	#NSC_4_BASEADDR
 
XPAR_T4NFC_HLPER_4_BASEADDR


	)

87 
	#NSC_4_CONNECTED
 0

	)

88 
	#NSC_4_UCODEADDR
 0

	)

89 
	#NSC_4_BASEADDR
 0

	)

91 #ifdef 
XPAR_T4NFC_HLPER_3_BASEADDR


92 
	#NSC_3_CONNECTED
 1

	)

93 
	#NSC_3_UCODEADDR
 
XPAR_AXI_BRAM_CTRL_3_S_AXI_BASEADDR


	)

94 
	#NSC_3_BASEADDR
 
XPAR_T4NFC_HLPER_3_BASEADDR


	)

96 
	#NSC_3_CONNECTED
 0

	)

97 
	#NSC_3_UCODEADDR
 0

	)

98 
	#NSC_3_BASEADDR
 0

	)

100 #ifdef 
XPAR_T4NFC_HLPER_2_BASEADDR


101 
	#NSC_2_CONNECTED
 1

	)

102 
	#NSC_2_UCODEADDR
 
XPAR_AXI_BRAM_CTRL_2_S_AXI_BASEADDR


	)

103 
	#NSC_2_BASEADDR
 
XPAR_T4NFC_HLPER_2_BASEADDR


	)

105 
	#NSC_2_CONNECTED
 0

	)

106 
	#NSC_2_UCODEADDR
 0

	)

107 
	#NSC_2_BASEADDR
 0

	)

109 #ifdef 
XPAR_T4NFC_HLPER_1_BASEADDR


110 
	#NSC_1_CONNECTED
 1

	)

111 
	#NSC_1_UCODEADDR
 
XPAR_AXI_BRAM_CTRL_1_S_AXI_BASEADDR


	)

112 
	#NSC_1_BASEADDR
 
XPAR_T4NFC_HLPER_1_BASEADDR


	)

114 
	#NSC_1_CONNECTED
 0

	)

115 
	#NSC_1_UCODEADDR
 0

	)

116 
	#NSC_1_BASEADDR
 0

	)

118 #ifdef 
XPAR_T4NFC_HLPER_0_BASEADDR


119 
	#NSC_0_CONNECTED
 1

	)

120 
	#NSC_0_UCODEADDR
 
XPAR_AXI_BRAM_CTRL_0_S_AXI_BASEADDR


	)

121 
	#NSC_0_BASEADDR
 
XPAR_T4NFC_HLPER_0_BASEADDR


	)

123 
	#NSC_0_CONNECTED
 0

	)

124 
	#NSC_0_UCODEADDR
 0

	)

125 
	#NSC_0_BASEADDR
 0

	)

129 
	#NUMBER_OF_CONNECTED_CHANNEL
 (
NSC_7_CONNECTED
 + 
NSC_6_CONNECTED
 + 
NSC_5_CONNECTED
 + 
NSC_4_CONNECTED
 + 
NSC_3_CONNECTED
 + 
NSC_2_CONNECTED
 + 
NSC_1_CONNECTED
 + 
NSC_0_CONNECTED
)

	)

136 
	#BYTES_PER_DATA_REGION_OF_NAND_ROW
 16384

	)

137 
	#BYTES_PER_SPARE_REGION_OF_NAND_ROW
 1664

	)

138 
	#BYTES_PER_NAND_ROW
 (
BYTES_PER_DATA_REGION_OF_NAND_ROW
 + 
BYTES_PER_SPARE_REGION_OF_NAND_ROW
)

	)

140 
	#ROWS_PER_SLC_BLOCK
 256

	)

141 
	#ROWS_PER_MLC_BLOCK
 256

	)

143 
	#MAIN_BLOCKS_PER_LUN
 2732

	)

144 
	#EXTENDED_BLOCKS_PER_LUN
 224

	)

145 
	#TOTAL_BLOCKS_PER_LUN
 (
MAIN_BLOCKS_PER_LUN
 + 
EXTENDED_BLOCKS_PER_LUN
)

	)

147 
	#MAIN_ROWS_PER_SLC_LUN
 (
ROWS_PER_SLC_BLOCK
 * 
MAIN_BLOCKS_PER_LUN
)

	)

148 
	#MAIN_ROWS_PER_MLC_LUN
 (
ROWS_PER_MLC_BLOCK
 * 
MAIN_BLOCKS_PER_LUN
)

	)

150 
	#LUNS_PER_DIE
 1

	)

152 
	#MAIN_BLOCKS_PER_DIE
 (
MAIN_BLOCKS_PER_LUN
 * 
LUNS_PER_DIE
)

	)

153 
	#TOTAL_BLOCKS_PER_DIE
 (
TOTAL_BLOCKS_PER_LUN
 * 
LUNS_PER_DIE
)

	)

155 
	#BAD_BLOCK_MARK_PAGE0
 0

156 
	#BAD_BLOCK_MARK_PAGE1
 (
ROWS_PER_MLC_BLOCK
 - 1)

157 
	#BAD_BLOCK_MARK_BYTE0
 0

158 
	#BAD_BLOCK_MARK_BYTE1
 (
BYTES_PER_DATA_REGION_OF_NAND_ROW
)

159 

	)

168 
	#NSC_MAX_CHANNELS
 (
NUMBER_OF_CONNECTED_CHANNEL
)

	)

169 
	#NSC_MAX_WAYS
 8

	)

173 
	#BYTES_PER_DATA_REGION_OF_PAGE
 (4096)

174 
	#BYTES_PER_DATA_REGION_OF_PAGE_FOR_BB
 (16384)

	)

175 
	#BYTES_PER_SPARE_REGION_OF_PAGE
 256

	)

177 
	#PAGES_PER_SLC_BLOCK
 (
ROWS_PER_SLC_BLOCK
)

	)

178 
	#PAGES_PER_MLC_BLOCK
 (
ROWS_PER_MLC_BLOCK
)

	)

181 
	#ECC_CHUNKS_PER_PAGE
 32

	)

182 
	#BIT_ERROR_THRESHOLD_PER_CHUNK
 24

	)

183 
	#ERROR_INFO_WORD_COUNT
 11

	)

190 
	#BYTES_PER_NVME_BLOCK
 4096

	)

191 
	#NVME_BLOCKS_PER_PAGE
 (
BYTES_PER_DATA_REGION_OF_PAGE
 / 
BYTES_PER_NVME_BLOCK
)

	)

199 
	#SLC_MODE
 1

	)

200 
	#MLC_MODE
 2

	)

203 
	#BITS_PER_FLASH_CELL
 
SLC_MODE


204 
	#USER_BLOCKS_PER_LUN
 32

207 
	#USER_CHANNELS
 (
NUMBER_OF_CONNECTED_CHANNEL
)

208 
	#USER_WAYS
 8

210 

	)

211 
	#BYTES_PER_DATA_REGION_OF_SLICE
 (
BYTES_PER_DATA_REGION_OF_PAGE
)

212 
	#BYTES_PER_SPARE_REGION_OF_SLICE
 256

	)

214 
	#SLICES_PER_PAGE
 (
BYTES_PER_DATA_REGION_OF_PAGE
 / 
BYTES_PER_DATA_REGION_OF_SLICE
)

215 
	#NVME_BLOCKS_PER_SLICE
 (
BYTES_PER_DATA_REGION_OF_SLICE
 / 
BYTES_PER_NVME_BLOCK
)

	)

217 
	#USER_DIES
 (
USER_CHANNELS
 * 
USER_WAYS
)

	)

219 
	#USER_PAGES_PER_BLOCK
 (
PAGES_PER_SLC_BLOCK
 * 
BITS_PER_FLASH_CELL
)

	)

220 
	#USER_PAGES_PER_LUN
 (
USER_PAGES_PER_BLOCK
 * 
USER_BLOCKS_PER_LUN
)

	)

221 
	#USER_PAGES_PER_DIE
 (
USER_PAGES_PER_LUN
 * 
LUNS_PER_DIE
)

	)

222 
	#USER_PAGES_PER_CHANNEL
 (
USER_PAGES_PER_DIE
 * 
USER_WAYS
)

	)

223 
	#USER_PAGES_PER_SSD
 (
USER_PAGES_PER_CHANNEL
 * 
USER_CHANNELS
)

	)

225 
	#SLICES_PER_BLOCK
 (
USER_PAGES_PER_BLOCK
 * 
SLICES_PER_PAGE
)

	)

226 
	#SLICES_PER_LUN
 (
USER_PAGES_PER_LUN
 * 
SLICES_PER_PAGE
)

	)

227 
	#SLICES_PER_DIE
 (
USER_PAGES_PER_DIE
 * 
SLICES_PER_PAGE
)

	)

228 
	#SLICES_PER_CHANNEL
 (
USER_PAGES_PER_CHANNEL
 * 
SLICES_PER_PAGE
)

	)

229 
	#SLICES_PER_SSD
 (
USER_PAGES_PER_SSD
 * 
SLICES_PER_PAGE
)

	)

231 
	#USER_BLOCKS_PER_DIE
 (
USER_BLOCKS_PER_LUN
 * 
LUNS_PER_DIE
)

	)

232 
	#USER_BLOCKS_PER_CHANNEL
 (
USER_BLOCKS_PER_DIE
 * 
USER_WAYS
)

	)

233 
	#USER_BLOCKS_PER_SSD
 (
USER_BLOCKS_PER_CHANNEL
 * 
USER_CHANNELS
)

	)

235 
	#KB_PER_BLOCK
 ((
BYTES_PER_DATA_REGION_OF_SLICE
 * 
SLICES_PER_BLOCK
)/(1024))

	)

236 
	#MB_PER_SSD
 ((
USER_BLOCKS_PER_SSD
 * 
KB_PER_BLOCK
)/(1024))

	)

237 
	#MB_PER_MIN_FREE_BLOCK_SPACE
 ((
USER_DIES
 * 
KB_PER_BLOCK
)/(1024))

	)

238 
	#MB_PER_METADATA_BLOCK_SPACE
 ((
USER_DIES
 * 
KB_PER_BLOCK
)/(1024))

	)

239 
	#MB_PER_OVER_PROVISION_BLOCK_SPACE
 (((
USER_BLOCKS_PER_SSD
 / 10* 
KB_PER_BLOCK
)/(1024))

	)

242 
InFTL
();

243 
InChCReg
();

244 
InNdAay
();

245 
CheckCfigRerii
();

247 
ageCacy_L
;

248 
T4REGS
 
chCReg
[
USER_CHANNELS
];

251 
g_l_num_gh_gc
;

252 
g_l_num_gh_
;

253 
g_l_num_gh_wre
;

254 
g_l_num_ho_wre
;

255 
g_l_num_im
;

256 
g_l_num_wre
;

257 
g_l_num_gc
;

258 
g_l_num_a
;

259 
g_l_num_cy_back
;

261 
im_ag
;

	@garbage_collection.c

48 
	~"x_tf.h
"

49 
	~<as.h
>

50 
	~"memy_m.h
"

52 
P_GC_VICTIM_MAP
 
	ggcViimMP
;

53 
	ggcou
, 
	gaddiڮ_wre
;

54 
que_wre
;

56 
	$InGcViimM
()

58 
dNo
, 
vidSliC
;

60 
gcViimMP
 = (
P_GC_VICTIM_MAP

GC_VICTIM_MAP_ADDR
;

61 
gcou
 = 0;

63 
dNo
=0 ; dNo<
USER_DIES
; dieNo++)

65 
vidSliC
=0 ; invidSliC<
SLICES_PER_BLOCK
+1; invalidSliceCnt++)

67 
gcViimMP
->
gcViimLi
[
dNo
][
vidSliC
].
hdBlock
 = 
BLOCK_NONE
;

68 
gcViimMP
->
gcViimLi
[
dNo
][
vidSliC
].
Block
 = 
BLOCK_NONE
;

71 
	}
}

74 
	$GbageCi
(
dNo
)

76 
viimBlockNo
, 
geNo
, 
vtuSliAddr
, 
logilSliAddr
, 
dNoFGcCy
, 
qSlTag
;

78 
gcou
++;

80 
viimBlockNo
 = 
	`GFromGcViimLi
(
dNo
);

81 
dNoFGcCy
 = 
dNo
;

83 
g_l_num_gc
++;

85 if(
vtuBlockMP
->
block
[
dNo
][
viimBlockNo
].
vidSliC
 !
SLICES_PER_BLOCK
)

87 
geNo
=0 ;ageNo<
USER_PAGES_PER_BLOCK
 ;ageNo++)

89 
vtuSliAddr
 = 
	`Vg2VTni
(
dNo
, 
viimBlockNo
, 
geNo
);

90 
logilSliAddr
 = 
vtuSliMP
->
vtuSli
[
vtuSliAddr
].logicalSliceAddr;

92 if(
logilSliAddr
 !
LSA_NONE
)

93 if(
logilSliMP
->
logilSli
[
logilSliAddr
].
vtuSliAddr
 == virtualSliceAddr)

96 
qSlTag
 = 
	`GFromFeReqQ
();

98 
qPoP
->
qPo
[
qSlTag
].
qTy
 = 
REQ_TYPE_NAND
;

99 
qPoP
->
qPo
[
qSlTag
].
qCode
 = 
REQ_CODE_READ
;

100 
qPoP
->
qPo
[
qSlTag
].
logilSliAddr
 =ogicalSliceAddr;

101 
qPoP
->
qPo
[
qSlTag
].
qO
.
daBufFm
 = 
REQ_OPT_DATA_BUF_TEMP_ENTRY
;

102 
qPoP
->
qPo
[
qSlTag
].
qO
.
ndAddr
 = 
REQ_OPT_NAND_ADDR_VSA
;

103 
qPoP
->
qPo
[
qSlTag
].
qO
.
ndEcc
 = 
REQ_OPT_NAND_ECC_ON
;

104 
qPoP
->
qPo
[
qSlTag
].
qO
.
ndEccWng
 = 
REQ_OPT_NAND_ECC_WARNING_OFF
;

105 
qPoP
->
qPo
[
qSlTag
].
qO
.
rowAddrDdcyCheck
 = 
REQ_OPT_ROW_ADDR_DEPENDENCY_CHECK
;

106 
qPoP
->
qPo
[
qSlTag
].
qO
.
blockS
 = 
REQ_OPT_BLOCK_SPACE_MAIN
;

107 
qPoP
->
qPo
[
qSlTag
].
qO
.
fUnAcss
 = 
REQ_OPT_FORCE_UNIT_ACCESS_OFF
;

108 
qPoP
->
qPo
[
qSlTag
].
daBufInfo
.
y
 = 
	`AoTempDaBuf
(
dNo
);

109 
	`UpdeTempDaBufEryInfoBlockgReq
(
qPoP
->
qPo
[
qSlTag
].
daBufInfo
.
y
,eqSlotTag);

110 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
vtuSliAddr
 = virtualSliceAddr;

112 
	`SeLowLevReqQ
(
qSlTag
);

115 
qSlTag
 = 
	`GFromFeReqQ
();

117 
qPoP
->
qPo
[
qSlTag
].
qTy
 = 
REQ_TYPE_NAND
;

118 
qPoP
->
qPo
[
qSlTag
].
qCode
 = 
REQ_CODE_WRITE
;

119 
qPoP
->
qPo
[
qSlTag
].
logilSliAddr
 =ogicalSliceAddr;

120 
qPoP
->
qPo
[
qSlTag
].
qO
.
daBufFm
 = 
REQ_OPT_DATA_BUF_TEMP_ENTRY
;

121 
qPoP
->
qPo
[
qSlTag
].
qO
.
ndAddr
 = 
REQ_OPT_NAND_ADDR_VSA
;

122 
qPoP
->
qPo
[
qSlTag
].
qO
.
ndEcc
 = 
REQ_OPT_NAND_ECC_ON
;

123 
qPoP
->
qPo
[
qSlTag
].
qO
.
ndEccWng
 = 
REQ_OPT_NAND_ECC_WARNING_OFF
;

124 
qPoP
->
qPo
[
qSlTag
].
qO
.
rowAddrDdcyCheck
 = 
REQ_OPT_ROW_ADDR_DEPENDENCY_CHECK
;

125 
qPoP
->
qPo
[
qSlTag
].
qO
.
blockS
 = 
REQ_OPT_BLOCK_SPACE_MAIN
;

126 
qPoP
->
qPo
[
qSlTag
].
qO
.
fUnAcss
 = 
REQ_OPT_FORCE_UNIT_ACCESS_OFF
;

127 
qPoP
->
qPo
[
qSlTag
].
daBufInfo
.
y
 = 
	`AoTempDaBuf
(
dNo
);

128 
	`UpdeTempDaBufEryInfoBlockgReq
(
qPoP
->
qPo
[
qSlTag
].
daBufInfo
.
y
,eqSlotTag);

129 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
vtuSliAddr
 = 
	`FdFeVtuSliFGc
(
dNoFGcCy
, 
viimBlockNo
);

131 
logilSliMP
->
logilSli
[
logilSliAddr
].
vtuSliAddr
 = 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.virtualSliceAddr;

132 
vtuSliMP
->
vtuSli
[
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
vtuSliAddr
].
logilSliAddr
 =ogicalSliceAddr;

134 
	`SeLowLevReqQ
(
qSlTag
);

135 
addiڮ_wre
++;

140 
	`EBlock
(
dNo
, 
viimBlockNo
);

141 
	}
}

144 
	$PutToGcViimLi
(
dNo
, 
blockNo
, 
vidSliC
)

146 if(
gcViimMP
->
gcViimLi
[
dNo
][
vidSliC
].
Block
 !
BLOCK_NONE
)

148 
vtuBlockMP
->
block
[
dNo
][
blockNo
].
evBlock
 = 
gcViimMP
->
gcViimLi
[dNo][
vidSliC
].
Block
;

149 
vtuBlockMP
->
block
[
dNo
][
blockNo
].
xtBlock
 = 
BLOCK_NONE
;

150 
vtuBlockMP
->
block
[
dNo
][
gcViimMP
->
gcViimLi
[dNo][
vidSliC
].
Block
].
xtBlock
 = 
blockNo
;

151 
gcViimMP
->
gcViimLi
[
dNo
][
vidSliC
].
Block
 = 
blockNo
;

155 
vtuBlockMP
->
block
[
dNo
][
blockNo
].
evBlock
 = 
BLOCK_NONE
;

156 
vtuBlockMP
->
block
[
dNo
][
blockNo
].
xtBlock
 = 
BLOCK_NONE
;

157 
gcViimMP
->
gcViimLi
[
dNo
][
vidSliC
].
hdBlock
 = 
blockNo
;

158 
gcViimMP
->
gcViimLi
[
dNo
][
vidSliC
].
Block
 = 
blockNo
;

160 
	}
}

162 
	$GFromGcViimLi
(
dNo
)

164 
eviedBlockNo
;

165 
vidSliC
;

167 
vidSliC
 = 
SLICES_PER_BLOCK
; invalidSliceCnt > 0 ; invalidSliceCnt--)

169 if(
gcViimMP
->
gcViimLi
[
dNo
][
vidSliC
].
hdBlock
 !
BLOCK_NONE
)

171 
eviedBlockNo
 = 
gcViimMP
->
gcViimLi
[
dNo
][
vidSliC
].
hdBlock
;

173 if(
vtuBlockMP
->
block
[
dNo
][
eviedBlockNo
].
xtBlock
 !
BLOCK_NONE
)

175 
vtuBlockMP
->
block
[
dNo
][vtuBlockMP->block[dNo][
eviedBlockNo
].
xtBlock
].
evBlock
 = 
BLOCK_NONE
;

176 
gcViimMP
->
gcViimLi
[
dNo
][
vidSliC
].
hdBlock
 = 
vtuBlockMP
->
block
[dNo][
eviedBlockNo
].
xtBlock
;

181 
gcViimMP
->
gcViimLi
[
dNo
][
vidSliC
].
hdBlock
 = 
BLOCK_NONE
;

182 
gcViimMP
->
gcViimLi
[
dNo
][
vidSliC
].
Block
 = 
BLOCK_NONE
;

184  
eviedBlockNo
;

189 
	`as
(!"[WARNING] Therereo free blocks. Aborterminatehis ssd. [WARNING]");

190  
BLOCK_FAIL
;

191 
	}
}

194 
	$SeiveGFromGcViimLi
(
dNo
, 
blockNo
)

196 
xtBlock
, 
evBlock
, 
vidSliC
;

198 
xtBlock
 = 
vtuBlockMP
->
block
[
dNo
][
blockNo
].nextBlock;

199 
evBlock
 = 
vtuBlockMP
->
block
[
dNo
][
blockNo
].prevBlock;

200 
vidSliC
 = 
vtuBlockMP
->
block
[
dNo
][
blockNo
].invalidSliceCnt;

202 if((
xtBlock
 !
BLOCK_NONE
&& (
evBlock
 != BLOCK_NONE))

204 
vtuBlockMP
->
block
[
dNo
][
evBlock
].
xtBlock
 =extBlock;

205 
vtuBlockMP
->
block
[
dNo
][
xtBlock
].
evBlock
 =revBlock;

207 if((
xtBlock
 =
BLOCK_NONE
&& (
evBlock
 != BLOCK_NONE))

209 
vtuBlockMP
->
block
[
dNo
][
evBlock
].
xtBlock
 = 
BLOCK_NONE
;

210 
gcViimMP
->
gcViimLi
[
dNo
][
vidSliC
].
Block
 = 
evBlock
;

212 if((
xtBlock
 !
BLOCK_NONE
&& (
evBlock
 == BLOCK_NONE))

214 
vtuBlockMP
->
block
[
dNo
][
xtBlock
].
evBlock
 = 
BLOCK_NONE
;

215 
gcViimMP
->
gcViimLi
[
dNo
][
vidSliC
].
hdBlock
 = 
xtBlock
;

219 
gcViimMP
->
gcViimLi
[
dNo
][
vidSliC
].
hdBlock
 = 
BLOCK_NONE
;

220 
gcViimMP
->
gcViimLi
[
dNo
][
vidSliC
].
Block
 = 
BLOCK_NONE
;

222 
	}
}

224 
	$gcus
(){

225 if(
gcou
 > 0){

226 
	`x_tf
("%d %d %d\n", 
gcou
, 
addiڮ_wre
, 
que_wre
);

228 
	}
}

	@garbage_collection.h

47 #ide
GARBAGE_COLLECTION_H_


48 
	#GARBAGE_COLLECTION_H_


	)

50 
	~"l_cfig.h
"

52 
	s_GC_VICTIM_LIST_ENTRY
 {

53 
	mhdBlock
 : 16;

54 
	mBlock
 : 16;

55 } 
	tGC_VICTIM_LIST_ENTRY
, *
	tP_GC_VICTIM_LIST_ENTRY
;

57 
	s_GC_VICTIM_MAP
 {

58 
GC_VICTIM_LIST_ENTRY
 
	mgcViimLi
[
USER_DIES
][
SLICES_PER_BLOCK
 + 1];

59 } 
	tGC_VICTIM_MAP
, *
	tP_GC_VICTIM_MAP
;

61 
InGcViimM
();

62 
GbageCi
(
dNo
);

64 
PutToGcViimLi
(
dNo
, 
blockNo
, 
vidSliC
);

65 
GFromGcViimLi
(
dNo
);

66 
SeiveGFromGcViimLi
(
dNo
, 
blockNo
);

67 
gcus
();

69 
P_GC_VICTIM_MAP
 
gcViimMP
;

70 
gcTrigged
;

71 
cyC
;

	@main.c

63 
	~"x_che.h
"

64 
	~"x_exi.h
"

65 
	~"x_mmu.h
"

66 
	~"xms_ps.h
"

67 
	~"xscugic_hw.h
"

68 
	~"xscugic.h
"

69 
	~"x_tf.h
"

70 
	~"nvme/debug.h
"

72 
	~"nvme/nvme.h
"

73 
	~"nvme/nvme_ma.h
"

74 
	~"nvme/ho_d.h
"

77 
XScuGic
 
	gGicIn
;

79 
	$ma
()

81 
u
;

83 
XScuGic_Cfig
 *
IcCfig
;

85 
	`X_ICacheDib
();

86 
	`X_DCacheDib
();

87 
	`X_DibMMU
();

90 
	#MB
 (1024*1024)

	)

91 
u
 = 0; u < 4096; u++)

93 i(
u
 < 0x2)

94 
	`X_STlbAribus
(
u
 * 
MB
, 0xC1E);

95 i(
u
 < 0x180)

96 
	`X_STlbAribus
(
u
 * 
MB
, 0xC12);

97 i(
u
 < 0x400)

98 
	`X_STlbAribus
(
u
 * 
MB
, 0xC1E);

100 
	`X_STlbAribus
(
u
 * 
MB
, 0xC12);

103 
	`X_EbMMU
();

104 
	`X_ICacheEb
();

105 
	`X_DCacheEb
();

106 
	`x_tf
("[!] MMU has beennabled.\r\n");

109 
	`x_tf
("\r\n Hello COSMOS+ OpenSSD !!! \r\n");

112 
	`X_ExiIn
();

114 
IcCfig
 = 
	`XScuGic_LookupCfig
(
XPAR_SCUGIC_SINGLE_DEVICE_ID
);

115 
	`XScuGic_CfgInlize
(&
GicIn
, 
IcCfig
, IcCfig->
CpuBaAddss
);

116 
	`X_ExiRegiHdr
(
XIL_EXCEPTION_ID_INT
,

117 (
X_ExiHdr
)
XScuGic_IruHdr
,

118 &
GicIn
);

120 
	`XScuGic_C
(&
GicIn
, 61,

121 (
X_ExiHdr
)
dev_q_hdr
,

124 
	`XScuGic_Eb
(&
GicIn
, 61);

127 
	`X_ExiEbMask
(
XIL_EXCEPTION_IRQ
);

128 
	`X_ExiEb
();

130 
	`dev_q_
();

132 
	`nvme_ma
();

134 
	`x_tf
("done\r\n");

137 
	}
}

	@memory_map.h

47 #ide
MEMORY_MAP_H_


48 
	#MEMORY_MAP_H_


	)

50 
	~"da_bufr.h
"

51 
	~"addss_i.h
"

52 
	~"que_loti.h
"

53 
	~"que_schedu.h
"

54 
	~"que_sfm.h
"

55 
	~"gbage_ci.h
"

57 
	#DRAM_START_ADDR
 0x00100000

	)

59 
	#MEMORY_SEGMENTS_START_ADDR
 
DRAM_START_ADDR


	)

60 
	#MEMORY_SEGMENTS_END_ADDR
 0x001FFFFF

	)

62 
	#NVME_MANAGEMENT_START_ADDR
 0x00200000

	)

63 
	#NVME_MANAGEMENT_END_ADDR
 0x002FFFFF

	)

65 
	#RESERVED0_START_ADDR
 0x00300000

	)

66 
	#RESERVED0_END_ADDR
 0x0FFFFFFF

	)

68 
	#FTL_MANAGEMENT_START_ADDR
 0x10000000

	)

71 
	#DATA_BUFFER_BASE_ADDR
 0x10000000

	)

72 
	#TEMPORARY_DATA_BUFFER_BASE_ADDR
 (
DATA_BUFFER_BASE_ADDR
 + 
AVAILABLE_DATA_BUFFER_ENTRY_COUNT
 * 
BYTES_PER_DATA_REGION_OF_SLICE_FOR_DATA_BUFFER
)

	)

73 
	#SPARE_DATA_BUFFER_BASE_ADDR
 (
TEMPORARY_DATA_BUFFER_BASE_ADDR
 + 
AVAILABLE_TEMPORARY_DATA_BUFFER_ENTRY_COUNT
 * 
BYTES_PER_DATA_REGION_OF_SLICE_FOR_DATA_BUFFER
)

	)

74 
	#TEMPORARY_SPARE_DATA_BUFFER_BASE_ADDR
 (
SPARE_DATA_BUFFER_BASE_ADDR
 + 
AVAILABLE_DATA_BUFFER_ENTRY_COUNT
 * 
BYTES_PER_SPARE_REGION_OF_SLICE
)

	)

75 
	#RESERVED_DATA_BUFFER_BASE_ADDR
 (
TEMPORARY_SPARE_DATA_BUFFER_BASE_ADDR
 + 
AVAILABLE_TEMPORARY_DATA_BUFFER_ENTRY_COUNT
 * 
BYTES_PER_SPARE_REGION_OF_SLICE
)

	)

77 
	#COMPLETE_FLAG_TABLE_ADDR
 0x17000000

	)

78 
	#STATUS_REPORT_TABLE_ADDR
 (
COMPLETE_FLAG_TABLE_ADDR
 + (
COMPLETE_FLAG_TABLE
))

	)

79 
	#ERROR_INFO_TABLE_ADDR
 (
STATUS_REPORT_TABLE_ADDR
 + (
STATUS_REPORT_TABLE
))

	)

80 
	#TEMPORARY_PAY_LOAD_ADDR
 (
ERROR_INFO_TABLE_ADDR
+ (
ERROR_INFO_TABLE
))

	)

83 
	#DATA_BUFFER_MAP_ADDR
 0x18000000

	)

84 
	#DATA_BUFFFER_HASH_TABLE_ADDR
 (
DATA_BUFFER_MAP_ADDR
 + (
DATA_BUF_MAP
))

	)

85 
	#TEMPORARY_DATA_BUFFER_MAP_ADDR
 (
DATA_BUFFFER_HASH_TABLE_ADDR
 + (
DATA_BUF_HASH_TABLE
))

	)

87 
	#LOGICAL_SLICE_MAP_ADDR
 (
TEMPORARY_DATA_BUFFER_MAP_ADDR
 + (
TEMPORARY_DATA_BUF_MAP
))

	)

88 
	#VIRTUAL_SLICE_MAP_ADDR
 (
LOGICAL_SLICE_MAP_ADDR
 + (
LOGICAL_SLICE_MAP
))

	)

89 
	#VIRTUAL_BLOCK_MAP_ADDR
 (
VIRTUAL_SLICE_MAP_ADDR
 + (
VIRTUAL_SLICE_MAP
))

	)

90 
	#PHY_BLOCK_MAP_ADDR
 (
VIRTUAL_BLOCK_MAP_ADDR
 + (
VIRTUAL_BLOCK_MAP
))

	)

91 
	#BAD_BLOCK_TABLE_INFO_MAP_ADDR
 (
PHY_BLOCK_MAP_ADDR
 + (
PHY_BLOCK_MAP
))

	)

92 
	#VIRTUAL_DIE_MAP_ADDR
 (
BAD_BLOCK_TABLE_INFO_MAP_ADDR
 + (
BAD_BLOCK_TABLE_INFO_MAP
))

	)

94 
	#GC_VICTIM_MAP_ADDR
 (
VIRTUAL_DIE_MAP_ADDR
 + (
VIRTUAL_DIE_MAP
))

	)

96 
	#REQ_POOL_ADDR
 (
GC_VICTIM_MAP_ADDR
 + (
GC_VICTIM_MAP
))

	)

98 
	#ROW_ADDR_DEPENDENCY_TABLE_ADDR
 (
REQ_POOL_ADDR
 + (
REQ_POOL
))

	)

100 
	#DIE_STATE_TABLE_ADDR
 (
ROW_ADDR_DEPENDENCY_TABLE_ADDR
 + (
ROW_ADDR_DEPENDENCY_TABLE
))

	)

101 
	#RETRY_LIMIT_TABLE_ADDR
 (
DIE_STATE_TABLE_ADDR
 + (
DIE_STATE_TABLE
))

	)

102 
	#WAY_PRIORITY_TABLE_ADDR
 (
RETRY_LIMIT_TABLE_ADDR
 + (
RETRY_LIMIT_TABLE
))

	)

104 
	#FTL_MANAGEMENT_END_ADDR
 ((
WAY_PRIORITY_TABLE_ADDR
 + (
WAY_PRIORITY_TABLE
))- 1)

	)

106 
	#RESERVED1_START_ADDR
 (
FTL_MANAGEMENT_END_ADDR
 + 1)

	)

107 
	#RESERVED1_END_ADDR
 0x3FFFFFFF

	)

109 
	#DRAM_END_ADDR
 0x3FFFFFFF

	)

	@nsc_driver.c

50 
	~"nsc_driv.h
"

51 
	~"xms.h
"

52 
	~<as.h
>

56 
	mdayV
[32];

57 } 
	tioday_if
;

59 
	$nfc_t_dqs_day
(
chl
, 
wVue
)

61 vީ* 
0
 = (vީ*)
XPAR_IODELAY_IF_0_DQS_BASEADDR
;

62 vީ
ioday_if
* 
da0
 = (vީioday_if*)(
XPAR_IODELAY_IF_0_DQS_BASEADDR
 + 0x8000);

63 vީ* 
1
 = (vީ*)
XPAR_IODELAY_IF_1_DQS_BASEADDR
;

64 vީ
ioday_if
* 
da1
 = (vީioday_if*)(
XPAR_IODELAY_IF_1_DQS_BASEADDR
 + 0x8000);

66 i(
chl
 < 4)

68 
da0
->
dayV
[
chl
] = 
wVue
;

69 
0
[1] = 1;

73 
da1
->
dayV
[
chl
 % 4] = 
wVue
;

74 
1
[1] = 1;

76 
	}
}

78 
	$nfc_t_dq_day
(
chl
, 
wVue
)

80 vީ* 
0
 = (vީ*)
XPAR_IODELAY_IF_0_BASEADDR
;

81 vީ
ioday_if
* 
da0
 = (vީioday_if*)(
XPAR_IODELAY_IF_0_BASEADDR
 + 0x8000);

82 vީ* 
1
 = (vީ*)
XPAR_IODELAY_IF_0_BASEADDR
;

83 vީ
ioday_if
* 
da1
 = (vީioday_if*)(
XPAR_IODELAY_IF_0_BASEADDR
 + 0x8000);

85 
i
;

86 i(
chl
 < 4)

88 
i
 = 0; i < 8; i++)

89 
da0
->
dayV
[
chl
 * 8 + 
i
] = 
wVue
;

90 
0
[1] = 1;

94 
i
 = 0; i < 8; i++)

95 
da1
->
dayV
[(
chl
 % 4* 8 + 
i
] = 
wVue
;

96 
1
[1] = 1;

98 
	}
}

100 
	$V2FInlizeHd
(
T4REGS
* 
t4gs
, * 
t4nscRegiBaAddss
)

102 
t4gs
->
t4gID
 = (
T4REG_ID
*)(()
t4nscRegiBaAddss
 + 0);

103 
t4gs
->
t4gCFG
 = (
T4REG_CFG
*)(()
t4nscRegiBaAddss
 + 0x1000);

104 
t4gs
->
t4gEXT
 = (
T4REG_EXT
*)(()
t4nscRegiBaAddss
 + 0x2000);

105 
t4gs
->
t4gCC
 = (
T4REG_CC
*)(()
t4nscRegiBaAddss
 + 0x3000);

106 
t4gs
->
t4gBP
 = (
T4REG_BP
*)(()
t4nscRegiBaAddss
 + 0x3800);

107 
t4gs
->
t4gSP
 = (
T4REG_SP
*)(()
t4nscRegiBaAddss
 + 0x4000);

108 
	}
}

110 
__ibu__
((
timize
("O0"))
	$V2FSSambrS
(
T4REGS
* 
t4gs
, 
ab
)

112 
T4REG_CMD_SET_SCRAMBLER
 
tSambrCmd
;

114 
tSambrCmd
.
cmdSe
 = (
ab
)?
T4NSC_CMD_SET_SCRAMBLER_ENABLE
:
T4NSC_CMD_SET_SCRAMBLER_DISABLE
;

116 
	`V2FFlRegis
(
t4gs
, 
T4REG_CMD_SET_SCRAMBLER
, 
tSambrCmd
);

117 
	`V2FIssueCommd
(
t4gs
);

118 
	}
}

120 
__ibu__
((
timize
("O0"))
	$V2FRetSync
(
T4REGS
* 
t4gs
, 
way
)

122 
T4REG_CMD_NAND_RESET
 
tCmd
;

124 
tCmd
.
cmdSe
 = 
T4NSC_CMD_NAND_RESET
;

125 
tCmd
.
waySe
 = 1 << 
way
;

127 
	`V2FIsCڌrBusy
(
t4gs
));

128 
	`V2FFlRegis
(
t4gs
, 
T4REG_CMD_NAND_RESET
, 
tCmd
);

129 
	`V2FIssueCommd
(
t4gs
);

131 
	`V2FIsCڌrBusy
(
t4gs
));

132 
	`V2FSSambrS
(
t4gs
, 0);

133 
	}
}

135 
__ibu__
((
timize
("O0"))
	$V2FSFtusT
(
T4REGS
* 
t4gs
, 
way
, 
addss
, vީ* 
yld
)

137 
T4REG_CMD_SET_FEATURES
 
tFtusCmd
;

139 
tFtusCmd
.
cmdSe
 = 
T4NSC_CMD_SET_FEATUREST
;

140 
tFtusCmd
.
waySe
 = 1 << 
way
;

141 
tFtusCmd
.
yldAddss
 = ()
yld
;

142 
tFtusCmd
.
tFtusAddss
 = 
addss
;

144 
	`V2FFlRegis
(
t4gs
, 
T4REG_CMD_SET_FEATURES
, 
tFtusCmd
);

145 
	`V2FIssueCommd
(
t4gs
);

146 
	}
}

148 
	$V2FGRdyBusy
(
T4REGS
* 
t4gs
, * 
pt
)

150 
T4REG_CMD_GET_READYBUSY
 
gRdyBusyCmd
;

152 
gRdyBusyCmd
.
cmdSe
 = 
T4NSC_CMD_GET_READYBUSY
;

153 
gRdyBusyCmd
.
rved
 = 0;

154 
gRdyBusyCmd
.
ptAddss
 = ()
pt
;

156 
	`V2FFlRegis
(
t4gs
, 
T4REG_CMD_GET_READYBUSY
, 
gRdyBusyCmd
);

157 
	`V2FIssueCommd
(
t4gs
);

158 
	}
}

160 
__ibu__
((
timize
("O0"))
	$V2FSFtusSync
(
T4REGS
* 
t4gs
, 
way
, 
u0x02
, 
u0x10
, 
u0x01
, 
yLdAddr
)

162 vީ* 
yld
 = (*)
yLdAddr
;

163 vީ* 
us
 = (*)(
yLdAddr
 + 4);

165 *
yld
 = 
u0x02
;

166 
	`V2FIsCڌrBusy
(
t4gs
));

167 
	`V2FSFtusT
(
t4gs
, 
way
, 0x02, 
yld
);

170 
	`V2FIsCڌrBusy
(
t4gs
));

171 
	`V2FGRdyBusy
(
t4gs
, 
us
);

172 !(*
us
 & 1));

173 *
us
 >>= 16;

175 !(*
us
 & (1 << 
way
)));

177 *
yld
 = 
u0x10
;

178 
	`V2FIsCڌrBusy
(
t4gs
));

179 
	`V2FSFtusT
(
t4gs
, 
way
, 0x10, 
yld
);

182 
	`V2FIsCڌrBusy
(
t4gs
));

183 
	`V2FGRdyBusy
(
t4gs
, 
us
);

184 !(*
us
 & 1));

185 *
us
 >>= 16;

187 !(*
us
 & (1 << 
way
)));

189 
	`V2FIsCڌrBusy
(
t4gs
));

190 
	`V2FSSambrS
(
t4gs
, 0);

202 
	}
}

204 
__ibu__
((
timize
("O0"))
	$V2FRdPageTriggAsync
(
T4REGS
* 
t4gs
, 
way
, 
rowAddss
)

206 
T4REG_CMD_READ_PAGE_TRIGGER
 
adPageTrigggCmd
;

208 
adPageTrigggCmd
.
cmdSe
 = 
T4NSC_CMD_READ_PAGE_TRIGGER_PSLC
;

209 
adPageTrigggCmd
.
waySe
 = 1 << 
way
;

210 
adPageTrigggCmd
.
rowAddss
 =owAddress;

212 
	`V2FIsCڌrBusy
(
t4gs
));

213 
	`V2FFlRegis
(
t4gs
, 
T4REG_CMD_READ_PAGE_TRIGGER
, 
adPageTrigggCmd
);

214 
	`V2FIssueCommd
(
t4gs
);

215 
	}
}

217 
__ibu__
((
timize
("O0"))
	$V2FRdPageTnsrAsync
(
T4REGS
* 
t4gs
, 
way
, * 
geDaBufr
, * 
eDaBufr
, * 
rInfmi
, * 
comi
, 
rowAddss
)

219 
T4REG_CMD_READ_PAGE_TRANSFER_PSLC
 
adgSLC
;

221 
adgSLC
.
cmdSe
 = 
T4NSC_CMD_READ_TRANSFER_PSLC
;

222 
adgSLC
.
waySe
 = 1 << 
way
;

223 
adgSLC
.
rowAddss
 =owAddress;

224 
adgSLC
.
geDaAddss
 = 
geDaBufr
;

225 
adgSLC
.
eDaAddss
 = 
eDaBufr
;

226 
adgSLC
.
rInfoAddss
 = 
rInfmi
;

227 *
comi
 = 0;

228 
adgSLC
.
comiRtAddss
 = 
comi
;

230 
	`V2FIsCڌrBusy
(
t4gs
));

231 
	`V2FFlRegis
(
t4gs
, 
T4REG_CMD_READ_PAGE_TRANSFER_PSLC
, 
adgSLC
);

232 
	`V2FIssueCommd
(
t4gs
);

233 
	}
}

235 
__ibu__
((
timize
("O0"))
	$V2FRdPageTnsrRawAsync
(
T4REGS
* 
t4gs
, 
way
, * 
geDaBufr
, * 
comi
)

237 
T4REG_CMD_READ_PAGE_TRANSFER_RAW
 
adPageTnsrRaw
;

239 
adPageTnsrRaw
.
cmdSe
 = 
T4NSC_CMD_READ_TRANSFER_RAW
;

240 
adPageTnsrRaw
.
waySe
 = 1 << 
way
;

241 
adPageTnsrRaw
.
cAddss
 = 0;

242 
adPageTnsrRaw
.
wdLgth
 = (16384 + 1664) / 4;

243 
adPageTnsrRaw
.
geDaAddss
 = 
geDaBufr
;

244 
adPageTnsrRaw
.
comiRtAddss
 = ()
comi
;

245 *
comi
 = 0;

247 
	`V2FIsCڌrBusy
(
t4gs
));

248 
	`V2FFlRegis
(
t4gs
, 
T4REG_CMD_READ_PAGE_TRANSFER_RAW
, 
adPageTnsrRaw
);

249 
	`V2FIssueCommd
(
t4gs
);

250 
	}
}

253 
__ibu__
((
timize
("O0"))
	$V2FProgmPageAsync
(
T4REGS
* 
t4gs
, 
way
, 
rowAddss
, * 
geDaBufr
, * 
eDaBufr
)

255 
T4REG_CMD_PROGRAM_PAGE_TRANSFER_PSLC
 
ogPagSLC
;

257 
ogPagSLC
.
cmdSe
 = 
T4NSC_CMD_PROGRAM_PAGE_PSLC
;

258 
ogPagSLC
.
waySe
 = 1 << 
way
;

259 
ogPagSLC
.
rowAddss
 =owAddress;

260 
ogPagSLC
.
geDaAddss
 = 
geDaBufr
;

261 
ogPagSLC
.
eDaAddss
 = 
eDaBufr
;

263 
	`V2FIsCڌrBusy
(
t4gs
));

264 
	`V2FFlRegis
(
t4gs
, 
T4REG_CMD_PROGRAM_PAGE_TRANSFER_PSLC
, 
ogPagSLC
);

265 
	`V2FIssueCommd
(
t4gs
);

266 
	}
}

268 
__ibu__
((
timize
("O0"))
	$V2FEBlockAsync
(
T4REGS
* 
t4gs
, 
way
, 
rowAddss
)

270 
T4REG_CMD_ERASE_BLOCK
 
aBlockCmd
;

272 
	`as
((
rowAddss
 & 0xFF) == 0);

274 
aBlockCmd
.
cmdSe
 = 
T4NSC_CMD_ERASE_BLOCK
;

275 
aBlockCmd
.
waySe
 = 1 << 
way
;

276 
aBlockCmd
.
rowAddss
 =owAddress;

278 
	`V2FIsCڌrBusy
(
t4gs
));

279 
	`V2FFlRegis
(
t4gs
, 
T4REG_CMD_ERASE_BLOCK
, 
aBlockCmd
);

280 
	`V2FIssueCommd
(
t4gs
);

281 
	}
}

283 
__ibu__
((
timize
("O0"))
	$V2FStusCheckAsync
(
T4REGS
* 
t4gs
, 
way
, * 
usRt
)

285 
T4REG_CMD_READ_STATUS
 
adStusCmd
;

287 
adStusCmd
.
cmdSe
 = 
T4NSC_CMD_READ_STATUS
;

288 
adStusCmd
.
waySe
 = 1 << 
way
;

289 
adStusCmd
.
ptAddss
 = ()
usRt
;

290 *
usRt
 = 0;

292 
	`V2FIsCڌrBusy
(
t4gs
));

293 
	`V2FFlRegis
(
t4gs
, 
T4REG_CMD_READ_STATUS
, 
adStusCmd
);

294 
	`V2FIssueCommd
(
t4gs
);

295 
	}
}

297 
	$V2FRdIdAsync
(
T4REGS
* 
t4gs
, 
way
, * 
usRt
, * 
comi
)

299 
T4REG_CMD_READ_ID
 
adIdCmd
;

301 
adIdCmd
.
cmdSe
 = 
T4NSC_CMD_READ_ID
;

302 
adIdCmd
.
waySe
 = 1 << 
way
;

303 
adIdCmd
.
cAddss
 = 0x0090;

304 
adIdCmd
.
ngth
 = 3;

305 
adIdCmd
.
ptAddss
 = ()
usRt
;

306 
adIdCmd
.
comiRtAddss
 = ()
comi
;

308 
	`V2FIsCڌrBusy
(
t4gs
));

309 
	`V2FFlRegis
(
t4gs
, 
T4REG_CMD_READ_ID
, 
adIdCmd
);

310 
	`V2FIssueCommd
(
t4gs
);

311 
	}
}

313 
	$V2FRdIdSync
(
T4REGS
* 
t4gs
, 
way
, * 
usRt
)

315 
buf
[8] = {0};

316 
i
;

317 
i
 = 0; i < 8; i++)

318 ((*)
usRt
)[
i
] = 0;

319 * 
comi
 = &
usRt
[4];

320 *
comi
 = 0;

321 
	`V2FRdIdAsync
(
t4gs
, 
way
, 
usRt
, 
comi
);

322 *
comi
 == 0);

324 
i
 = 0; i < 6; i++)

325 
buf
[
i
] = ((*)
usRt
)[i * 2];

326 
i
 = 0; i < 8; i++)

327 ((*)
usRt
)[
i
] = 
buf
[i];

328 
	}
}

330 
__ibu__
((
timize
("O0"))
	$V2FRdyBusyAsync
(
T4REGS
* 
t4gs
)

332 vީ
adyBusy
 = (
t4gs
)->
t4gBP
->
ndRdyBusy
;

334  
adyBusy
;

335 
	}
}

	@nsc_driver.h

57 #ide
FMC_DRIVER_H_


58 
	#FMC_DRIVER_H_


	)

60 
	~"t4nsc_pm.h
"

62 
	#T4NSC_CMD_NAND_RESET
 4

	)

63 
	#T4NSC_CMD_MODE_CHANGE
 32

	)

64 
	#T4NSC_CMD_GET_READYBUSY
 108

	)

65 
	#T4NSC_CMD_SET_FEATURESA
 124

	)

66 
	#T4NSC_CMD_SET_LUN_FEATUREST
 132

	)

67 
	#T4NSC_CMD_SET_FEATUREST
 144

	)

68 
	#T4NSC_CMD_GET_LUN_FEATUREST
 192

	)

69 
	#T4NSC_CMD_GET_FEATUREST
 204

	)

70 
	#T4NSC_CMD_SET_SCRAMBLER_DISABLE
 264

	)

71 
	#T4NSC_CMD_SET_SCRAMBLER_ENABLE
 284

	)

72 
	#T4NSC_CMD_READ_STATUS
 304

	)

73 
	#T4NSC_CMD_ERASE_BLOCK
 352

	)

74 
	#T4NSC_CMD_READ_PAGE_TRIGGER
 384

	)

75 
	#T4NSC_CMD_SINGLE_STATE_READ_PAGE_TRIGGER
 392

	)

76 
	#T4NSC_CMD_READ_PAGE_TRIGGER_WRLPRE_LSB
 404

	)

77 
	#T4NSC_CMD_READ_PAGE_TRIGGER_WRLPRE_CSB
 412

	)

78 
	#T4NSC_CMD_READ_PAGE_TRIGGER_WRLPRE_MSB
 420

	)

79 
	#T4NSC_CMD_READ_PAGE_TRIGGER_LSB
 428

	)

80 
	#T4NSC_CMD_READ_PAGE_TRIGGER_CSB
 436

	)

81 
	#T4NSC_CMD_READ_PAGE_TRIGGER_MSB
 444

	)

82 
	#T4NSC_CMD_READ_PAGE_TRIGGER_PSLC
 452

	)

83 
	#T4NSC_CMD_READ_TRANSFER_RAW
 500

	)

84 
	#T4NSC_CMD_PROGRAM_PAGE_RAW
 568

	)

85 
	#T4NSC_CMD_PROGRAM_PAGE_RAW_xSB
 576

	)

86 
	#T4NSC_CMD_PROGRAM_PAGE_RAW_PSLC
 580

	)

87 
	#T4NSC_CMD_READ_ID
 756

	)

88 
	#T4NSC_CMD_END_OF_COMMON
 824

	)

90 
	#T4NSC_CMD_READ_TRANSFER_PSLC
 (
T4NSC_CMD_END_OF_COMMON
+0)

	)

91 
	#T4NSC_CMD_PROGRAM_PAGE_PSLC
 (
T4NSC_CMD_END_OF_COMMON
+112)

	)

92 
	#T4NSC_CMD_READ_TRANSFER
 (
T4NSC_CMD_END_OF_COMMON
+204)

	)

93 
	#T4NSC_CMD_PROGRAM_PAGES
 (
T4NSC_CMD_END_OF_COMMON
+616)

	)

94 
	#T4NSC_CMD_FSP_PAGES
 (
T4NSC_CMD_END_OF_COMMON
+960)

	)

95 
	#T4NSC_CMD_END_OF_PLAINOPS
 (
T4NSC_CMD_END_OF_COMMON
+1308)

	)

97 
	#V2FFlRegis
(
t4gs
, 
cmdty
, 
cmdyld
(*((vީcmdty*)(4gs)->
t4gSP
)(cmdyld))

	)

98 
	#V2FIssueCommd
(
t4gs
((4gs)->
t4gCC
)->
issueCmd
 = 1)

	)

100 
	#V2FIsCڌrBusy
(
t4gs
(4gs)->
t4gID
->
queueNFu
 =0)

	)

101 
	#V2FGFeQueueCou
(
t4gs
(32 - (4gs)->
t4gID
->
queueCou
))

	)

102 
	#V2FGNANDRdyBusy
(
t4gs
, 
way
!!(4gs)->
t4gBP
->
ndRdyBusy
 & (1 << (way)))

	)

104 
	#V2FCrcVid
(
rInfmi
!!(*((
ut32_t
*)ӼInfmi)& 0x10000000)

	)

105 
	#V2FWܡChunkECou
(
rInfmi
((*((
ut32_t
*)ӼInfmi)& 0x00FF0000>> 16)

	)

106 
	#V2FPageDecodeSucss
(
cEInfmi
((*((
ut32_t
*)(cEInfmi)& 0xFFFFFFFF=0xFFFFFFFF)

	)

108 
	#V2FEToggMode
(
dev
, 
way
, 
yLdAddr

	`V2FSFtusSync
(dev, way, 0x17, 0x06, 0,ayLdAddr)

	)

110 
	#V2FWayRdy
(
adyBusy
, 
wayNo
((ԗdyBusy>> (wayNo)& 1)

	)

111 
	#V2FTnsrCome
(
comeFg
((comeFg& 1)

	)

112 
	#V2FRequeRtDe
(
usRt
((usRt& 1)

	)

113 
	#V2FElimeRtDeFg
(
usRt
((usRt>> 1)

	)

114 
	#V2FRequeCome
(
usRt
(((usRt& 0x60=0x60)

	)

115 
	#V2FRequeFa
(
usRt
((usRt& 3)

	)

119 
	mcmdSe
;

120 
	mrowAddss
;

121 
	murDa
;

122 
	mdaAddss
;

123 
	meAddss
;

124 
	mrCouAddss
;

125 
	mcomiAddss
;

126 
	mwaySei
;

127 
	mchlBusy
;

128 
	madyBusy
;

129 } 
	tV2FMCRegis
;

133 
	mqueueNFu
:1;

134 
	mvsi
:31;

135 
	mqueueCou
;

136 } 
	tT4REG_ID
;

140 
	mrved
;

141 } 
	tT4REG_CFG
;

145 
T4EXT_PM
 
	mrfMڙ
;

146 } 
	tT4REG_EXT
;

150 
	missueCmd
;

151 } 
	tT4REG_CC
;

155 
	mndRdyBusy
;

156 } 
	tT4REG_BP
;

160 
	mcmdSe
;

161 
	mwaySe
;

162 
	m
[30];

163 } 
	tT4REG_SP
;

168 vީ
T4REG_ID
* 
	mt4gID
;

170 vީ
T4REG_CFG
* 
	mt4gCFG
;

172 vީ
T4REG_EXT
* 
	mt4gEXT
;

174 vީ
T4REG_CC
* 
	mt4gCC
;

176 vީ
T4REG_BP
* 
	mt4gBP
;

178 vީ
T4REG_SP
* 
	mt4gSP
;

179 } 
	tT4REGS
;

183 
	mcmdSe
;

184 
	mwaySe
;

185 } 
	tT4REG_CMD_NAND_RESET
;

189 
	mcmdSe
;

190 
	mwaySe
;

191 
	myldAddss
;

192 } 
	tT4REG_CMD_MODE_CHANGE
;

196 
	mcmdSe
;

197 
	mwaySe
;

198 
	myldAddss
;

199 
	mtFtusAddss
;

200 } 
	tT4REG_CMD_SET_FEATURES
;

204 
	mcmdSe
;

205 
	mwaySe
;

206 
	myldAddss
;

207 
	mtFtusAddss
;

208 
	mlunSe
;

209 } 
	tT4REG_CMD_SET_LUN_FEATURES
;

213 
	mcmdSe
;

214 
	mwaySe
;

215 
	mptAddss
;

216 
	mgFtusAddss
;

217 
	mcomiAddss
;

218 } 
	tT4REG_CMD_GET_FEATURES
;

222 
	mcmdSe
;

223 
	mrved
;

224 
	mptAddss
;

225 } 
	tT4REG_CMD_GET_READYBUSY
;

229 
	mcmdSe
;

230 
	mwaySe
;

231 
	mptAddss
;

232 
	mgFtusAddss
;

233 
	mcomiAddss
;

234 
	mlunSe
;

235 } 
	tT4REG_CMD_GET_LUN_FEATURES
;

239 
	mcmdSe
;

240 } 
	tT4REG_CMD_SET_SCRAMBLER
;

244 
	mcmdSe
;

245 
	mwaySe
;

246 
	mptAddss
;

247 } 
	tT4REG_CMD_READ_STATUS
;

251 
	mcmdSe
;

252 
	mwaySe
;

253 
	mrowAddss
;

254 } 
	tT4REG_CMD_ERASE_BLOCK
;

258 
	mcmdSe
;

259 
	mwaySe
;

260 
	mrowAddss
;

261 } 
	tT4REG_CMD_READ_PAGE_TRIGGER
;

265 
	mcmdSe
;

266 
	mwaySe
;

267 
	mrowAddss
;

268 
	meSe
;

269 } 
	tT4REG_CMD_SINGLE_STATE_READ_PAGE_TRIGGER
;

273 
	mcmdSe
;

274 
	mwaySe
;

275 
	mrowAddss
;

276 
	mgeDaAddss
;

277 
	meDaAddss
;

278 
	mrInfoAddss
;

279 
	mcomiRtAddss
;

280 } 
	tT4REG_CMD_READ_PAGE_TRANSFER_PSLC
;

284 
	mcmdSe
;

285 
	mwaySe
;

286 
	mrowAddss
;

287 
	mgeDaAddss
;

288 
	meDaAddss
;

289 } 
	tT4REG_CMD_PROGRAM_PAGE_TRANSFER_PSLC
;

293 
	mcmdSe
;

294 
	mwaySe
;

295 
	mrowAddss
;

298 
	mgeDaAddss
;

299 
	meDaAddss
;

300 
	mrInfoAddss
;

301 } 
	mSubges
[4];

302 
	mcomiRtAddss
;

303 } 
	tT4REG_CMD_READ_PAGE_TRANSFER
;

307 
	mcmdSe
;

308 
	mwaySe
;

309 
	mrowAddss
;

312 
	mgeDaAddss
;

313 
	meDaAddss
;

314 } 
	mSubges
[4];

315 } 
	tT4REG_CMD_PROGRAM_PAGE_TRANSFER
;

319 
	mcmdSe
;

320 
	mwaySe
;

321 
	mrowAddss
;

322 
	mti
;

325 
	mgeDaAddss
;

326 
	meDaAddss
;

327 } 
	mSubges
[4];

328 } 
	tT4REG_CMD_FSP_TRANSFER
;

330 
	#T4NSC_CMD_FSP_TRANSFER_OPTION_LSB_PASSNEXT
 3

	)

331 
	#T4NSC_CMD_FSP_TRANSFER_OPTION_LSB_COMMIT
 2

	)

332 
	#T4NSC_CMD_FSP_TRANSFER_OPTION_CSB_PASSNEXT
 5

	)

333 
	#T4NSC_CMD_FSP_TRANSFER_OPTION_CSB_COMMIT
 4

	)

334 
	#T4NSC_CMD_FSP_TRANSFER_OPTION_MSB_COMMIT
 6

	)

338 
	mcmdSe
;

339 
	mwaySe
;

340 
	mcAddss
;

341 
	mwdLgth
;

342 
	mgeDaAddss
;

343 
	mcomiRtAddss
;

344 } 
	tT4REG_CMD_READ_PAGE_TRANSFER_RAW
;

348 
	mcmdSe
;

349 
	mwaySe
;

350 
	mrowAddss
;

351 
	mcAddss
;

352 
	mwdLgth
;

353 
	mgeDaAddss
;

354 } 
	tT4REG_CMD_PROGRAM_PAGE_TRANSFER_RAW
;

358 
	mcmdSe
;

359 
	mwaySe
;

360 
	mrowAddss
;

361 
	mcAddss
;

362 
	mwdLgth
;

363 
	mgeDaAddss
;

364 
	mti
;

365 } 
	tT4REG_CMD_PROGRAM_PAGE_TRANSFER_RAW_XSBOPTION
;

367 
	#T4NSC_CMD_FSP_TRANSFER_OPTION_LSB_PASSNEXT
 3

	)

368 
	#T4NSC_CMD_FSP_TRANSFER_OPTION_LSB_COMMIT
 2

	)

369 
	#T4NSC_CMD_FSP_TRANSFER_OPTION_CSB_PASSNEXT
 5

	)

370 
	#T4NSC_CMD_FSP_TRANSFER_OPTION_CSB_COMMIT
 4

	)

371 
	#T4NSC_CMD_FSP_TRANSFER_OPTION_MSB_COMMIT
 6

	)

375 
	mcmdSe
;

376 
	mrved
;

377 
	mgeBufrAddss
;

378 
	meBufrAddss
;

379 } 
	tT4REG_CMD_SET_BUFFER_BASEADDRESS
;

383 
	mcmdSe
;

384 
	mwaySe
;

385 
	mrowAddss
;

388 
	mgeBufrIndex
:16;

389 
	meBufrIndex
:16;

390 } 
	mSubges
[4];

391 
	mcomiRtAddss
;

392 } 
	tT4REG_CMD_INDEXED_READ_PAGE_TRANSFER
;

396 
	mcmdSe
;

397 
	mwaySe
;

398 
	mrowAddss
;

401 
	mgeBufrIndex
:16;

402 
	meBufrIndex
:16;

403 } 
	mSubges
[4];

404 } 
	tT4REG_CMD_INDEXED_PROGRAM_PAGE_TRANSFER
;

408 
	mcmdSe
;

409 
	mwaySe
;

410 
	mcAddss
;

411 
	mngth
;

412 
	mptAddss
;

413 
	mcomiRtAddss
;

414 } 
	tT4REG_CMD_READ_ID
;

418 
	mcSucss
:1;

419 
	meSucss
:1;

420 
	mgeSucss
:32;

421 
	mtٮECou
:8;

422 
	mwܡECou
:5;

423 
	mchunk0ECou
:5;

424 
	mchunk1ECou
:5;

425 
	mchunk2ECou
:5;

426 
	mchunk3ECou
:5;

427 
	mchunk4ECou
:5;

428 
	mchunk5ECou
:5;

429 
	mchunk6ECou
:5;

430 
	mchunk7ECou
:5;

431 } 
	tT4NSC_BCH_ERROR_INFO
;

433 
nfc_t_dqs_day
(
chl
, 
wVue
);

434 
nfc_t_dq_day
(
chl
, 
wVue
);

435 
V2FInlizeHd
(
T4REGS
* 
t4gs
, * 
t4nscRegiBaAddss
);

436 
V2FRetSync
(
T4REGS
* 
t4gs
, 
way
);

437 
V2FSFtusSync
(
T4REGS
* 
t4gs
, 
way
, 
u0x02
, 
u0x10
, 
u0x01
, 
yLdAddr
);

438 
V2FRdPageTriggAsync
(
T4REGS
* 
t4gs
, 
way
, 
rowAddss
);

439 
V2FRdPageTnsrAsync
(
T4REGS
* 
t4gs
, 
way
, * 
geDaBufr
, * 
eDaBufr
, * 
rInfmi
, * 
comi
, 
rowAddss
);

440 
V2FRdPageTnsrRawAsync
(
T4REGS
* 
t4gs
, 
way
, * 
geDaBufr
, * 
comi
);

441 
V2FProgmPageAsync
(
T4REGS
* 
t4gs
, 
way
, 
rowAddss
, * 
geDaBufr
, * 
eDaBufr
);

442 
V2FEBlockAsync
(
T4REGS
* 
t4gs
, 
way
, 
rowAddss
);

443 
V2FStusCheckAsync
(
T4REGS
* 
t4gs
, 
way
, * 
usRt
);

444 
V2FRdIdAsync
(
T4REGS
* 
t4gs
, 
way
, * 
usRt
, * 
comi
);

445 
V2FRdIdSync
(
T4REGS
* 
t4gs
, 
way
, * 
usRt
);

446 
V2FRdyBusyAsync
(
T4REGS
* 
t4gs
);

	@nvme/debug.h

47 #ide
__DEBUG_H_


48 
	#__DEBUG_H_


	)

50 
	~"as.h
"

52 
	#__ASSERT
 1

	)

54 #i
__ASSERT


55 
	#ASSERT
(
X
) \

56 i(!(
X
)) \

58 
	`x_tf
("\r\n\ü i%s: L%d\r\n", 
__FILE__
, 
__LINE__
); \

60 }

	)

62 
	#ASSERT
(
X
)

	)

	@nvme/host_lld.c

53 
	~"dio.h
"

54 
	~"x_exi.h
"

55 
	~"x_tf.h
"

56 
	~"debug.h
"

57 
	~"io_acss.h
"

59 
	~"nvme.h
"

60 
	~"ho_d.h
"

62 
NVME_CONTEXT
 
g_nvmeTask
;

63 
HOST_DMA_STATUS
 
	gg_hoDmaStus
;

64 
HOST_DMA_ASSIST_STATUS
 
	gg_hoDmaAssiStus
;

66 
	$dev_q_
()

68 
DEV_IRQ_REG
 
devReg
;

70 
devReg
.
dwd
 = 0;

71 
devReg
.
pcLk
 = 1;

72 
devReg
.
busMa
 = 1;

73 
devReg
.
pcIrq
 = 1;

74 
devReg
.
pcMsi
 = 1;

75 
devReg
.
pcMsix
 = 1;

76 
devReg
.
nvmeCcEn
 = 1;

77 
devReg
.
nvmeCcShn
 = 1;

78 
devReg
.
mAxiWreE
 = 1;

79 
devReg
.
pcMqE
 = 1;

80 
devReg
.
pcCdE
 = 1;

81 
devReg
.
pcCdLE
 = 1;

83 
	`IO_WRITE32
(
DEV_IRQ_MASK_REG_ADDR
, 
devReg
.
dwd
);

84 
	}
}

86 
	$dev_q_hdr
()

88 
DEV_IRQ_REG
 
devReg
;

91 
devReg
.
dwd
 = 
	`IO_READ32
(
DEV_IRQ_STATUS_REG_ADDR
);

92 
	`IO_WRITE32
(
DEV_IRQ_CLEAR_REG_ADDR
, 
devReg
.
dwd
);

95 if(
devReg
.
pcLk
 == 1)

97 
PCIE_STATUS_REG
 
pcReg
;

98 
pcReg
.
dwd
 = 
	`IO_READ32
(
PCIE_STATUS_REG_ADDR
);

99 
	`x_tf
("PCILk: %d\r\n", 
pcReg
.
pcLkUp
);

101 if(
pcReg
.
pcLkUp
 == 0)

102 
g_nvmeTask
.
us
 = 
NVME_TASK_RESET
;

105 if(
devReg
.
busMa
 == 1)

107 
PCIE_FUNC_REG
 
pcReg
;

108 
pcReg
.
dwd
 = 
	`IO_READ32
(
PCIE_FUNC_REG_ADDR
);

109 
	`x_tf
("PCIBuMa: %d\r\n", 
pcReg
.
busMa
);

112 if(
devReg
.
pcIrq
 == 1)

114 
PCIE_FUNC_REG
 
pcReg
;

115 
pcReg
.
dwd
 = 
	`IO_READ32
(
PCIE_FUNC_REG_ADDR
);

116 
	`x_tf
("PCIIRQ Dib: %d\r\n", 
pcReg
.
qDib
);

119 if(
devReg
.
pcMsi
 == 1)

121 
PCIE_FUNC_REG
 
pcReg
;

122 
pcReg
.
dwd
 = 
	`IO_READ32
(
PCIE_FUNC_REG_ADDR
);

123 
	`x_tf
("PCIMSI Eb: %d, 0x%x\r\n", 
pcReg
.
msiEb
,cReg.
msiVecNum
);

126 if(
devReg
.
pcMsix
 == 1)

128 
PCIE_FUNC_REG
 
pcReg
;

129 
pcReg
.
dwd
 = 
	`IO_READ32
(
PCIE_FUNC_REG_ADDR
);

130 
	`x_tf
("PCIMSI-X Eb: %d\r\n", 
pcReg
.
msixEb
);

133 if(
devReg
.
nvmeCcEn
 == 1)

135 
NVME_STATUS_REG
 
nvmeReg
;

136 
nvmeReg
.
dwd
 = 
	`IO_READ32
(
NVME_STATUS_REG_ADDR
);

137 
	`x_tf
("NVME CC.EN: %d\r\n", 
nvmeReg
.
ccEn
);

139 if(
nvmeReg
.
ccEn
 == 1)

140 
g_nvmeTask
.
us
 = 
NVME_TASK_WAIT_CC_EN
;

142 
g_nvmeTask
.
us
 = 
NVME_TASK_RESET
;

146 if(
devReg
.
nvmeCcShn
 == 1)

148 
NVME_STATUS_REG
 
nvmeReg
;

149 
nvmeReg
.
dwd
 = 
	`IO_READ32
(
NVME_STATUS_REG_ADDR
);

150 
	`x_tf
("NVME CC.SHN: %d\r\n", 
nvmeReg
.
ccShn
);

151 if(
nvmeReg
.
ccShn
 == 1)

152 
g_nvmeTask
.
us
 = 
NVME_TASK_SHUTDOWN
;

155 if(
devReg
.
mAxiWreE
 == 1)

157 
	`x_tf
("mAxiWriteErr\r\n");

160 if(
devReg
.
pcMqE
 == 1)

162 
	`x_tf
("pcieMreqErr\r\n");

165 if(
devReg
.
pcCdE
 == 1)

167 
	`x_tf
("pcieCpldErr\r\n");

170 if(
devReg
.
pcCdLE
 == 1)

172 
	`x_tf
("pcieCpldLenErr\r\n");

175 
	}
}

177 
	$check_nvme_cc_
()

179 
NVME_STATUS_REG
 
nvmeReg
;

181 
nvmeReg
.
dwd
 = 
	`IO_READ32
(
NVME_STATUS_REG_ADDR
);

183  ()
nvmeReg
.
ccEn
;

184 
	}
}

186 
	$pc_async_t
(
rC
)

188 
NVME_STATUS_REG
 
nvmeReg
;

190 
nvmeReg
.
rC
 =stCnt;

191 
	`x_tf
("rC%X \r\n",
rC
);

192 
	`IO_WRITE32
(
NVME_STATUS_REG_ADDR
, 
nvmeReg
.
dwd
);

194 
	}
}

196 
	$t_lk_width
(
lkNum
)

198 
NVME_STATUS_REG
 
nvmeReg
;

200 
nvmeReg
.
lkNum
 =inkNum;

201 
nvmeReg
.
lkEn
 = 1;

202 
	`x_tf
("lkNum%X \r\n",
lkNum
);

203 
	`IO_WRITE32
(
NVME_STATUS_REG_ADDR
, 
nvmeReg
.
dwd
);

205 
	}
}

208 
	$t_nvme_cs_rdy
(
rdy
)

210 
NVME_STATUS_REG
 
nvmeReg
;

212 
nvmeReg
.
dwd
 = 
	`IO_READ32
(
NVME_STATUS_REG_ADDR
);

213 
nvmeReg
.
csRdy
 = 
rdy
;

215 
	`IO_WRITE32
(
NVME_STATUS_REG_ADDR
, 
nvmeReg
.
dwd
);

216 
	}
}

218 
	$t_nvme_cs_sh
(
sh
)

220 
NVME_STATUS_REG
 
nvmeReg
;

222 
nvmeReg
.
dwd
 = 
	`IO_READ32
(
NVME_STATUS_REG_ADDR
);

223 
nvmeReg
.
csSh
 = 
sh
;

225 
	`IO_WRITE32
(
NVME_STATUS_REG_ADDR
, 
nvmeReg
.
dwd
);

226 
	}
}

228 
	$t_nvme_adm_queue
(
sqVid
, 
cqVid
, 
cqIrqEn
)

230 
NVME_ADMIN_QUEUE_SET_REG
 
nvmeReg
;

232 
nvmeReg
.
dwd
 = 
	`IO_READ32
(
NVME_ADMIN_QUEUE_SET_REG_ADDR
);

233 
nvmeReg
.
sqVid
 = sqValid;

234 
nvmeReg
.
cqVid
 = cqValid;

235 
nvmeReg
.
cqIrqEn
 = cqIrqEn;

237 
	`IO_WRITE32
(
NVME_ADMIN_QUEUE_SET_REG_ADDR
, 
nvmeReg
.
dwd
);

238 
	}
}

241 
	$g_nvme_cmd
(*
qID
, *
cmdSlTag
, *
cmdSeqNum
, *
cmdDwd
)

243 
NVME_CMD_FIFO_REG
 
nvmeReg
;

245 
nvmeReg
.
dwd
 = 
	`IO_READ32
(
NVME_CMD_FIFO_REG_ADDR
);

247 if(
nvmeReg
.
cmdVid
 == 1)

249 
addr
;

250 
idx
;

251 *
qID
 = 
nvmeReg
.qID;

252 *
cmdSlTag
 = 
nvmeReg
.cmdSlotTag;

253 *
cmdSeqNum
 = 
nvmeReg
.cmdSeqNum;

255 
addr
 = 
NVME_CMD_SRAM_ADDR
 + (
nvmeReg
.
cmdSlTag
 * 64);

256 
idx
 = 0; idx < 16; idx++)

257 *(
cmdDwd
 + 
idx

	`IO_READ32
(
addr
 + (idx * 4));

260  ()
nvmeReg
.
cmdVid
;

261 
	}
}

263 
	$t_auto_nvme_l
(
cmdSlTag
, 
ecific
, 
usFldWd
)

265 
NVME_CPL_FIFO_REG
 
nvmeReg
;

267 
nvmeReg
.
ecific
 = specific;

268 
nvmeReg
.
cmdSlTag
 = cmdSlotTag;

269 
nvmeReg
.
usFldWd
 = statusFieldWord;

270 
nvmeReg
.
lTy
 = 
AUTO_CPL_TYPE
;

273 
	`IO_WRITE32
((
NVME_CPL_FIFO_REG_ADDR
 + 4), 
nvmeReg
.
dwd
[1]);

274 
	`IO_WRITE32
((
NVME_CPL_FIFO_REG_ADDR
 + 8), 
nvmeReg
.
dwd
[2]);

275 
	}
}

277 
	$t_nvme__a
(
cmdSlTag
)

279 
NVME_CPL_FIFO_REG
 
nvmeReg
;

281 
nvmeReg
.
cmdSlTag
 = cmdSlotTag;

282 
nvmeReg
.
lTy
 = 
CMD_SLOT_RELEASE_TYPE
;

286 
	`IO_WRITE32
((
NVME_CPL_FIFO_REG_ADDR
 + 8), 
nvmeReg
.
dwd
[2]);

287 
	}
}

289 
	$t_nvme_l
(
sqId
, 
cid
, 
ecific
, 
usFldWd
)

291 
NVME_CPL_FIFO_REG
 
nvmeReg
;

293 
nvmeReg
.
cid
 = cid;

294 
nvmeReg
.
sqId
 = sqId;

295 
nvmeReg
.
ecific
 = specific;

296 
nvmeReg
.
usFldWd
 = statusFieldWord;

297 
nvmeReg
.
lTy
 = 
ONLY_CPL_TYPE
;

299 
	`IO_WRITE32
(
NVME_CPL_FIFO_REG_ADDR
, 
nvmeReg
.
dwd
[0]);

300 
	`IO_WRITE32
((
NVME_CPL_FIFO_REG_ADDR
 + 4), 
nvmeReg
.
dwd
[1]);

301 
	`IO_WRITE32
((
NVME_CPL_FIFO_REG_ADDR
 + 8), 
nvmeReg
.
dwd
[2]);

302 
	}
}

304 
	$t_io_sq
(
ioSqIdx
, 
vid
, 
cqVe
, 
qSz
, 
pcBaAddrL
, 
pcBaAddrH
)

306 
NVME_IO_SQ_SET_REG
 
nvmeReg
;

307 
addr
;

309 
nvmeReg
.
vid
 = valid;

310 
nvmeReg
.
cqVe
 = cqVector;

311 
nvmeReg
.
sqSize
 = 
qSz
;

312 
nvmeReg
.
pcBaAddrL
 =cieBaseAddrL;

313 
nvmeReg
.
pcBaAddrH
 =cieBaseAddrH;

315 
addr
 = 
NVME_IO_SQ_SET_REG_ADDR
 + (
ioSqIdx
 * 8);

316 
	`IO_WRITE32
(
addr
, 
nvmeReg
.
dwd
[0]);

317 
	`IO_WRITE32
((
addr
 + 4), 
nvmeReg
.
dwd
[1]);

318 
	}
}

320 
	$t_io_cq
(
ioCqIdx
, 
vid
, 
qEn
, 
qVe
, 
qSz
, 
pcBaAddrL
, 
pcBaAddrH
)

322 
NVME_IO_CQ_SET_REG
 
nvmeReg
;

323 
addr
;

325 
nvmeReg
.
vid
 = valid;

326 
nvmeReg
.
qEn
 = irqEn;

327 
nvmeReg
.
qVe
 = irqVector;

328 
nvmeReg
.
cqSize
 = 
qSz
;

329 
nvmeReg
.
pcBaAddrL
 =cieBaseAddrL;

330 
nvmeReg
.
pcBaAddrH
 =cieBaseAddrH;

332 
addr
 = 
NVME_IO_CQ_SET_REG_ADDR
 + (
ioCqIdx
 * 8);

333 
	`IO_WRITE32
(
addr
, 
nvmeReg
.
dwd
[0]);

334 
	`IO_WRITE32
((
addr
 + 4), 
nvmeReg
.
dwd
[1]);

336 
	}
}

339 
	$t_de_tx_dma
(
devAddr
, 
pcAddrH
, 
pcAddrL
, 
n
)

341 
HOST_DMA_CMD_FIFO_REG
 
hoDmaReg
;

343 
	`ASSERT
((
n
 <0x1000&& ((
pcAddrL
 & 0x3) == 0));

345 
hoDmaReg
.
devAddr
 = devAddr;

346 
hoDmaReg
.
pcAddrL
 =cieAddrL;

347 
hoDmaReg
.
pcAddrH
 =cieAddrH;

349 
hoDmaReg
.
dwd
[3] = 0;

350 
hoDmaReg
.
dmaTy
 = 
HOST_DMA_DIRECT_TYPE
;

351 
hoDmaReg
.
dmaDei
 = 
HOST_DMA_TX_DIRECTION
;

352 
hoDmaReg
.
dmaL
 = 
n
;

354 
	`IO_WRITE32
(
HOST_DMA_CMD_FIFO_REG_ADDR
, 
hoDmaReg
.
dwd
[0]);

355 
	`IO_WRITE32
((
HOST_DMA_CMD_FIFO_REG_ADDR
 + 4), 
hoDmaReg
.
dwd
[1]);

356 
	`IO_WRITE32
((
HOST_DMA_CMD_FIFO_REG_ADDR
 + 8), 
hoDmaReg
.
dwd
[2]);

357 
	`IO_WRITE32
((
HOST_DMA_CMD_FIFO_REG_ADDR
 + 12), 
hoDmaReg
.
dwd
[3]);

358 
	`IO_WRITE32
((
HOST_DMA_CMD_FIFO_REG_ADDR
 + 16), 
hoDmaReg
.
dwd
[4]);

360 
g_hoDmaStus
.
fifoTa
.
deDmaTx
++;

361 
g_hoDmaStus
.
deDmaTxC
++;

362 
	}
}

364 
	$t_de_rx_dma
(
devAddr
, 
pcAddrH
, 
pcAddrL
, 
n
)

366 
HOST_DMA_CMD_FIFO_REG
 
hoDmaReg
;

368 
	`ASSERT
((
n
 <0x1000&& ((
pcAddrL
 & 0x3) == 0));

370 
hoDmaReg
.
devAddr
 = devAddr;

371 
hoDmaReg
.
pcAddrH
 =cieAddrH;

372 
hoDmaReg
.
pcAddrL
 =cieAddrL;

374 
hoDmaReg
.
dwd
[3] = 0;

375 
hoDmaReg
.
dmaTy
 = 
HOST_DMA_DIRECT_TYPE
;

376 
hoDmaReg
.
dmaDei
 = 
HOST_DMA_RX_DIRECTION
;

377 
hoDmaReg
.
dmaL
 = 
n
;

379 
	`IO_WRITE32
(
HOST_DMA_CMD_FIFO_REG_ADDR
, 
hoDmaReg
.
dwd
[0]);

380 
	`IO_WRITE32
((
HOST_DMA_CMD_FIFO_REG_ADDR
 + 4), 
hoDmaReg
.
dwd
[1]);

381 
	`IO_WRITE32
((
HOST_DMA_CMD_FIFO_REG_ADDR
 + 8), 
hoDmaReg
.
dwd
[2]);

382 
	`IO_WRITE32
((
HOST_DMA_CMD_FIFO_REG_ADDR
 + 12), 
hoDmaReg
.
dwd
[3]);

383 
	`IO_WRITE32
((
HOST_DMA_CMD_FIFO_REG_ADDR
 + 16), 
hoDmaReg
.
dwd
[4]);

384 
g_hoDmaStus
.
fifoTa
.
deDmaRx
++;

385 
g_hoDmaStus
.
deDmaRxC
++;

387 
	}
}

389 
	$t_auto_tx_dma
(
cmdSlTag
, 
cmd4KBOfft
, 
devAddr
, 
autoComi
)

391 
HOST_DMA_CMD_FIFO_REG
 
hoDmaReg
;

392 
mpTa
;

394 
	`ASSERT
(
cmd4KBOfft
 < 256);

396 
g_hoDmaStus
.
fifoHd
.
dwd
 = 
	`IO_READ32
(
HOST_DMA_FIFO_CNT_REG_ADDR
);

397 (
g_hoDmaStus
.
fifoTa
.
autoDmaTx
 + 1% 256 =g_hoDmaStus.
fifoHd
.autoDmaTx)

398 
g_hoDmaStus
.
fifoHd
.
dwd
 = 
	`IO_READ32
(
HOST_DMA_FIFO_CNT_REG_ADDR
);

400 
hoDmaReg
.
devAddr
 = devAddr;

402 
hoDmaReg
.
dwd
[3] = 0;

403 
hoDmaReg
.
dmaTy
 = 
HOST_DMA_AUTO_TYPE
;

404 
hoDmaReg
.
dmaDei
 = 
HOST_DMA_TX_DIRECTION
;

405 
hoDmaReg
.
cmd4KBOfft
 = cmd4KBOffset;

406 
hoDmaReg
.
cmdSlTag
 = cmdSlotTag;

407 
hoDmaReg
.
autoComi
 =utoCompletion;

409 
	`IO_WRITE32
(
HOST_DMA_CMD_FIFO_REG_ADDR
, 
hoDmaReg
.
dwd
[0]);

412 
	`IO_WRITE32
((
HOST_DMA_CMD_FIFO_REG_ADDR
 + 12), 
hoDmaReg
.
dwd
[3]);

413 
	`IO_WRITE32
((
HOST_DMA_CMD_FIFO_REG_ADDR
 + 16), 
hoDmaReg
.
dwd
[4]);

415 
mpTa
 = 
g_hoDmaStus
.
fifoTa
.
autoDmaTx
++;

416 if(
mpTa
 > 
g_hoDmaStus
.
fifoTa
.
autoDmaTx
)

417 
g_hoDmaAssiStus
.
autoDmaTxOvFlowC
++;

419 
g_hoDmaStus
.
autoDmaTxC
++;

420 
	}
}

422 
	$t_auto_rx_dma
(
cmdSlTag
, 
cmd4KBOfft
, 
devAddr
, 
autoComi
)

424 
HOST_DMA_CMD_FIFO_REG
 
hoDmaReg
;

425 
mpTa
;

427 
	`ASSERT
(
cmd4KBOfft
 < 256);

429 
g_hoDmaStus
.
fifoHd
.
dwd
 = 
	`IO_READ32
(
HOST_DMA_FIFO_CNT_REG_ADDR
);

430 (
g_hoDmaStus
.
fifoTa
.
autoDmaRx
 + 1% 256 =g_hoDmaStus.
fifoHd
.autoDmaRx)

431 
g_hoDmaStus
.
fifoHd
.
dwd
 = 
	`IO_READ32
(
HOST_DMA_FIFO_CNT_REG_ADDR
);

433 
hoDmaReg
.
devAddr
 = devAddr;

435 
hoDmaReg
.
dwd
[3] = 0;

436 
hoDmaReg
.
dmaTy
 = 
HOST_DMA_AUTO_TYPE
;

437 
hoDmaReg
.
dmaDei
 = 
HOST_DMA_RX_DIRECTION
;

438 
hoDmaReg
.
cmd4KBOfft
 = cmd4KBOffset;

439 
hoDmaReg
.
cmdSlTag
 = cmdSlotTag;

440 
hoDmaReg
.
autoComi
 =utoCompletion;

442 
	`IO_WRITE32
(
HOST_DMA_CMD_FIFO_REG_ADDR
, 
hoDmaReg
.
dwd
[0]);

445 
	`IO_WRITE32
((
HOST_DMA_CMD_FIFO_REG_ADDR
 + 12), 
hoDmaReg
.
dwd
[3]);

446 
	`IO_WRITE32
((
HOST_DMA_CMD_FIFO_REG_ADDR
 + 16), 
hoDmaReg
.
dwd
[4]);

448 
mpTa
 = 
g_hoDmaStus
.
fifoTa
.
autoDmaRx
++;

449 if(
mpTa
 > 
g_hoDmaStus
.
fifoTa
.
autoDmaRx
)

450 
g_hoDmaAssiStus
.
autoDmaRxOvFlowC
++;

452 
g_hoDmaStus
.
autoDmaRxC
++;

453 
	}
}

455 
	$check_de_tx_dma_de
()

457 
g_hoDmaStus
.
fifoHd
.
deDmaTx
 !g_hoDmaStus.
fifoTa
.directDmaTx)

459 
g_hoDmaStus
.
fifoHd
.
dwd
 = 
	`IO_READ32
(
HOST_DMA_FIFO_CNT_REG_ADDR
);

461 
	}
}

463 
	$check_de_rx_dma_de
()

465 
g_hoDmaStus
.
fifoHd
.
deDmaRx
 !g_hoDmaStus.
fifoTa
.directDmaRx)

467 
g_hoDmaStus
.
fifoHd
.
dwd
 = 
	`IO_READ32
(
HOST_DMA_FIFO_CNT_REG_ADDR
);

469 
	}
}

471 
	$check_auto_tx_dma_de
()

473 
g_hoDmaStus
.
fifoHd
.
autoDmaTx
 !g_hoDmaStus.
fifoTa
.autoDmaTx)

475 
g_hoDmaStus
.
fifoHd
.
dwd
 = 
	`IO_READ32
(
HOST_DMA_FIFO_CNT_REG_ADDR
);

477 
	}
}

479 
	$check_auto_rx_dma_de
()

481 
g_hoDmaStus
.
fifoHd
.
autoDmaRx
 !g_hoDmaStus.
fifoTa
.autoDmaRx)

483 
g_hoDmaStus
.
fifoHd
.
dwd
 = 
	`IO_READ32
(
HOST_DMA_FIFO_CNT_REG_ADDR
);

485 
	}
}

487 
	$check_auto_tx_dma_l_de
(
Index
, 
AssiIndex
)

491 
g_hoDmaStus
.
fifoHd
.
dwd
 = 
	`IO_READ32
(
HOST_DMA_FIFO_CNT_REG_ADDR
);

493 if(
g_hoDmaStus
.
fifoHd
.
autoDmaTx
 =g_hoDmaStus.
fifoTa
.autoDmaTx)

496 if(
g_hoDmaStus
.
fifoHd
.
autoDmaTx
 < 
Index
)

498 if(
g_hoDmaStus
.
fifoTa
.
autoDmaTx
 < 
Index
)

500 if(
g_hoDmaStus
.
fifoTa
.
autoDmaTx
 > g_hoDmaStus.
fifoHd
.autoDmaTx)

503 if(
g_hoDmaAssiStus
.
autoDmaTxOvFlowC
 !(
AssiIndex
 + 1))

507 if(
g_hoDmaAssiStus
.
autoDmaTxOvFlowC
 !
AssiIndex
)

511 if(
g_hoDmaStus
.
fifoHd
.
autoDmaTx
 =
Index
)

515 if(
g_hoDmaStus
.
fifoTa
.
autoDmaTx
 < 
Index
)

519 if(
g_hoDmaStus
.
fifoTa
.
autoDmaTx
 > g_hoDmaStus.
fifoHd
.autoDmaTx)

522 if(
g_hoDmaAssiStus
.
autoDmaTxOvFlowC
 !
AssiIndex
)

528 
	}
}

530 
	$check_auto_rx_dma_l_de
(
Index
, 
AssiIndex
)

534 
g_hoDmaStus
.
fifoHd
.
dwd
 = 
	`IO_READ32
(
HOST_DMA_FIFO_CNT_REG_ADDR
);

536 if(
g_hoDmaStus
.
fifoHd
.
autoDmaRx
 =g_hoDmaStus.
fifoTa
.autoDmaRx)

539 if(
g_hoDmaStus
.
fifoHd
.
autoDmaRx
 < 
Index
)

541 if(
g_hoDmaStus
.
fifoTa
.
autoDmaRx
 < 
Index
)

543 if(
g_hoDmaStus
.
fifoTa
.
autoDmaRx
 > g_hoDmaStus.
fifoHd
.autoDmaRx)

546 if(
g_hoDmaAssiStus
.
autoDmaRxOvFlowC
 !(
AssiIndex
 + 1))

550 if(
g_hoDmaAssiStus
.
autoDmaRxOvFlowC
 !
AssiIndex
)

554 if(
g_hoDmaStus
.
fifoHd
.
autoDmaRx
 =
Index
)

558 if(
g_hoDmaStus
.
fifoTa
.
autoDmaRx
 < 
Index
)

562 if(
g_hoDmaStus
.
fifoTa
.
autoDmaRx
 > g_hoDmaStus.
fifoHd
.autoDmaRx)

565 if(
g_hoDmaAssiStus
.
autoDmaRxOvFlowC
 !
AssiIndex
)

571 
	}
}

	@nvme/host_lld.h

54 #ide
__HOST_LLD_H_


55 
	#__HOST_LLD_H_


	)

58 
	#HOST_IP_ADDR
 (
XPAR_NVME_CTRL_0_BASEADDR
)

	)

60 
	#DEV_IRQ_MASK_REG_ADDR
 (
HOST_IP_ADDR
 + 0x4)

	)

61 
	#DEV_IRQ_CLEAR_REG_ADDR
 (
HOST_IP_ADDR
 + 0x8)

	)

62 
	#DEV_IRQ_STATUS_REG_ADDR
 (
HOST_IP_ADDR
 + 0xC)

	)

64 
	#PCIE_STATUS_REG_ADDR
 (
HOST_IP_ADDR
 + 0x100)

	)

65 
	#PCIE_FUNC_REG_ADDR
 (
HOST_IP_ADDR
 + 0x104)

	)

67 
	#NVME_STATUS_REG_ADDR
 (
HOST_IP_ADDR
 + 0x200)

	)

68 
	#HOST_DMA_FIFO_CNT_REG_ADDR
 (
HOST_IP_ADDR
 + 0x204)

	)

69 
	#NVME_ADMIN_QUEUE_SET_REG_ADDR
 (
HOST_IP_ADDR
 + 0x21C)

	)

70 
	#NVME_IO_SQ_SET_REG_ADDR
 (
HOST_IP_ADDR
 + 0x220)

	)

71 
	#NVME_IO_CQ_SET_REG_ADDR
 (
HOST_IP_ADDR
 + 0x260)

	)

73 
	#NVME_CMD_FIFO_REG_ADDR
 (
HOST_IP_ADDR
 + 0x300)

	)

74 
	#NVME_CPL_FIFO_REG_ADDR
 (
HOST_IP_ADDR
 + 0x304)

	)

75 
	#HOST_DMA_CMD_FIFO_REG_ADDR
 (
HOST_IP_ADDR
 + 0x310)

	)

77 
	#NVME_CMD_SRAM_ADDR
 (
HOST_IP_ADDR
 + 0x10000)

	)

82 
	#HOST_DMA_DIRECT_TYPE
 (1)

	)

83 
	#HOST_DMA_AUTO_TYPE
 (0)

	)

85 
	#HOST_DMA_TX_DIRECTION
 (1)

	)

86 
	#HOST_DMA_RX_DIRECTION
 (0)

	)

88 
	#ONLY_CPL_TYPE
 (0)

	)

89 
	#AUTO_CPL_TYPE
 (1)

	)

90 
	#CMD_SLOT_RELEASE_TYPE
 (2)

	)

91 
	#P_SLOT_TAG_WIDTH
 (10)

92 

	)

93 #agm
ck
(
push
, 1)

95 
	s_DEV_IRQ_REG


98 
	mdwd
;

100 
	mpcLk
 :1;

101 
	mbusMa
 :1;

102 
	mpcIrq
 :1;

103 
	mpcMsi
 :1;

104 
	mpcMsix
 :1;

105 
	mnvmeCcEn
 :1;

106 
	mnvmeCcShn
 :1;

107 
	mmAxiWreE
 :1;

108 
	mmAxiRdE
 :1;

109 
	mpcMqE
 :1;

110 
	mpcCdE
 :1;

111 
	mpcCdLE
 :1;

112 
	mrved0
 :20;

115 } 
	tDEV_IRQ_REG
;

117 
	s_PCIE_STATUS_REG


120 
	mdwd
;

122 
	mssm
 :6;

123 
	mrved0
 :2;

124 
	mpcLkUp
 :1;

125 
	mrved1
 :23;

128 } 
	tPCIE_STATUS_REG
;

130 
	s_PCIE_FUNC_REG


133 
	mdwd
;

135 
	mbusMa
 :1;

136 
	mmsiEb
 :1;

137 
	mmsixEb
 :1;

138 
	mqDib
 :1;

139 
	mmsiVecNum
 :3;

140 
	mrved0
 :25;

143 } 
	tPCIE_FUNC_REG
;

146 
	s_NVME_STATUS_REG


149 
	mdwd
;

151 
	mccEn
 :1;

152 
	mccShn
 :2;

153 
	mrved0
 :1;

154 
	mcsRdy
 :1;

155 
	mcsSh
 :2;

156 
	mrC
 :4;

157 
	mlkNum
 :2;

158 
	mlkEn
 :2;

159 
	mrved1
 :17;

162 } 
	tNVME_STATUS_REG
;

165 
	s_NVME_CMD_FIFO_REG


168 
	mdwd
;

170 
	mqID
 :4;

171 
	mrved0
 :1;

172 
	mcmdSlTag
 :
P_SLOT_TAG_WIDTH
;

173 
	mrved2
 :1;

174 
	mcmdSeqNum
 :8;

175 
	mrved3
 :(17-
P_SLOT_TAG_WIDTH
);

176 
	mcmdVid
 :1;

179 } 
	tNVME_CMD_FIFO_REG
;

182 
	s_NVME_CPL_FIFO_REG


185 
	mdwd
[3];

189 
	mcid
 :16;

190 
	msqId
 :4;

191 
	mrved0
 :12;

194 
	mecific
;

196 
	mcmdSlTag
 :
P_SLOT_TAG_WIDTH
;

197 
	mrved1
 :(14- 
P_SLOT_TAG_WIDTH
);

198 
	mlTy
 :2;

201 
	musFldWd
;

204 
	mrved0
 :1;

205 
	mSC
 :8;

206 
	mSCT
 :3;

207 
	mrved1
 :2;

208 
	mMORE
 :1;

209 
	mDNR
 :1;

210 }
	musFld
;

214 } 
	tNVME_CPL_FIFO_REG
;

217 
	s_NVME_ADMIN_QUEUE_SET_REG


220 
	mdwd
;

222 
	mcqVid
 :1;

223 
	msqVid
 :1;

224 
	mcqIrqEn
 :1;

225 
	mrved0
 :29;

228 } 
	tNVME_ADMIN_QUEUE_SET_REG
;

231 
	s_NVME_IO_SQ_SET_REG


234 
	mdwd
[2];

236 
	mpcBaAddrL
;

237 
	mpcBaAddrH
 :16;

238 
	mvid
 :1;

239 
	mcqVe
 :4;

240 
	mrved1
 :3;

241 
	msqSize
 :8;

244 } 
	tNVME_IO_SQ_SET_REG
;

248 
	s_NVME_IO_CQ_SET_REG


251 
	mdwd
[2];

253 
	mpcBaAddrL
;

254 
	mpcBaAddrH
 :16;

255 
	mvid
 :1;

256 
	mqVe
 :3;

257 
	mqEn
 :1;

258 
	mrved1
 :3;

259 
	mcqSize
 :8;

262 } 
	tNVME_IO_CQ_SET_REG
;

265 
	s_HOST_DMA_FIFO_CNT_REG


268 
	mdwd
;

271 
	mdeDmaRx
;

272 
	mdeDmaTx
;

273 
	mautoDmaRx
;

274 
	mautoDmaTx
;

277 } 
	tHOST_DMA_FIFO_CNT_REG
;

280 
	s_HOST_DMA_CMD_FIFO_REG


283 
	mdwd
[5];

286 
	mdevAddr
;

287 
	mpcAddrH
;

288 
	mpcAddrL
;

291 
	mdmaL
 :13;

292 
	mautoComi
 :1;

293 
	mcmd4KBOfft
 :9;

294 
	mrved0
 :7;

295 
	mdmaDei
 :1;

296 
	mdmaTy
 :1;

298 
	mcmdSlTag
;

301 } 
	tHOST_DMA_CMD_FIFO_REG
;

304 
	s_NVME_CMD_SRAM


306 
	mdwd
[128][16];

307 } 
	t_NVME_CMD_SRAM
;

309 #agm
ck
(
p
)

312 
	s_HOST_DMA_STATUS


314 
HOST_DMA_FIFO_CNT_REG
 
	mfifoHd
;

315 
HOST_DMA_FIFO_CNT_REG
 
	mfifoTa
;

316 
	mdeDmaTxC
;

317 
	mdeDmaRxC
;

318 
	mautoDmaTxC
;

319 
	mautoDmaRxC
;

320 } 
	tHOST_DMA_STATUS
;

323 
	s_HOST_DMA_ASSIST_STATUS


325 
	mautoDmaTxOvFlowC
;

326 
	mautoDmaRxOvFlowC
;

327 } 
	tHOST_DMA_ASSIST_STATUS
;

329 
dev_q_
();

331 
dev_q_hdr
();

333 
check_nvme_cc_
();

335 
t_nvme_cs_rdy
();

337 
t_nvme_cs_sh
(
sh
);

339 
t_nvme_adm_queue
(
sqVid
, 
cqVid
, 
cqIrqEn
);

341 
g_nvme_cmd
(*
qID
, *
cmdSlTag
, *
cmdSeqNum
, *
cmdDwd
);

343 
t_auto_nvme_l
(
cmdSlTag
, 
ecific
, 
usFldWd
);

345 
t_nvme__a
(
cmdSlTag
);

347 
t_nvme_l
(
sqId
, 
cid
, 
ecific
, 
usFldWd
);

349 
t_io_sq
(
ioSqIdx
, 
vid
, 
cqVe
, 
qSz
, 
pcBaAddrL
, 
pcBaAddrH
);

351 
t_io_cq
(
ioCqIdx
, 
vid
, 
qEn
, 
qVe
, 
qSz
, 
pcBaAddrL
, 
pcBaAddrH
);

353 
t_de_tx_dma
(
devAddr
, 
pcAddrH
, 
pcAddrL
, 
n
);

355 
t_de_rx_dma
(
devAddr
, 
pcAddrH
, 
pcAddrL
, 
n
);

357 
t_auto_tx_dma
(
cmdSlTag
, 
cmd4KBOfft
, 
devAddr
, 
autoComi
);

359 
t_auto_rx_dma
(
cmdSlTag
, 
cmd4KBOfft
, 
devAddr
, 
autoComi
);

361 
t_lk_width
(
lkNum
);

363 
pc_async_t
(
rC
);

365 
check_de_tx_dma_de
();

367 
check_de_rx_dma_de
();

369 
check_auto_tx_dma_de
();

371 
check_auto_rx_dma_de
();

373 
check_auto_tx_dma_l_de
(
Index
, 
AssiIndex
);

375 
check_auto_rx_dma_l_de
(
Index
, 
AssiIndex
);

377 
HOST_DMA_STATUS
 
g_hoDmaStus
;

378 
HOST_DMA_ASSIST_STATUS
 
g_hoDmaAssiStus
;

	@nvme/io_access.h

48 #ide
__IO_ACCESS_H_


49 
	#__IO_ACCESS_H_


	)

51 
	#IO_WRITE32
(
addr
, 
v
*((vީ*)ddr)
	)
val

52 
	#IO_READ32
(
addr
*((vީ*)ddr))

	)

	@nvme/nvme.h

51 #ide
__NVME_H_


52 
	#__NVME_H_


	)

54 
	#MAX_NUM_OF_IO_SQ
 8

	)

55 
	#MAX_NUM_OF_IO_CQ
 8

	)

57 
	#ADMIN_CMD_DRAM_DATA_BUFFER
 0x00200000

	)

59 
	#STORAGE_CAPACITY_L
 0x00000000

60 
	#STORAGE_CAPACITY_H
 0x00000000

	)

62 
	#MAX_NUM_OF_NLB
 (512 * 1024 / 4096)

	)

65 
	#ADMIN_DELETE_IO_SQ
 0x00

	)

66 
	#ADMIN_CREATE_IO_SQ
 0x01

	)

67 
	#ADMIN_GET_LOG_PAGE
 0x02

	)

68 
	#ADMIN_DELETE_IO_CQ
 0x04

	)

69 
	#ADMIN_CREATE_IO_CQ
 0x05

	)

70 
	#ADMIN_IDENTIFY
 0x06

	)

71 
	#ADMIN_ABORT
 0x08

	)

72 
	#ADMIN_SET_FEATURES
 0x09

	)

73 
	#ADMIN_GET_FEATURES
 0x0A

	)

74 
	#ADMIN_ASYNCHRONOUS_EVENT_REQUEST
 0x0C

	)

75 
	#ADMIN_FIRMWARE_ACTIVATE
 0x10

	)

76 
	#ADMIN_FIRMWARE_IMAGE_DOWNLOAD
 0x11

	)

77 
	#ADMIN_FORMAT_NVM
 0x80

	)

78 
	#ADMIN_DOORBELL_BUFFER_CONFIG
 0x7C

	)

79 
	#ADMIN_SECURITY_SEND
 0x81

	)

80 
	#ADMIN_SECURITY_RECEIVE
 0x82

	)

83 
	#IO_NVM_FLUSH
 0x00

	)

84 
	#IO_NVM_WRITE
 0x01

	)

85 
	#IO_NVM_READ
 0x02

	)

86 
	#IO_NVM_WRITE_UNCORRECTABLE
 0x04

	)

87 
	#IO_NVM_COMPARE
 0x05

	)

88 
	#IO_NVM_DATASET_MANAGEMENT
 0x09

	)

91 
	#IO_NVM_PRINT_STAT
 0x80

	)

92 
	#IO_NVM_RESET
 0x81

	)

93 
	#IO_NVM_ALLOCATE
 0x82

	)

94 
	#IO_NVM_SHARE
 0x83

	)

98 
	#SCT_GENERIC_COMMAND_STATUS
 0

	)

99 
	#SCT_COMMAND_SPECIFIC_STATUS
 1

	)

100 
	#SCT_MEDIA_AND_DATA_INTEGRITY_ERRORS
 2

	)

101 
	#SCT_VENDOR_SPECIFIC
 7

	)

104 
	#SC_SUCCESSFUL_COMPLETION
 0x00

	)

105 
	#SC_INVALID_COMMAND_OPCODE
 0x01

	)

106 
	#SC_INVALID_FIELD_IN_COMMAND
 0x02

	)

107 
	#SC_COMMAND_ID_CONFLICT
 0x03

	)

108 
	#SC_DATA_TRANSFER_ERROR
 0x04

	)

109 
	#SC_COMMANDS_ABORTED_DUE_TO_POWER_LOSS_NOTIFICATION
 0x05

	)

110 
	#SC_INTERNAL_DEVICE_ERROR
 0x06

	)

111 
	#SC_COMMAND_ABORT_REQUESTED
 0x07

	)

112 
	#SC_COMMAND_ABORTED_DUE_TO_SQ_DELETION
 0x08

	)

113 
	#SC_COMMAND_ABORTED_DUE_TO_FAILED_FUSED_COMMAND
 0x09

	)

114 
	#SC_COMMAND_ABORTED_DUE_TO_MISSING_FUSED_COMMAND
 0x0A

	)

115 
	#SC_INVALID_NAMESPACE_OR_FORMAT
 0x0B

	)

116 
	#SC_COMMAND_SEQUENCE_ERROR
 0x0C

	)

117 
	#SC_INVALID_SGL_SEGMENT_DESCRIPTOR
 0x0D

	)

118 
	#SC_INVALID_NUMBER_OF_SGL_DESCRIPTORS
 0x0E

	)

119 
	#SC_DATA_SGL_LENGTH_INVALID
 0x0F

	)

120 
	#SC_METADATA_SGL_LENGTH_INVALID
 0x10

	)

121 
	#SC_SGL_DESCRIPTOR_TYPE_INVALID
 0x11

	)

122 
	#SC_INVALID_USE_OF_CONTROLLER_MEMORY_BUFFER
 0x12

	)

123 
	#SC_PRP_OFFSET_INVALID
 0x13

	)

124 
	#SC_ATOMIC_WRITE_UNIT_EXCEEDED
 0x14

	)

125 
	#SC_SGL_OFFSET_INVALID
 0x16

	)

126 
	#SC_SGL_SUB_TYPE_INVALID
 0x17

	)

127 
	#SC_HOST_IDENTIFIER_INCONSISTENT_FORMAT
 0x18

	)

128 
	#SC_KEEP_ALIVE_TIMEOUT_EXPIRED
 0x19

	)

129 
	#SC_KEEP_ALIVE_TIMEOUT_INVALID
 0x1A

	)

132 
	#SC_LBA_OUT_OF_RANGE
 0x80

	)

133 
	#SC_CAPACITY_EXCEEDED
 0x81

	)

134 
	#SC_NAMESPACE_NOT_READY
 0x82

	)

135 
	#SC_RESERVATION_CONFLICT
 0x83

	)

136 
	#SC_FORMAT_IN_PROGRESS
 0x84

	)

139 
	#SC_COMPLETION_QUEUE_INVALID
 0x00

140 
	#SC_INVALID_QUEUE_IDENTIFIER
 0x01

141 
	#SC_INVALID_QUEUE_SIZE
 0x02

142 
	#SC_ABORT_COMMAND_LIMIT_EXCEEDED
 0x03

143 
	#SC_ASYNCHRONOUS_EVENT_REQUEST_LIMIT_EXCEEDED
 0x05

144 
	#SC_INVALID_FIRMWARE_SLOT
 0x06

145 
	#SC_INVALID_FIRMWARE_IMAGE
 0x07

146 
	#SC_INVALID_INTERRUPT_VECTOR
 0x08

147 
	#SC_INVALID_LOG_PAGE
 0x09

148 
	#SC_INVALID_FORMAT
 0x0A

149 
	#SC_FIRMWARE_ACTIVATION_REQUIRES_CONVENTIONAL_RESET
 0x0B

150 
	#SC_INVALID_QUEUE_DELETION
 0x0C

151 
	#SC_FEATURE_IDENTIFIER_NOT_SAVEABLE
 0x0D

152 
	#SC_FEATURE_NOT_CHANGEABLE
 0x0E

153 
	#SC_FEATURE_NOT_NAMESPACE_SPECIFIC
 0x0F

154 
	#SC_FIRMWARE_ACTIVATION_REQUIRES_NVM_SUBSYSTEM_RESET
 0x10

155 
	#SC_FIRMWARE_ACTIVATION_REQUIRES_RESET
 0x11

156 
	#SC_FIRMWARE_ACTIVATION_REQUIRES_MAXIMUM_TIME_VIOLATION
 0x12

157 
	#SC_FIRMWARE_ACTIVATION_PROHIBITED
 0x13

158 
	#SC_OVERLAPPING_RANGE
 0x14

159 
	#SC_NAMESPACE_INSUFFICIENT_CAPACITY
 0x15

160 
	#SC_NAMESPACE_IDENTIFIER_UNAVAILABLE
 0x16

161 
	#SC_NAMESPACE_ALREADY_ATTACHED
 0x18

162 
	#SC_NAMESPACE_IS_PRIVATE
 0x19

163 
	#SC_NAMESPACE_NOT_ATTACHED
 0x1A

164 
	#SC_THIN_PROVISIONING_NOT_SUPPORTED
 0x1B

165 
	#SC_CONTROLLER_LIST_INVALID
 0x1C

166 

	)

168 
	#SC_CONFLICTING_ATTRIBUTES
 0x80

169 
	#SC_INVALID_PROTECTION_INFORMATION
 0x81

170 
	#SC_ATTEMPTED_WRITE_TO_READ_ONLY_RANGE
 0x82

171 

	)

173 
	#SC_WRITE_FAULT
 0x80

	)

174 
	#SC_UNRECOVERED_READ_ERROR
 0x81

	)

175 
	#SC_END_TO_END_GUARD_CHECK_ERROR
 0x82

	)

176 
	#SC_END_TO_END_APPLICATION_TAG_CHECK_ERROR
 0x83

	)

177 
	#SC_END_TO_END_REFERENCE_TAG_CHECK_ERROR
 0x84

	)

178 
	#SC_COMPARE_FAILURE
 0x85

	)

179 
	#SC_ACCESS_DENIED
 0x86

	)

180 
	#SC_DEALLOCATED_OR_UNWRITTEN_LOGICAL_BLOCK
 0x87

	)

185 
	#ARBITRATION
 0x01

	)

186 
	#POWER_MANAGEMENT
 0x02

	)

187 
	#LBA_RANGE_TYPE
 0x03

	)

188 
	#TEMPERATURE_THRESHOLD
 0x04

	)

189 
	#ERROR_RECOVERY
 0x05

	)

190 
	#VOLATILE_WRITE_CACHE
 0x06

	)

191 
	#NUMBER_OF_QUEUES
 0x07

	)

192 
	#INTERRUPT_COALESCING
 0x08

	)

193 
	#INTERRUPT_VECTOR_CONFIGURATION
 0x09

	)

194 
	#WRITE_ATOMICITY
 0x0A

	)

195 
	#ASYNCHRONOUS_EVENT_CONFIGURATION
 0x0B

	)

196 
	#Pow_S_Tnsi
 0x0C

	)

197 
	#Timeamp
 0x0E

	)

198 
	#SOFTWARE_PROGRESS_MARKER
 0x80

	)

201 
	#NVME_TASK_IDLE
 0x0

	)

202 
	#NVME_TASK_WAIT_CC_EN
 0x1

	)

203 
	#NVME_TASK_RUNNING
 0x2

	)

204 
	#NVME_TASK_SHUTDOWN
 0x3

	)

205 
	#NVME_TASK_WAIT_RESET
 0x4

	)

206 
	#NVME_TASK_RESET
 0x5

	)

207 #agm
ck
(
push
, 1)

209 
	s_NVME_COMMAND


211 
	mqID
;

212 
	mcmdSlTag
;

213 
	mcmdSeqNum
;

214 
	mcmdDwd
[16];

215 }
	tNVME_COMMAND
;

217 
	s_NVME_ADMIN_COMMAND


220 
	mdwd
[16];

223 
	mOPC
;

224 
	mFUSE
 :2;

225 
	mrved0
 :5;

226 
	mPSDT
 :1;

227 
	mCID
;

229 
	mNSID
;

230 
	mrved1
[2];

231 
	mMPTR
[2];

232 
	mPRP1
[2];

233 
	mPRP2
[2];

234 
	mdwd10
;

235 
	mdwd11
;

236 
	mdwd12
;

237 
	mdwd13
;

238 
	mdwd14
;

239 
	mdwd15
;

242 }
	tNVME_ADMIN_COMMAND
;

244 
	s_ADMIN_SET_FEATURES_NUMBER_OF_QUEUES_COMPLETE


247 
	mdwd
;

249 
	mNCQA
;

250 
	mNSQA
;

253 } 
	tADMIN_SET_FEATURES_NUMBER_OF_QUEUES_COMPLETE
;

255 
	s_NVME_IO_COMMAND


258 
	mdwd
[16];

261 
	mOPC
;

262 
	mFUSE
 :2;

263 
	mrved0
 :5;

264 
	mPSDT
 :1;

265 
	mCID
;

267 
	mNSID
;

268 
	mrved1
[2];

269 
	mMPTR
[2];

270 
	mPRP1
[2];

271 
	mPRP2
[2];

272 
	mdwd10
;

273 
	mdwd11
;

274 
	mdwd12
;

275 
	mdwd13
;

276 
	mdwd14
;

277 
	mdwd15
;

280 }
	tNVME_IO_COMMAND
;

282 
	s_NVME_COMPLETION


285 
	mdwd
[2];

288 
	musFldWd
;

291 
	mrved0
 :1;

292 
	mSC
 :8;

293 
	mSCT
 :3;

294 
	mrved1
 :2;

295 
	mMORE
 :1;

296 
	mDNR
 :1;

297 }
	musFld
;

300 
	mecific
;

303 }
	tNVME_COMPLETION
;

305 
	s_ADMIN_SET_FEATURES_DW10


308 
	mdwd
;

310 
	mFID
;

311 
	mrved0
[2];

312 
	mrved1
 :7;

313 
	mSV
 :1;

316 } 
	tADMIN_SET_FEATURES_DW10
;

318 
	s_ADMIN_SET_FEATURES_NUMBER_OF_QUEUES_DW11


321 
	mdwd
;

323 
	mNCQR
;

324 
	mNSQR
;

327 } 
	tADMIN_SET_FEATURES_NUMBER_OF_QUEUES_DW11
;

331 
	s_ADMIN_GET_FEATURES_DW10


334 
	mdwd
;

336 
	mFID
;

337 
	mSEL
 :3;

338 
	mrved0
 :5;

339 
	mrved1
[2];

342 } 
	tADMIN_GET_FEATURES_DW10
;

345 
	s_ADMIN_CREATE_IO_CQ_DW10


348 
	mdwd
;

350 
	mQID
;

351 
	mQSIZE
;

354 } 
	tADMIN_CREATE_IO_CQ_DW10
;

356 
	s_ADMIN_CREATE_IO_CQ_DW11


359 
	mdwd
;

361 
	mPC
 :1;

362 
	mIEN
 :1;

363 
	mrved0
 :14;

364 
	mIV
;

367 } 
	tADMIN_CREATE_IO_CQ_DW11
;

371 
	s_ADMIN_DELETE_IO_CQ_DW10


374 
	mdwd
;

376 
	mQID
;

377 
	mrved0
;

380 } 
	tADMIN_DELETE_IO_CQ_DW10
;

385 
	s_ADMIN_CREATE_IO_SQ_DW10


388 
	mdwd
;

390 
	mQID
;

391 
	mQSIZE
;

394 } 
	tADMIN_CREATE_IO_SQ_DW10
;

396 
	s_ADMIN_CREATE_IO_SQ_DW11


399 
	mdwd
;

401 
	mPC
 :1;

402 
	mQPRIO
 :2;

403 
	mrved0
 :13;

404 
	mCQID
;

407 } 
	tADMIN_CREATE_IO_SQ_DW11
;

410 
	s_ADMIN_DELETE_IO_SQ_DW10


413 
	mdwd
;

415 
	mQID
;

416 
	mrved0
;

419 } 
	tADMIN_DELETE_IO_SQ_DW10
;

422 
	s_ADMIN_IDENTIFY_COMMAND_DW10


425 
	mdwd
;

427 
	mCNS
 :1;

428 
	mrved0
 :31;

431 } 
	tADMIN_IDENTIFY_COMMAND_DW10
;

434 
	s_ADMIN_GET_LOG_PAGE_DW10


437 
	mdwd
;

439 
	mLID
;

440 
	mrved0
;

441 
	mNUMD
 :12;

442 
	mrved1
 :4;

445 } 
	tADMIN_GET_LOG_PAGE_DW10
;

448 
	s_ADMIN_IDENTIFY_POWER_STATE_DESCRIPTOR


451 
	mdwd
[8];

453 
	mMP
;

454 
	mrved0
 :8;

455 
	mMPS
 :1;

456 
	mNOPS
 :1;

457 
	mrved1
 :6;

458 
	mENLAT
;

459 
	mEXLAT
;

460 
	mRRT
 :5;

461 
	mrved2
 :3;

462 
	mRRL
 :5;

463 
	mrved3
 :3;

464 
	mRWT
 :5;

465 
	mrved4
 :3;

466 
	mRWL
 :5;

467 
	mrved5
 :3;

468 
	mrved6
[4];

471 } 
	tADMIN_IDENTIFY_POWER_STATE_DESCRIPTOR
;

474 
	s_ADMIN_IDENTIFY_CONTROLLER


476 
	mVID
;

477 
	mSSVID
;

478 
	mSN
[20];

479 
	mMN
[40];

480 
	mFR
[8];

481 
	mRAB
;

482 
	mIEEE
[3];

483 
	mCMIC
;

484 
	mMDTS
;

485 
	mCNTLID
;

486 
	mrved0
[176];

490 
	msutsSecurySdSecuryReive
 :1;

491 
	msutsFmNVM
 :1;

492 
	msutsFmweAiveFmweDowd
 :1;

493 
	mrved0
 :13;

494 } 
	mOACS
;

496 
	mACL
;

497 
	mAERL
;

501 
	mfFmweSlRdOy
 :1;

502 
	msu܋dNumbOfFmweSls
 :3;

503 
	mrved0
 :4;

504 } 
	mFRMW
;

508 
	msutsSMARTHhInfmiLogPage
 :1;

509 
	msutsCommdEfsLogPage
 :1;

510 
	mrved0
 :6;

511 } 
	mLPA
;

513 
	mELPE
;

514 
	mNPSS
;

516 
	mAVSCC
 :1;

517 
	mrved1
 :7;

519 
	mAPSTA
 :1;

520 
	mrved2
 :7;

522 
	mrved3
[246];

526 
	mquedSubmissiQueueErySize
 :4;

527 
	mmaximumSubmissiQueueErySize
 :4;

528 } 
	mSQES
;

532 
	mquedComiQueueErySize
 :4;

533 
	mmaximumComiQueueErySize
 :4;

534 } 
	mCQES
;

536 
	mrved4
[2];

537 
	mNN
;

541 
	msutsCom
 :1;

542 
	msutsWreUncܻab
 :1;

543 
	msutsDaSMagemt
 :1;

544 
	mrved0
 :13;

545 } 
	mONCS
;

549 
	msutsComWre
 :1;

550 
	mrved0
 :15;

551 } 
	mFUSES
;

555 
	mfmAlsToANameas
 :1;

556 
	mcuEAlsToANameas
 :1;

557 
	msutsCryogphicE
 :1;

558 
	mrved0
 :5;

559 } 
	mFNA
;

563 
	me
 :1;

564 
	mrved0
 :7;

565 } 
	mVWC
;

567 
	mAWUN
;

568 
	mAWUPF
;

570 
	mNVSCC
 :1;

571 
	mrved5
 :7;

573 
	mrved6
;

575 
	mACWU
;

577 
	mrved7
[2];

581 
	msutsSGL
 :1;

582 
	mrved0
 :15;

583 
	msutsSGLBBuckDest
 :1;

584 
	mrved1
 :15;

585 } 
	mSGLS
;

588 
	mrved8
[164];

589 
	mrved9
[1344];

591 
ADMIN_IDENTIFY_POWER_STATE_DESCRIPTOR
 
	mPSDx
[32];

593 
	mVS
[1024];

595 } 
	tADMIN_IDENTIFY_CONTROLLER
;

601 
	s_ADMIN_IDENTIFY_FORMAT_DATA


603 
	mMS
;

604 
	mLBADS
;

605 
	mRP
 :2;

606 
	mrved
 :6;

607 } 
	tADMIN_IDENTIFY_FORMAT_DATA
;

610 
	s_ADMIN_IDENTIFY_NAMESPACE


612 
	mNSZE
[2];

613 
	mNCAP
[2];

614 
	mNUSE
[2];

618 
	msutsDod
 :1;

619 
	msutsNawunNawupf
 :1;

620 
	msutsThProvisiښg
 :1;

621 
	mrved0
 :5;

622 } 
	mNSFEAT
;

624 
	mNLBAF
;

628 
	msu܋dCombi
 :4;

629 
	msutsMadaAtEndOfLBA
 :1;

630 
	mrved0
 :3;

631 } 
	mFLBAS
;

635 
	msutsMadaAsPtOfLBA
 :1;

636 
	msutsMadaAsSe
 :1;

637 
	mrved0
 :6;

638 } 
	mMC
;

643 
	msutsPreiTy1
 :1;

644 
	msutsPreiTy2
 :1;

645 
	msutsPreiTy3
 :1;

646 
	msutsPreiF8
 :1;

647 
	msutsPreiLa8
 :1;

648 
	mrved0
 :3;

649 } 
	mDPC
;

653 
	meiEbd
 :3;

654 
	meiInF8
 :1;

655 
	mrved0
 :4;

656 } 
	mDPS
;

660 
	msutsMuɝhIOShg
 :1;

661 
	mrved0
 :7;

662 } 
	mNMIC
;

666 
	msutsPsiThroughPowLoss
 :1;

667 
	msutsWreExusiveRervi
 :1;

668 
	msutsWreExusiveRegis
 :1;

669 
	msutsExusiveAcssRegis
 :1;

670 
	msutsWreExusiveARegis
 :1;

671 
	msutsExusiveAcssARegis
 :1;

672 
	mrved0
 :2;

673 } 
	mRESCAP
;

675 
	mrved0
[88];

676 
	mEUI64
[8];

678 
ADMIN_IDENTIFY_FORMAT_DATA
 
	mLBAFx
[16];

680 
	mrved1
[192];

681 
	mVS
[3712];

683 } 
	tADMIN_IDENTIFY_NAMESPACE
;

687 
	s_IO_WRITE_COMMAND_DW12


690 
	mdwd
;

692 
	mNLB
;

693 
	mrved0
 :10;

694 
	mPRINFO
 :4;

695 
	mFUA
 :1;

696 
	mLR
 :1;

699 } 
	tIO_WRITE_COMMAND_DW12
;

701 
	s_IO_WRITE_COMMAND_DW13


704 
	mdwd
;

708 
	mAcssFqucy
 :4;

709 
	mAcssLcy
 :2;

710 
	mSequtlReque
 :1;

711 
	mIncomessib
 :1;

712 } 
	mDSM
;

713 
	mrved0
[3];

716 } 
	tIO_WRITE_COMMAND_DW13
;

718 
	s_IO_WRITE_COMMAND_DW15


721 
	mdwd
;

723 
	mELBAT
;

724 
	mELBATM
;

727 } 
	tIO_WRITE_COMMAND_DW15
;

731 
	s_IO_READ_COMMAND_DW12


734 
	mdwd
;

736 
	mNLB
;

737 
	mrved0
 :10;

738 
	mPRINFO
 :4;

739 
	mFUA
 :1;

740 
	mLR
 :1;

743 } 
	tIO_READ_COMMAND_DW12
;

745 
	s_IO_READ_COMMAND_DW13


748 
	mdwd
;

752 
	mAcssFqucy
 :4;

753 
	mAcssLcy
 :2;

754 
	mSequtlReque
 :1;

755 
	mIncomessib
 :1;

756 } 
	mDSM
;

757 
	mrved0
[3];

760 } 
	tIO_READ_COMMAND_DW13
;

762 
	s_IO_READ_COMMAND_DW15


765 
	mdwd
;

767 
	mELBAT
;

768 
	mELBATM
;

771 } 
	tIO_READ_COMMAND_DW15
;

791 
	s_IO_DATASET_MANAGEMENT_COMMAND_DW10


794 
	mdwd
;

796 
	mNR
 :8;

797 
	mrved0
 :24;

800 } 
	tIO_DATASET_MANAGEMENT_COMMAND_DW10
;

802 
	s_IO_DATASET_MANAGEMENT_COMMAND_DW11


805 
	mdwd
;

807 
	mIDR
 :1;

808 
	mIDW
 :1;

809 
	mAD
 :1;

810 
	mrved0
 :29;

813 } 
	tIO_DATASET_MANAGEMENT_COMMAND_DW11
;

815 
	s_DATASET_MANAGEMENT_CONTEXT_ATTRIBUTES


817 
	mAF
 :4;

818 
	mAL
 :2;

819 
	mrved0
 :2;

820 
	mSR
 :1;

821 
	mSW
 :1;

822 
	mWP
 :1;

823 
	mrved1
 :13;

824 
	mCommdAcssSize
 :8;

825 } 
	tDATASET_MANAGEMENT_CONTEXT_ATTRIBUTES
;

827 
	s_DATASET_MANAGEMENT_RANGE


829 
DATASET_MANAGEMENT_CONTEXT_ATTRIBUTES
 
	mCڋxtAribus
;

830 
	mngthInLogilBlocks
;

831 
	mtgLBA
[2];

832 } 
	tDATASET_MANAGEMENT_RANGE
;

834 #agm
ck
(
p
)

837 
	s_DATASET_MANAGEMENT_RANGE_SHARE


839 
DATASET_MANAGEMENT_CONTEXT_ATTRIBUTES
 
	mCڋxtAribus
;

840 
	mngth
;

841 
	mLBA1
[2];

842 
	mLBA2
[2];

843 } 
	tDATASET_MANAGEMENT_RANGE_SHARE
;

845 
	s_NVME_METADATA


847 
	mLBA1
[2];

848 } 
	tNVME_METADATA
;

850 
	s_NVME_ADMIN_QUEUE_STATUS


852 
	mab
;

853 
	msqVid
;

854 
	mcqVid
;

855 
	mqEn
;

856 } 
	tNVME_ADMIN_QUEUE_STATUS
;

858 
	s_NVME_IO_SQ_STATUS


860 
	mvid
;

861 
	mcqVe
;

862 
	mqSz
;

863 
	mpcBaAddrL
;

864 
	mpcBaAddrH
;

865 } 
	tNVME_IO_SQ_STATUS
;

867 
	s_NVME_IO_CQ_STATUS


869 
	mvid
;

870 
	mqEn
;

871 
	mrved0
;

872 
	mqVe
;

873 
	mqSz
;

874 
	mpcBaAddrL
;

875 
	mpcBaAddrH
;

876 } 
	tNVME_IO_CQ_STATUS
;

878 
	s_NVME_STATUS


880 
	mus
;

881 
	mcheEn
;

882 
NVME_ADMIN_QUEUE_STATUS
 
	madmQueueInfo
;

883 
	mnumOfIOSubmissiQueuesAod
;

884 
	mnumOfIOComiQueuesAod
;

885 
NVME_IO_SQ_STATUS
 
	mioSqInfo
[
MAX_NUM_OF_IO_SQ
];

886 
NVME_IO_CQ_STATUS
 
	mioCqInfo
[
MAX_NUM_OF_IO_CQ
];

887 } 
	tNVME_CONTEXT
;

	@nvme/nvme_admin_cmd.c

48 
	~"x_tf.h
"

49 
	~"debug.h
"

50 
	~"rg.h
"

51 
	~"io_acss.h
"

53 
	~"nvme.h
"

54 
	~"ho_d.h
"

55 
	~"nvme_idtify.h
"

56 
	~"nvme_adm_cmd.h
"

58 
NVME_CONTEXT
 
g_nvmeTask
;

60 
	$g_num_of_queue
(
dwd11
)

62 
ADMIN_SET_FEATURES_NUMBER_OF_QUEUES_DW11
 
queed
;

63 
ADMIN_SET_FEATURES_NUMBER_OF_QUEUES_COMPLETE
 
lod
;

65 
queed
.
dwd
 = 
dwd11
;

66 
	`x_tf
("Numb oIO Submissi QueueRequeed (NSQR, zo-bad): 0x%04X\r\n", 
queed
.
NSQR
);

67 
	`x_tf
("Numb oIO Comi QueueRequeed (NCQR, zo-bad): 0x%04X\r\n", 
queed
.
NCQR
);

70 if(
queed
.
NSQR
 >
MAX_NUM_OF_IO_SQ
)

71 
g_nvmeTask
.
numOfIOSubmissiQueuesAod
 = 
MAX_NUM_OF_IO_SQ
;

73 
g_nvmeTask
.
numOfIOSubmissiQueuesAod
 = 
queed
.
NSQR
 + 1;

75 
lod
.
NSQA
 = 
g_nvmeTask
.
numOfIOSubmissiQueuesAod
 - 1;

79 if(
queed
.
NCQR
 >
MAX_NUM_OF_IO_CQ
)

80 
g_nvmeTask
.
numOfIOComiQueuesAod
 = 
MAX_NUM_OF_IO_CQ
;

82 
g_nvmeTask
.
numOfIOComiQueuesAod
 = 
queed
.
NCQR
 + 1;

84 
lod
.
NCQA
 = 
g_nvmeTask
.
numOfIOComiQueuesAod
 - 1;

86 
	`x_tf
("Numb oIO Submissi QueueAod (NSQA, zo-bad): 0x%04X\r\n", 
lod
.
NSQA
);

87 
	`x_tf
("Numb oIO Comi QueueAod (NCQA, zo-bad): 0x%04X\r\n", 
lod
.
NCQA
);

89  
lod
.
dwd
;

90 
	}
}

92 
	$hd_t_us
(
NVME_ADMIN_COMMAND
 *
nvmeAdmCmd
, 
NVME_COMPLETION
 *
nvmeCPL
)

94 
ADMIN_SET_FEATURES_DW10
 
us
;

96 
us
.
dwd
 = 
nvmeAdmCmd
->
dwd10
;

98 
us
.
FID
)

100 
NUMBER_OF_QUEUES
:

102 
nvmeCPL
->
dwd
[0] = 0x0;

103 
nvmeCPL
->
ecific
 = 
	`g_num_of_queue
(
nvmeAdmCmd
->
dwd11
);

106 
INTERRUPT_COALESCING
:

108 
nvmeCPL
->
dwd
[0] = 0x0;

109 
nvmeCPL
->
ecific
 = 0x0;

112 
ARBITRATION
:

114 
nvmeCPL
->
dwd
[0] = 0x0;

115 
nvmeCPL
->
ecific
 = 0x0;

118 
ASYNCHRONOUS_EVENT_CONFIGURATION
:

120 
nvmeCPL
->
dwd
[0] = 0x0;

121 
nvmeCPL
->
ecific
 = 0x0;

124 
VOLATILE_WRITE_CACHE
:

126 
	`x_tf
("S VWC: %X\r\n", 
nvmeAdmCmd
->
dwd11
);

127 
g_nvmeTask
.
cheEn
 = (
nvmeAdmCmd
->
dwd11
 & 0x1);

128 
nvmeCPL
->
dwd
[0] = 0x0;

129 
nvmeCPL
->
ecific
 = 0x0;

132 
POWER_MANAGEMENT
:

134 
nvmeCPL
->
dwd
[0] = 0x0;

135 
nvmeCPL
->
ecific
 = 0x0;

138 
Timeamp
:

140 
nvmeCPL
->
dwd
[0] = 0x0;

141 
nvmeCPL
->
ecific
 = 0x0;

146 
	`x_tf
("N Su܈FID (S): %X\r\n", 
us
.
FID
);

147 
	`ASSERT
(0);

151 
	`x_tf
("S Ftu FID:%X\r\n", 
us
.
FID
);

152 
	}
}

154 
	$hd_g_us
(
NVME_ADMIN_COMMAND
 *
nvmeAdmCmd
, 
NVME_COMPLETION
 *
nvmeCPL
)

156 
ADMIN_GET_FEATURES_DW10
 
us
;

157 
NVME_COMPLETION
 
l
;

159 
us
.
dwd
 = 
nvmeAdmCmd
->
dwd10
;

161 
us
.
FID
)

163 
LBA_RANGE_TYPE
:

165 
	`ASSERT
(
nvmeAdmCmd
->
NSID
 == 1);

167 
l
.
dwd
[0] = 0x0;

168 
l
.
usFld
.
SC
 = 
SC_INVALID_FIELD_IN_COMMAND
;

169 
nvmeCPL
->
dwd
[0] = 
l
.dword[0];

170 
nvmeCPL
->
ecific
 = 0x0;

173 
TEMPERATURE_THRESHOLD
:

175 
nvmeCPL
->
dwd
[0] = 0x0;

176 
nvmeCPL
->
ecific
 = 
nvmeAdmCmd
->
dwd11
;

179 
VOLATILE_WRITE_CACHE
:

182 
	`x_tf
("G VWC: %X\r\n", 
g_nvmeTask
.
cheEn
);

183 
nvmeCPL
->
dwd
[0] = 0x0;

184 
nvmeCPL
->
ecific
 = 
g_nvmeTask
.
cheEn
;

187 
POWER_MANAGEMENT
:

189 
nvmeCPL
->
dwd
[0] = 0x0;

190 
nvmeCPL
->
ecific
 = 0x0;

193 
Pow_S_Tnsi
:

195 
nvmeCPL
->
dwd
[0] = 0x0;

196 
nvmeCPL
->
ecific
 = 0x0;

201 
nvmeCPL
->
dwd
[0] = 0x0;

202 
nvmeCPL
->
ecific
 = 0x0;

207 
	`x_tf
("N Su܈FID (G): %X\r\n", 
us
.
FID
);

208 
	`ASSERT
(0);

212 
	`x_tf
("G Ftu FID:%X\r\n", 
us
.
FID
);

213 
	}
}

215 
	$hd__io_sq
(
NVME_ADMIN_COMMAND
 *
nvmeAdmCmd
, 
NVME_COMPLETION
 *
nvmeCPL
)

217 
ADMIN_CREATE_IO_SQ_DW10
 
sqInfo10
;

218 
ADMIN_CREATE_IO_SQ_DW11
 
sqInfo11
;

219 
NVME_IO_SQ_STATUS
 *
ioSqStus
;

220 
ioSqIdx
;

222 
sqInfo10
.
dwd
 = 
nvmeAdmCmd
->
dwd10
;

223 
sqInfo11
.
dwd
 = 
nvmeAdmCmd
->
dwd11
;

225 
	`x_tf
(" sq: 0x%08X, 0x%08X\r\n", 
sqInfo11
.
dwd
, 
sqInfo10
.dword);

230 
	`ASSERT
((
nvmeAdmCmd
->
PRP1
[0] & 0x3) == 0 &&vmeAdminCmd->PRP1[1] < 0x10000);

231 
	`ASSERT
(0 < 
sqInfo10
.
QID
 && sqInfo10.QID <8 && sqInfo10.
QSIZE
 < 0x100 && 0 < 
sqInfo11
.
CQID
 && sqInfo11.CQID <= 8);

233 
ioSqIdx
 = 
sqInfo10
.
QID
 - 1;

234 
ioSqStus
 = 
g_nvmeTask
.
ioSqInfo
 + 
ioSqIdx
;

236 
ioSqStus
->
vid
 = 1;

237 
ioSqStus
->
qSz
 = 
sqInfo10
.
QSIZE
;

238 
ioSqStus
->
cqVe
 = 
sqInfo11
.
CQID
;

239 
ioSqStus
->
pcBaAddrL
 = 
nvmeAdmCmd
->
PRP1
[0];

240 
ioSqStus
->
pcBaAddrH
 = 
nvmeAdmCmd
->
PRP1
[1];

242 
	`t_io_sq
(
ioSqIdx
, 
ioSqStus
->
vid
, ioSqStus->
cqVe
, ioSqStus->
qSz
, ioSqStus->
pcBaAddrL
, ioSqStus->
pcBaAddrH
);

244 
nvmeCPL
->
dwd
[0] = 0;

245 
nvmeCPL
->
ecific
 = 0x0;

247 
	}
}

249 
	$hd_de_io_sq
(
NVME_ADMIN_COMMAND
 *
nvmeAdmCmd
, 
NVME_COMPLETION
 *
nvmeCPL
)

251 
ADMIN_DELETE_IO_SQ_DW10
 
sqInfo10
;

252 
NVME_IO_SQ_STATUS
 *
ioSqStus
;

253 
ioSqIdx
;

255 
sqInfo10
.
dwd
 = 
nvmeAdmCmd
->
dwd10
;

257 
	`x_tf
("dsq: 0x%08X\r\n", 
sqInfo10
.
dwd
);

259 
ioSqIdx
 = ()
sqInfo10
.
QID
 - 1;

260 
ioSqStus
 = 
g_nvmeTask
.
ioSqInfo
 + 
ioSqIdx
;

262 
ioSqStus
->
vid
 = 0;

263 
ioSqStus
->
cqVe
 = 0;

264 
ioSqStus
->
qSz
 = 0;

265 
ioSqStus
->
pcBaAddrL
 = 0;

266 
ioSqStus
->
pcBaAddrH
 = 0;

268 
	`t_io_sq
(
ioSqIdx
, 0, 0, 0, 0, 0);

270 
nvmeCPL
->
dwd
[0] = 0;

271 
nvmeCPL
->
ecific
 = 0x0;

272 
	}
}

275 
	$hd__io_cq
(
NVME_ADMIN_COMMAND
 *
nvmeAdmCmd
, 
NVME_COMPLETION
 *
nvmeCPL
)

277 
ADMIN_CREATE_IO_CQ_DW10
 
cqInfo10
;

278 
ADMIN_CREATE_IO_CQ_DW11
 
cqInfo11
;

279 
NVME_IO_CQ_STATUS
 *
ioCqStus
;

280 
ioCqIdx
;

282 
cqInfo10
.
dwd
 = 
nvmeAdmCmd
->
dwd10
;

283 
cqInfo11
.
dwd
 = 
nvmeAdmCmd
->
dwd11
;

285 
	`x_tf
(" cq: 0x%08X, 0x%08X\r\n", 
cqInfo11
.
dwd
, 
cqInfo10
.dword);

287 
	`ASSERT
(((
nvmeAdmCmd
->
PRP1
[0] & 0x3) == 0) && (nvmeAdminCmd->PRP1[1] < 0x10000));

288 
	`ASSERT
(
cqInfo11
.
IV
 < 8 && 
cqInfo10
.
QSIZE
 < 0x100 && 0 < cqInfo10.
QID
 && cqInfo10.QID <= 8);

290 
ioCqIdx
 = 
cqInfo10
.
QID
 - 1;

291 
ioCqStus
 = 
g_nvmeTask
.
ioCqInfo
 + 
ioCqIdx
;

293 
ioCqStus
->
vid
 = 1;

294 
ioCqStus
->
qSz
 = 
cqInfo10
.
QSIZE
;

295 
ioCqStus
->
qEn
 = 
cqInfo11
.
IEN
;

296 
ioCqStus
->
qVe
 = 
cqInfo11
.
IV
;

297 
ioCqStus
->
pcBaAddrL
 = 
nvmeAdmCmd
->
PRP1
[0];

298 
ioCqStus
->
pcBaAddrH
 = 
nvmeAdmCmd
->
PRP1
[1];

300 
	`t_io_cq
(
ioCqIdx
, 
ioCqStus
->
vid
, ioCqStus->
qEn
, ioCqStus->
qVe
, ioCqStus->
qSz
, ioCqStus->
pcBaAddrL
, ioCqStus->
pcBaAddrH
);

302 
nvmeCPL
->
dwd
[0] = 0;

303 
nvmeCPL
->
ecific
 = 0x0;

304 
	}
}

306 
	$hd_de_io_cq
(
NVME_ADMIN_COMMAND
 *
nvmeAdmCmd
, 
NVME_COMPLETION
 *
nvmeCPL
)

308 
ADMIN_DELETE_IO_CQ_DW10
 
cqInfo10
;

309 
NVME_IO_CQ_STATUS
 *
ioCqStus
;

310 
ioCqIdx
;

312 
cqInfo10
.
dwd
 = 
nvmeAdmCmd
->
dwd10
;

314 
	`x_tf
("dcq: 0x%08X\r\n", 
cqInfo10
.
dwd
);

316 
ioCqIdx
 = ()
cqInfo10
.
QID
 - 1;

317 
ioCqStus
 = 
g_nvmeTask
.
ioCqInfo
 + 
ioCqIdx
;

319 
ioCqStus
->
vid
 = 0;

320 
ioCqStus
->
qVe
 = 0;

321 
ioCqStus
->
qSz
 = 0;

322 
ioCqStus
->
pcBaAddrL
 = 0;

323 
ioCqStus
->
pcBaAddrH
 = 0;

325 
	`t_io_cq
(
ioCqIdx
, 0, 0, 0, 0, 0, 0);

327 
nvmeCPL
->
dwd
[0] = 0;

328 
nvmeCPL
->
ecific
 = 0x0;

329 
	}
}

331 
	$hd_idtify
(
NVME_ADMIN_COMMAND
 *
nvmeAdmCmd
, 
NVME_COMPLETION
 *
nvmeCPL
)

333 
ADMIN_IDENTIFY_COMMAND_DW10
 
idtifyInfo
;

334 
pIdtifyDa
 = 
ADMIN_CMD_DRAM_DATA_BUFFER
;

335 
p
[2];

336 
pL
;

338 
idtifyInfo
.
dwd
 = 
nvmeAdmCmd
->
dwd10
;

340 if(
idtifyInfo
.
CNS
 == 1)

342 if((
nvmeAdmCmd
->
PRP1
[0] & 0x3!0 || (nvmeAdmCmd->
PRP2
[0] & 0x3) != 0)

343 
	`x_tf
("CI: %X, %X, %X, %X\r\n", 
nvmeAdmCmd
->
PRP1
[1],vmeAdmCmd->PRP1[0],vmeAdmCmd->
PRP2
[1],vmeAdminCmd->PRP2[0]);

345 
	`ASSERT
((
nvmeAdmCmd
->
PRP1
[0] & 0x3=0 && (nvmeAdmCmd->
PRP2
[0] & 0x3) == 0);

346 
	`idtify_cڌr
(
pIdtifyDa
);

348 if(
idtifyInfo
.
CNS
 == 0)

350 if((
nvmeAdmCmd
->
PRP1
[0] & 0x3!0 || (nvmeAdmCmd->
PRP2
[0] & 0x3) != 0)

351 
	`x_tf
("NI: %X, %X, %X, %X\r\n", 
nvmeAdmCmd
->
PRP1
[1],vmeAdmCmd->PRP1[0],vmeAdmCmd->
PRP2
[1],vmeAdminCmd->PRP2[0]);

353 
	`ASSERT
((
nvmeAdmCmd
->
PRP1
[0] & 0x3=0 && (nvmeAdmCmd->
PRP2
[0] & 0x3) == 0);

354 
	`idtify_mea
(
pIdtifyDa
);

357 
	`ASSERT
(0);

359 
p
[0] = 
nvmeAdmCmd
->
PRP1
[0];

360 
p
[1] = 
nvmeAdmCmd
->
PRP1
[1];

362 
pL
 = 0x1000 - (
p
[0] & 0xFFF);

364 
	`t_de_tx_dma
(
pIdtifyDa
, 
p
[1],[0], 
pL
);

365 if(
pL
 != 0x1000)

367 
pIdtifyDa
 =IdtifyD+ 
pL
;

368 
pL
 = 0x1000 -rpLen;

369 
p
[0] = 
nvmeAdmCmd
->
PRP2
[0];

370 
p
[1] = 
nvmeAdmCmd
->
PRP2
[1];

374 
	`t_de_tx_dma
(
pIdtifyDa
, 
p
[1],[0], 
pL
);

377 
	`check_de_tx_dma_de
();

378 
nvmeCPL
->
dwd
[0] = 0;

379 
nvmeCPL
->
ecific
 = 0x0;

380 
	}
}

382 
	$hd_g_log_ge
(
NVME_ADMIN_COMMAND
 *
nvmeAdmCmd
, 
NVME_COMPLETION
 *
nvmeCPL
)

409 
nvmeCPL
->
dwd
[0] = 0;

410 
nvmeCPL
->
ecific
 = 0x9;

411 
	}
}

413 
	$hd_nvme_adm_cmd
(
NVME_COMMAND
 *
nvmeCmd
)

414 { 
NVME_ADMIN_COMMAND
 *
nvmeAdmCmd
;

415 
NVME_COMPLETION
 
nvmeCPL
;

416 
c
;

417 
edC
;

418 
edSlR
;

420 
nvmeAdmCmd
 = (
NVME_ADMIN_COMMAND
*)
nvmeCmd
->
cmdDwd
;

421 
c
 = ()
nvmeAdmCmd
->
OPC
;

424 
edC
 = 1;

425 
edSlR
 = 0;

441 
c
)

443 
ADMIN_SET_FEATURES
:

445 
	`hd_t_us
(
nvmeAdmCmd
, &
nvmeCPL
);

448 
ADMIN_CREATE_IO_CQ
:

450 
	`hd__io_cq
(
nvmeAdmCmd
, &
nvmeCPL
);

453 
ADMIN_CREATE_IO_SQ
:

455 
	`hd__io_sq
(
nvmeAdmCmd
, &
nvmeCPL
);

458 
ADMIN_IDENTIFY
:

460 
	`hd_idtify
(
nvmeAdmCmd
, &
nvmeCPL
);

463 
ADMIN_GET_FEATURES
:

465 
	`hd_g_us
(
nvmeAdmCmd
, &
nvmeCPL
);

468 
ADMIN_DELETE_IO_CQ
:

470 
	`hd_de_io_cq
(
nvmeAdmCmd
, &
nvmeCPL
);

473 
ADMIN_DELETE_IO_SQ
:

475 
	`hd_de_io_sq
(
nvmeAdmCmd
, &
nvmeCPL
);

478 
ADMIN_ASYNCHRONOUS_EVENT_REQUEST
:

480 
edC
 = 0;

481 
edSlR
 = 1;

482 
nvmeCPL
.
dwd
[0] = 0;

483 
nvmeCPL
.
ecific
 = 0x0;

486 
ADMIN_GET_LOG_PAGE
:

488 
	`hd_g_log_ge
(
nvmeAdmCmd
, &
nvmeCPL
);

491 
ADMIN_SECURITY_RECEIVE
:

493 
edC
 = 0;

494 
edSlR
 = 0;

495 
nvmeCPL
.
dwd
[0] = 0;

496 
nvmeCPL
.
ecific
 = 0x0;

499 
ADMIN_DOORBELL_BUFFER_CONFIG
:

501 
edC
 = 0;

502 
edSlR
 = 0;

503 
nvmeCPL
.
dwd
[0] = 0;

504 
nvmeCPL
.
ecific
 = 0x0;

509 
	`x_tf
("N Su܈Adm Commd OPC: %X\r\n", 
c
);

510 
	`ASSERT
(0);

515 if(
edC
 == 1)

516 
	`t_auto_nvme_l
(
nvmeCmd
->
cmdSlTag
, 
nvmeCPL
.
ecific
,vmeCPL.
usFldWd
);

517 if(
edSlR
 == 1)

518 
	`t_nvme__a
(
nvmeCmd
->
cmdSlTag
);

520 
	`t_nvme_l
(
nvmeCmd
->
qID
, 
nvmeAdmCmd
->
CID
, 
nvmeCPL
.
ecific
,vmeCPL.
usFldWd
);

522 
	`x_tf
("DڐAdm Commd OPC: %X\r\n", 
c
);

524 
	}
}

	@nvme/nvme_admin_cmd.h

47 #ide
__NVME_ADMIN_CMD_H_


48 
	#__NVME_ADMIN_CMD_H_


	)

51 
g_num_of_queue
(
dwd11
);

53 
hd_t_us
(
NVME_ADMIN_COMMAND
 *
nvmeAdmCmd
, 
NVME_COMPLETION
 *
nvmeCPL
);

55 
hd_g_us
(
NVME_ADMIN_COMMAND
 *
nvmeAdmCmd
, 
NVME_COMPLETION
 *
nvmeCPL
);

57 
hd__io_cq
(
NVME_ADMIN_COMMAND
 *
nvmeAdmCmd
, 
NVME_COMPLETION
 *
nvmeCPL
);

59 
hd_de_io_cq
(
NVME_ADMIN_COMMAND
 *
nvmeAdmCmd
, 
NVME_COMPLETION
 *
nvmeCPL
);

61 
hd__io_sq
(
NVME_ADMIN_COMMAND
 *
nvmeAdmCmd
, 
NVME_COMPLETION
 *
nvmeCPL
);

63 
hd_de_io_sq
(
NVME_ADMIN_COMMAND
 *
nvmeAdmCmd
, 
NVME_COMPLETION
 *
nvmeCPL
);

65 
hd_idtify
(
NVME_ADMIN_COMMAND
 *
nvmeAdmCmd
, 
NVME_COMPLETION
 *
nvmeCPL
);

67 
hd_g_log_ge
(
NVME_ADMIN_COMMAND
 *
nvmeAdmCmd
, 
NVME_COMPLETION
 *
nvmeCPL
);

69 
hd_nvme_adm_cmd
(
NVME_COMMAND
 *
nvmeCmd
);

	@nvme/nvme_identify.c

52 
	~"x_tf.h
"

53 
	~"debug.h
"

54 
	~"rg.h
"

56 
	~"nvme.h
"

57 
	~"nvme_idtify.h
"

58 
	~"../l_cfig.h
"

60 
	$idtify_cڌr
(
pBufr
)

62 
ADMIN_IDENTIFY_CONTROLLER
 *
idtifyCNTL
;

63 
ADMIN_IDENTIFY_POWER_STATE_DESCRIPTOR
 *
powSDesc
;

65 
idtifyCNTL
 = (
ADMIN_IDENTIFY_CONTROLLER
*)
pBufr
;

67 
	`memt
(
idtifyCNTL
, 0, (
ADMIN_IDENTIFY_CONTROLLER
));

69 
idtifyCNTL
->
VID
 = 
PCI_VENDOR_ID
;

70 
idtifyCNTL
->
SSVID
 = 
PCI_SUBSYSTEM_VENDOR_ID
;

72 
	`memt
(
idtifyCNTL
->
SN
, 0x20, 20);

73 
	`memy
(
idtifyCNTL
->
SN
, 
SERIAL_NUMBER
, (SERIAL_NUMBER));

75 
	`memt
(
idtifyCNTL
->
MN
, 0x20, 40);

76 
	`memy
(
idtifyCNTL
->
MN
, 
MODEL_NUMBER
, (MODEL_NUMBER));

78 
	`memt
(
idtifyCNTL
->
FR
, 0x20, 8);

79 
	`memy
(
idtifyCNTL
->
FR
, 
FIRMWARE_REVISION
, (FIRMWARE_REVISION));

82 
idtifyCNTL
->
RAB
 = 0x0;

83 
idtifyCNTL
->
IEEE
[0] = 0xE4;

84 
idtifyCNTL
->
IEEE
[1] = 0xD2;

85 
idtifyCNTL
->
IEEE
[2] = 0x5C;

86 
idtifyCNTL
->
CMIC
 = 0x0;

87 
idtifyCNTL
->
MDTS
 = 0x8;

88 
idtifyCNTL
->
CNTLID
 = 0x9;

90 
idtifyCNTL
->
OACS
.
sutsSecurySdSecuryReive
 = 0x0;

91 
idtifyCNTL
->
OACS
.
sutsFmNVM
 = 0x0;

92 
idtifyCNTL
->
OACS
.
sutsFmweAiveFmweDowd
 = 0x0;

94 
idtifyCNTL
->
ACL
 = 0x3;

95 
idtifyCNTL
->
AERL
 = 0x3;

97 
idtifyCNTL
->
FRMW
.
fFmweSlRdOy
 = 0x1;

98 
idtifyCNTL
->
FRMW
.
su܋dNumbOfFmweSls
 = 0x1;

100 
idtifyCNTL
->
LPA
.
sutsSMARTHhInfmiLogPage
 = 0x0;

102 
idtifyCNTL
->
ELPE
 = 0x8;

103 
idtifyCNTL
->
NPSS
 = 0x0;

104 
idtifyCNTL
->
AVSCC
 = 0x0;

105 
idtifyCNTL
->
APSTA
 = 0x0;

107 
idtifyCNTL
->
SQES
.
quedSubmissiQueueErySize
 = 0x6;

108 
idtifyCNTL
->
SQES
.
maximumSubmissiQueueErySize
 = 0x6;

110 
idtifyCNTL
->
CQES
.
quedComiQueueErySize
 = 0x4;

111 
idtifyCNTL
->
CQES
.
maximumComiQueueErySize
 = 0x4;

113 
idtifyCNTL
->
NN
 = 0x1;

115 
idtifyCNTL
->
ONCS
.
sutsCom
 = 0x0;

116 
idtifyCNTL
->
ONCS
.
sutsWreUncܻab
 = 0x0;

119 
idtifyCNTL
->
ONCS
.
sutsDaSMagemt
 = 0x0;

121 
idtifyCNTL
->
FUSES
.
sutsComWre
 = 0x0;

123 
idtifyCNTL
->
FNA
.
fmAlsToANameas
 = 0x0;

124 
idtifyCNTL
->
FNA
.
cuEAlsToANameas
 = 0x0;

125 
idtifyCNTL
->
FNA
.
sutsCryogphicE
 = 0x0;

127 
idtifyCNTL
->
VWC
.
e
 = 0x1;

129 
idtifyCNTL
->
AWUN
 = 0x0;

130 
idtifyCNTL
->
AWUPF
 = 0x0;

131 
idtifyCNTL
->
NVSCC
 = 0x0;

132 
idtifyCNTL
->
ACWU
 = 0x0;

134 
idtifyCNTL
->
SGLS
.
sutsSGL
 = 0x0;

135 
idtifyCNTL
->
SGLS
.
sutsSGLBBuckDest
 = 0x0;

137 
powSDesc
 = &
idtifyCNTL
->
PSDx
[0];

139 
powSDesc
->
MP
 = 0x09C4;

140 
powSDesc
->
MPS
 = 0x0;

141 
powSDesc
->
NOPS
 = 0x0;

142 
powSDesc
->
ENLAT
 = 0x0;

143 
powSDesc
->
EXLAT
 = 0x0;

144 
powSDesc
->
RRT
 = 0x0;

145 
powSDesc
->
RRL
 = 0x0;

146 
powSDesc
->
RWT
 = 0x0;

147 
powSDesc
->
RWL
 = 0x0;

148 
	}
}

150 
	$idtify_mea
(
pBufr
)

152 
ADMIN_IDENTIFY_NAMESPACE
 *
idtifyNS
;

153 
ADMIN_IDENTIFY_FORMAT_DATA
 *
fmDa
;

154 
idtifyNS
 = (
ADMIN_IDENTIFY_NAMESPACE
 *)
pBufr
;

156 
	`memt
(
idtifyNS
, 0, (
ADMIN_IDENTIFY_NAMESPACE
));

158 
idtifyNS
->
NSZE
[0] = 
ageCacy_L
;

159 
idtifyNS
->
NSZE
[1] = 
STORAGE_CAPACITY_H
;

160 
idtifyNS
->
NCAP
[0] = 
ageCacy_L
;

161 
idtifyNS
->
NCAP
[1] = 
STORAGE_CAPACITY_H
;

162 
idtifyNS
->
NUSE
[0] = 
ageCacy_L
;

163 
idtifyNS
->
NUSE
[1] = 
STORAGE_CAPACITY_H
;

165 
idtifyNS
->
NSFEAT
.
sutsThProvisiښg
 = 0x0;

167 
idtifyNS
->
NSFEAT
.
sutsDod
 = 0x0;

171 
idtifyNS
->
NLBAF
 = 0x0;

173 
idtifyNS
->
FLBAS
.
su܋dCombi
 = 0x0;

174 
idtifyNS
->
FLBAS
.
sutsMadaAtEndOfLBA
 = 0x0;

176 
idtifyNS
->
MC
.
sutsMadaAsPtOfLBA
 = 0x0;

177 
idtifyNS
->
MC
.
sutsMadaAsSe
 = 0x0;

180 
idtifyNS
->
DPC
.
sutsPreiTy1
 = 0x0;

181 
idtifyNS
->
DPC
.
sutsPreiTy2
 = 0x0;

182 
idtifyNS
->
DPC
.
sutsPreiTy3
 = 0x0;

183 
idtifyNS
->
DPC
.
sutsPreiF8
 = 0x0;

184 
idtifyNS
->
DPC
.
sutsPreiLa8
 = 0x0;

186 
idtifyNS
->
DPS
.
eiEbd
 = 0x0;

187 
idtifyNS
->
DPS
.
eiInF8
 = 0x0;

189 
idtifyNS
->
NMIC
.
sutsMuɝhIOShg
 = 0x0;

191 
idtifyNS
->
RESCAP
.
sutsPsiThroughPowLoss
 = 0x0;

192 
idtifyNS
->
RESCAP
.
sutsWreExusiveRervi
 = 0x0;

193 
idtifyNS
->
RESCAP
.
sutsWreExusiveRegis
 = 0x0;

194 
idtifyNS
->
RESCAP
.
sutsExusiveAcssRegis
 = 0x0;

195 
idtifyNS
->
RESCAP
.
sutsWreExusiveARegis
 = 0x0;

196 
idtifyNS
->
RESCAP
.
sutsExusiveAcssARegis
 = 0x0;

198 
fmDa
 = &
idtifyNS
->
LBAFx
[0];

200 
fmDa
->
MS
 = 0x0;

201 
fmDa
->
LBADS
 = 0xC;

202 
fmDa
->
RP
 = 0x2;

203 
	}
}

	@nvme/nvme_identify.h

49 #ide
__NVME_IDENTIFY_H_


50 
	#__NVME_IDENTIFY_H_


	)

52 
	#PCI_VENDOR_ID
 0x1EDC

	)

53 
	#PCI_SUBSYSTEM_VENDOR_ID
 0x1EDC

	)

54 
	#SERIAL_NUMBER
 "SSDD515T"

	)

55 
	#MODEL_NUMBER
 "Cosmos+ OnSSD"

	)

56 
	#FIRMWARE_REVISION
 "TYPE0005"

	)

58 
idtify_cڌr
(
pBufr
);

60 
idtify_mea
(
pBufr
);

	@nvme/nvme_io_cmd.c

53 
	~"x_tf.h
"

54 
	~"debug.h
"

55 
	~"io_acss.h
"

57 
	~"nvme.h
"

58 
	~"ho_d.h
"

59 
	~"nvme_io_cmd.h
"

61 
	~"../l_cfig.h
"

62 
	~"../que_sfm.h
"

63 
	~"../she/she.h
"

65 
	$hd_nvme_io_ad
(
cmdSlTag
, 
NVME_IO_COMMAND
 *
nvmeIOCmd
, 
qID
)

67 
IO_READ_COMMAND_DW12
 
adInfo12
;

70 
tLba
[2];

71 
b
, 
fua
, 
cID
;

73 
adInfo12
.
dwd
 = 
nvmeIOCmd
->dword[12];

77 
tLba
[0] = 
nvmeIOCmd
->
dwd
[10];

78 
tLba
[1] = 
nvmeIOCmd
->
dwd
[11];

79 
b
 = 
adInfo12
.
NLB
;

80 
fua
 = 
adInfo12
.
FUA
;

81 
cID
 = 
nvmeIOCmd
->
CID
;

83 
	`ASSERT
(
tLba
[0] < 
ageCacy_L
 && (tLba[1] < 
STORAGE_CAPACITY_H
 || startLba[1] == 0));

85 
	`ASSERT
((
nvmeIOCmd
->
PRP1
[0] & 0x3=0 && (nvmeIOCmd->
PRP2
[0] & 0x3) == 0);

86 
	`ASSERT
(
nvmeIOCmd
->
PRP1
[1] < 0x10000 &&vmeIOCmd->
PRP2
[1] < 0x10000);

87 #i(
TEST_MODE_FUA
 == 1)

88 
fua
 = 
REQ_OPT_FORCE_UNIT_ACCESS_ON
;

90 #i(
TEST_MODE_FUA
 == 2)

91 
fua
 = 
REQ_OPT_FORCE_UNIT_ACCESS_OFF
;

94 
fua
 = 
REQ_OPT_FORCE_UNIT_ACCESS_OFF
;

95 
	`ReqTnsNvmeToSli
(
cmdSlTag
, 
qID
, 
cID
, 
tLba
[0], 
b
, 
IO_NVM_READ
, 
fua
);

96 
	}
}

99 
	$hd_nvme_io_wre
(
cmdSlTag
, 
NVME_IO_COMMAND
 *
nvmeIOCmd
, 
qID
)

101 
IO_READ_COMMAND_DW12
 
wreInfo12
;

104 
tLba
[2];

105 
b
, 
fua
, 
cID
;

107 
wreInfo12
.
dwd
 = 
nvmeIOCmd
->dword[12];

114 
tLba
[0] = 
nvmeIOCmd
->
dwd
[10];

115 
tLba
[1] = 
nvmeIOCmd
->
dwd
[11];

116 
b
 = 
wreInfo12
.
NLB
;

117 
fua
 = 
wreInfo12
.
FUA
;

118 
cID
 = 
nvmeIOCmd
->
CID
;

120 
	`ASSERT
(
tLba
[0] < 
ageCacy_L
 && (tLba[1] < 
STORAGE_CAPACITY_H
 || startLba[1] == 0));

122 
	`ASSERT
((
nvmeIOCmd
->
PRP1
[0] & 0xF=0 && (nvmeIOCmd->
PRP2
[0] & 0xF) == 0);

123 
	`ASSERT
(
nvmeIOCmd
->
PRP1
[1] < 0x10000 &&vmeIOCmd->
PRP2
[1] < 0x10000);

125 
fua
 = 
REQ_OPT_FORCE_UNIT_ACCESS_OFF
;

126 
	`ReqTnsNvmeToSli
(
cmdSlTag
, 
qID
, 
cID
, 
tLba
[0], 
b
, 
IO_NVM_WRITE
, 
fua
);

127 
	}
}

130 
	$hlde_nvme_io_disrd
(
cmdSlTag
, 
NVME_IO_COMMAND
 *
nvmeIOCmd
, 
qID
)

132 
IO_DATASET_MANAGEMENT_COMMAND_DW10
 
dsm10
;

133 
IO_DATASET_MANAGEMENT_COMMAND_DW11
 
dsm11
;

134 

;

136 
dsm10
.
dwd
 = 
nvmeIOCmd
->dword[10];

137 
dsm11
.
dwd
 = 
nvmeIOCmd
->dword[11];

139 i(
dsm11
.
AD
 == 1) {

140 

 = 
dsm10
.
NR
 + 1;

143 
diff
 = 
TEMPORARY_SPARE_DATA_BUFFER_BASE_ADDR
 % 4096;

144 
w_addr
 = 
TEMPORARY_SPARE_DATA_BUFFER_BASE_ADDR
 + (4096 - 
diff
);

146 
	`t_de_rx_dma
((
w_addr
), 
nvmeIOCmd
->
PRP1
[1],vmeIOCmd->PRP1[0], 4096);

147 
	`check_de_rx_dma_de
();

149 
n
, 
i
;

150 
tLba
[2];

151 
i
=0; i<

; i++) {

152 
DATASET_MANAGEMENT_RANGE
* 
dmr
 = (DATASET_MANAGEMENT_RANGE*(
w_addr
 + ((DATASET_MANAGEMENT_RANGE)*
i
));

153 
tLba
[0] = 
dmr
->
tgLBA
[0];

154 
n
 = 
dmr
->
ngthInLogilBlocks
;

156 
	`DisrdBlocks
(
tLba
[0], 
n
);

160 
	}
}

162 
	$hd_nvme_io_cmd
(
NVME_COMMAND
 *
nvmeCmd
)

164 
NVME_IO_COMMAND
 *
nvmeIOCmd
;

165 
NVME_COMPLETION
 
nvmeCPL
;

166 
c
;

167 
nvmeIOCmd
 = (
NVME_IO_COMMAND
*)
nvmeCmd
->
cmdDwd
;

176 
c
 = ()
nvmeIOCmd
->
OPC
;

178 
c
)

180 
IO_NVM_FLUSH
:

183 
nvmeCPL
.
dwd
[0] = 0;

184 
nvmeCPL
.
ecific
 = 0x0;

185 
	`t_auto_nvme_l
(
nvmeCmd
->
cmdSlTag
, 
nvmeCPL
.
ecific
,vmeCPL.
usFldWd
);

188 
IO_NVM_WRITE
:

191 
	`hd_nvme_io_wre
(
nvmeCmd
->
cmdSlTag
, 
nvmeIOCmd
,vmeCmd->
qID
);

194 
IO_NVM_READ
:

197 
	`hd_nvme_io_ad
(
nvmeCmd
->
cmdSlTag
, 
nvmeIOCmd
,vmeCmd->
qID
);

201 
IO_NVM_DATASET_MANAGEMENT
:

203 i(
im_ag
 == 0) {

204 
nvmeCPL
.
dwd
[0] = 0;

205 
nvmeCPL
.
ecific
 = 0x0;

206 
	`t_auto_nvme_l
(
nvmeCmd
->
cmdSlTag
, 
nvmeCPL
.
ecific
,vmeCPL.
usFldWd
);

210 
	`as
(
BYTES_PER_DATA_REGION_OF_PAGE
 == 4096);

212 
	`hlde_nvme_io_disrd
(
nvmeCmd
->
cmdSlTag
, 
nvmeIOCmd
,vmeCmd->
qID
);

214 
nvmeCPL
.
dwd
[0] = 0;

215 
nvmeCPL
.
ecific
 = 0x0;

216 
nvmeCPL
.
usFld
.
SCT
 = 
SCT_GENERIC_COMMAND_STATUS
;

217 
nvmeCPL
.
usFld
.
SC
 = 
SC_SUCCESSFUL_COMPLETION
;

218 
	`t_auto_nvme_l
(
nvmeCmd
->
cmdSlTag
, 
nvmeCPL
.
ecific
,vmeCPL.
usFldWd
);

224 
IO_NVM_SHARE
:

227 
	`as
(
BYTES_PER_DATA_REGION_OF_PAGE
 == 4096);

229 
	`hd_nvme_io_she_v2
(
nvmeCmd
->
cmdSlTag
, 
nvmeIOCmd
,vmeCmd->
qID
);

231 
nvmeCPL
.
dwd
[0] = 0;

232 
nvmeCPL
.
ecific
 = 0x0;

233 
nvmeCPL
.
usFld
.
SCT
 = 
SCT_GENERIC_COMMAND_STATUS
;

234 
nvmeCPL
.
usFld
.
SC
 = 
SC_SUCCESSFUL_COMPLETION
;

235 
	`t_auto_nvme_l
(
nvmeCmd
->
cmdSlTag
, 
nvmeCPL
.
ecific
,vmeCPL.
usFldWd
);

239 
IO_NVM_PRINT_STAT
:

241 
	`x_tf
("gc: %lld, wr: %lld, hwr: %lld, "

244 
g_l_num_gc
, 
g_l_num_wre
, 
g_l_num_ho_wre
,

245 
g_l_num_a
, 
g_l_num_cy_back
,

246 
g_l_num_gh_wre
, 
g_l_num_gh_
, 
g_l_num_gh_gc
, 
g_l_num_im
);

247 
nvmeCPL
.
dwd
[0] = 0;

248 
nvmeCPL
.
ecific
 = 0x0;

249 
	`t_auto_nvme_l
(
nvmeCmd
->
cmdSlTag
, 
nvmeCPL
.
ecific
,vmeCPL.
usFldWd
);

251 
im_ag
 = 1;

256 
	`x_tf
("N Su܈IO Commd OPC: %X\r\n", 
c
);

257 
	`ASSERT
(0);

261 
	}
}

	@nvme/nvme_io_cmd.h

47 #ide
__NVME_IO_CMD_H_


48 
	#__NVME_IO_CMD_H_


	)

50 
hd_nvme_io_cmd
(
NVME_COMMAND
 *
nvmeCmd
);

51 
	#TEST_MODE_FUA
 2

	)

	@nvme/nvme_main.c

59 
	~"x_tf.h
"

60 
	~"debug.h
"

61 
	~"io_acss.h
"

63 
	~"nvme.h
"

64 
	~"ho_d.h
"

65 
	~"nvme_ma.h
"

66 
	~"nvme_adm_cmd.h
"

67 
	~"nvme_io_cmd.h
"

69 
	~"../memy_m.h
"

71 vީ
NVME_CONTEXT
 
	gg_nvmeTask
;

73 
	$nvme_ma
()

75 
exeL
;

76 
rC
 = 0;

78 
	`x_tf
("!!! Wait until FTLeset complete !!! \r\n");

80 
	`InFTL
();

82 
	`x_tf
("\r\nFTLeset complete!!! \r\n");

83 
	`x_tf
("Turn onhe host PC \r\n");

87 
exeL
 = 1;

90 if(
g_nvmeTask
.
us
 =
NVME_TASK_WAIT_CC_EN
)

92 
ccEn
;

93 
ccEn
 = 
	`check_nvme_cc_
();

94 if(
ccEn
 == 1)

96 
	`t_nvme_adm_queue
(1, 1, 1);

97 
	`t_nvme_cs_rdy
(1);

98 
g_nvmeTask
.
us
 = 
NVME_TASK_RUNNING
;

99 
	`x_tf
("\r\nNVMeeady!!!\r\n");

102 if(
g_nvmeTask
.
us
 =
NVME_TASK_RUNNING
)

104 
NVME_COMMAND
 
nvmeCmd
;

105 
cmdVid
;

106 
cmdVid
 = 
	`g_nvme_cmd
(&
nvmeCmd
.
qID
, &nvmeCmd.
cmdSlTag
, &nvmeCmd.
cmdSeqNum
,vmeCmd.
cmdDwd
);

107 if(
cmdVid
 == 1)

108 { 
rC
 = 0;

109 if(
nvmeCmd
.
qID
 == 0)

111 
	`hd_nvme_adm_cmd
(&
nvmeCmd
);

115 
	`hd_nvme_io_cmd
(&
nvmeCmd
);

116 
	`ReqTnsSliToLowLev
();

117 
exeL
=0;

121 if(
g_nvmeTask
.
us
 =
NVME_TASK_SHUTDOWN
)

123 
NVME_STATUS_REG
 
nvmeReg
;

124 
nvmeReg
.
dwd
 = 
	`IO_READ32
(
NVME_STATUS_REG_ADDR
);

125 if(
nvmeReg
.
ccShn
 != 0)

127 
qID
;

128 
	`t_nvme_cs_sh
(1);

130 
qID
 = 0; qID < 8; qID++)

132 
	`t_io_cq
(
qID
, 0, 0, 0, 0, 0, 0);

133 
	`t_io_sq
(
qID
, 0, 0, 0, 0, 0);

136 
	`t_nvme_adm_queue
(0, 0, 0);

137 
g_nvmeTask
.
cheEn
 = 0;

138 
	`t_nvme_cs_sh
(2);

139 
g_nvmeTask
.
us
 = 
NVME_TASK_WAIT_RESET
;

142 
	`UpdeBadBlockTabFGrownBadBlock
(
RESERVED_DATA_BUFFER_BASE_ADDR
);

144 
	`x_tf
("\r\nNVMe shutdown!!!\r\n");

147 if(
g_nvmeTask
.
us
 =
NVME_TASK_WAIT_RESET
)

149 
ccEn
;

150 
ccEn
 = 
	`check_nvme_cc_
();

151 if(
ccEn
 == 0)

153 
g_nvmeTask
.
cheEn
 = 0;

154 
	`t_nvme_cs_sh
(0);

155 
	`t_nvme_cs_rdy
(0);

156 
g_nvmeTask
.
us
 = 
NVME_TASK_IDLE
;

157 
	`x_tf
("\r\nNVMe disable!!!\r\n");

160 if(
g_nvmeTask
.
us
 =
NVME_TASK_RESET
)

162 
qID
;

163 
qID
 = 0; qID < 8; qID++)

165 
	`t_io_cq
(
qID
, 0, 0, 0, 0, 0, 0);

166 
	`t_io_sq
(
qID
, 0, 0, 0, 0, 0);

169 i(
rC
>= 5){

170 
	`pc_async_t
(
rC
);

171 
rC
 = 0;

172 
	`x_tf
("\r\nPcie iink disable!!!\r\n");

173 
	`x_tf
("Wait few minute oreconnecthe PCIe cable\r\n");

176 
rC
++;

178 
g_nvmeTask
.
cheEn
 = 0;

179 
	`t_nvme_adm_queue
(0, 0, 0);

180 
	`t_nvme_cs_sh
(0);

181 
	`t_nvme_cs_rdy
(0);

182 
g_nvmeTask
.
us
 = 
NVME_TASK_IDLE
;

184 
	`x_tf
("\r\nNVMeeset!!!\r\n");

187 if(
exeL
 && ((
nvmeDmaReqQ
.
hdReq
 !
REQ_SLOT_TAG_NONE
|| 
nComedNdReqC
 || 
blockedReqC
))

189 
	`CheckDeNvmeDmaReq
();

190 
	`SchedulgNdReq
();

193 
	}
}

	@nvme/nvme_main.h

48 #ide
__NVME_MAIN_H_


49 
	#__NVME_MAIN_H_


	)

51 
nvme_ma
();

	@request_allocation.c

46 
	~"x_tf.h
"

47 
	~<as.h
>

48 
	~"memy_m.h
"

50 
P_REQ_POOL
 
	gqPoP
;

51 
FREE_REQUEST_QUEUE
 
	gReqQ
;

52 
SLICE_REQUEST_QUEUE
 
	giReqQ
;

53 
BLOCKED_BY_BUFFER_DEPENDENCY_REQUEST_QUEUE
 
	gblockedByBufDReqQ
;

54 
BLOCKED_BY_ROW_ADDR_DEPENDENCY_REQUEST_QUEUE
 
	gblockedByRowAddrDReqQ
[
USER_CHANNELS
][
USER_WAYS
];

55 
NVME_DMA_REQUEST_QUEUE
 
	gnvmeDmaReqQ
;

56 
NAND_REQUEST_QUEUE
 
	gndReqQ
[
USER_CHANNELS
][
USER_WAYS
];

58 
	gnComedNdReqC
;

59 
	gblockedReqC
;

61 
	$InReqPo
()

63 
chNo
, 
wayNo
, 
qSlTag
;

65 
qPoP
 = (
P_REQ_POOL

REQ_POOL_ADDR
;

67 
ReqQ
.
hdReq
 = 0;

68 
ReqQ
.
Req
 = 
AVAILABLE_OUNTSTANDING_REQ_COUNT
 - 1;

70 
iReqQ
.
hdReq
 = 
REQ_SLOT_TAG_NONE
;

71 
iReqQ
.
Req
 = 
REQ_SLOT_TAG_NONE
;

72 
iReqQ
.
qC
 = 0;

74 
blockedByBufDReqQ
.
hdReq
 = 
REQ_SLOT_TAG_NONE
;

75 
blockedByBufDReqQ
.
Req
 = 
REQ_SLOT_TAG_NONE
;

76 
blockedByBufDReqQ
.
qC
 = 0;

78 
nvmeDmaReqQ
.
hdReq
 = 
REQ_SLOT_TAG_NONE
;

79 
nvmeDmaReqQ
.
Req
 = 
REQ_SLOT_TAG_NONE
;

80 
nvmeDmaReqQ
.
qC
 = 0;

82 
chNo
 = 0; chNo<
USER_CHANNELS
; chNo++)

83 
wayNo
 = 0; wayNo<
USER_WAYS
; wayNo++)

85 
blockedByRowAddrDReqQ
[
chNo
][
wayNo
].
hdReq
 = 
REQ_SLOT_TAG_NONE
;

86 
blockedByRowAddrDReqQ
[
chNo
][
wayNo
].
Req
 = 
REQ_SLOT_TAG_NONE
;

87 
blockedByRowAddrDReqQ
[
chNo
][
wayNo
].
qC
 = 0;

89 
ndReqQ
[
chNo
][
wayNo
].
hdReq
 = 
REQ_SLOT_TAG_NONE
;

90 
ndReqQ
[
chNo
][
wayNo
].
Req
 = 
REQ_SLOT_TAG_NONE
;

91 
ndReqQ
[
chNo
][
wayNo
].
qC
 = 0;

94 
qSlTag
 = 0;eqSlTag < 
AVAILABLE_OUNTSTANDING_REQ_COUNT
;eqSlotTag++)

96 
qPoP
->
qPo
[
qSlTag
].
qQueueTy
 = 
REQ_QUEUE_TYPE_FREE
;

97 
qPoP
->
qPo
[
qSlTag
].
evBlockgReq
 = 
REQ_SLOT_TAG_NONE
;

98 
qPoP
->
qPo
[
qSlTag
].
xtBlockgReq
 = 
REQ_SLOT_TAG_NONE
;

99 
qPoP
->
qPo
[
qSlTag
].
evReq
 =eqSlotTag - 1;

100 
qPoP
->
qPo
[
qSlTag
].
xtReq
 =eqSlotTag + 1;

103 
qPoP
->
qPo
[0].
evReq
 = 
REQ_SLOT_TAG_NONE
;

104 
qPoP
->
qPo
[
AVAILABLE_OUNTSTANDING_REQ_COUNT
 - 1].
xtReq
 = 
REQ_SLOT_TAG_NONE
;

105 
ReqQ
.
qC
 = 
AVAILABLE_OUNTSTANDING_REQ_COUNT
;

107 
nComedNdReqC
 = 0;

108 
blockedReqC
 = 0;

109 
	}
}

112 
	$PutToFeReqQ
(
qSlTag
)

114 if(
ReqQ
.
Req
 !
REQ_SLOT_TAG_NONE
)

116 
qPoP
->
qPo
[
qSlTag
].
evReq
 = 
ReqQ
.
Req
;

117 
qPoP
->
qPo
[
qSlTag
].
xtReq
 = 
REQ_SLOT_TAG_NONE
;

118 
qPoP
->
qPo
[
ReqQ
.
Req
].
xtReq
 = 
qSlTag
;

119 
ReqQ
.
Req
 = 
qSlTag
;

123 
qPoP
->
qPo
[
qSlTag
].
evReq
 = 
REQ_SLOT_TAG_NONE
;

124 
qPoP
->
qPo
[
qSlTag
].
xtReq
 = 
REQ_SLOT_TAG_NONE
;

125 
ReqQ
.
hdReq
 = 
qSlTag
;

126 
ReqQ
.
Req
 = 
qSlTag
;

129 
qPoP
->
qPo
[
qSlTag
].
qQueueTy
 = 
REQ_QUEUE_TYPE_FREE
;

130 
ReqQ
.
qC
++;

131 
	}
}

133 
	$GFromFeReqQ
()

135 
qSlTag
;

137 
qSlTag
 = 
ReqQ
.
hdReq
;

139 if(
qSlTag
 =
REQ_SLOT_TAG_NONE
)

141 
	`SyncAvaFeReq
();

142 
qSlTag
 = 
ReqQ
.
hdReq
;

145 if(
qPoP
->
qPo
[
qSlTag
].
xtReq
 !
REQ_SLOT_TAG_NONE
)

147 
ReqQ
.
hdReq
 = 
qPoP
->
qPo
[
qSlTag
].
xtReq
;

148 
qPoP
->
qPo
[qPoP->qPo[
qSlTag
].
xtReq
].
evReq
 = 
REQ_SLOT_TAG_NONE
;

152 
ReqQ
.
hdReq
 = 
REQ_SLOT_TAG_NONE
;

153 
ReqQ
.
Req
 = 
REQ_SLOT_TAG_NONE
;

156 
qPoP
->
qPo
[
qSlTag
].
qQueueTy
 = 
REQ_QUEUE_TYPE_NONE
;

157 
ReqQ
.
qC
--;

159  
qSlTag
;

160 
	}
}

162 
	$PutToSliReqQ
(
qSlTag
)

164 if(
iReqQ
.
Req
 !
REQ_SLOT_TAG_NONE
)

166 
qPoP
->
qPo
[
qSlTag
].
evReq
 = 
iReqQ
.
Req
;

167 
qPoP
->
qPo
[
qSlTag
].
xtReq
 = 
REQ_SLOT_TAG_NONE
;

168 
qPoP
->
qPo
[
iReqQ
.
Req
].
xtReq
 = 
qSlTag
;

169 
iReqQ
.
Req
 = 
qSlTag
;

173 
qPoP
->
qPo
[
qSlTag
].
evReq
 = 
REQ_SLOT_TAG_NONE
;

174 
qPoP
->
qPo
[
qSlTag
].
xtReq
 = 
REQ_SLOT_TAG_NONE
;

175 
iReqQ
.
hdReq
 = 
qSlTag
;

176 
iReqQ
.
Req
 = 
qSlTag
;

179 
qPoP
->
qPo
[
qSlTag
].
qQueueTy
 = 
REQ_QUEUE_TYPE_SLICE
;

180 
iReqQ
.
qC
++;

181 
	}
}

183 
	$GFromSliReqQ
()

185 
qSlTag
;

187 
qSlTag
 = 
iReqQ
.
hdReq
;

189 if(
qSlTag
 =
REQ_SLOT_TAG_NONE
)

190  
REQ_SLOT_TAG_FAIL
;

192 if(
qPoP
->
qPo
[
qSlTag
].
xtReq
 !
REQ_SLOT_TAG_NONE
)

194 
iReqQ
.
hdReq
 = 
qPoP
->
qPo
[
qSlTag
].
xtReq
;

195 
qPoP
->
qPo
[qPoP->qPo[
qSlTag
].
xtReq
].
evReq
 = 
REQ_SLOT_TAG_NONE
;

199 
iReqQ
.
hdReq
 = 
REQ_SLOT_TAG_NONE
;

200 
iReqQ
.
Req
 = 
REQ_SLOT_TAG_NONE
;

203 
qPoP
->
qPo
[
qSlTag
].
qQueueTy
 = 
REQ_QUEUE_TYPE_NONE
;

204 
iReqQ
.
qC
--;

206  
qSlTag
;

207 
	}
}

209 
	$PutToBlockedByBufDReqQ
(
qSlTag
)

211 if(
blockedByBufDReqQ
.
Req
 !
REQ_SLOT_TAG_NONE
)

213 
qPoP
->
qPo
[
qSlTag
].
evReq
 = 
blockedByBufDReqQ
.
Req
;

214 
qPoP
->
qPo
[
qSlTag
].
xtReq
 = 
REQ_SLOT_TAG_NONE
;

215 
qPoP
->
qPo
[
blockedByBufDReqQ
.
Req
].
xtReq
 = 
qSlTag
;

216 
blockedByBufDReqQ
.
Req
 = 
qSlTag
;

220 
qPoP
->
qPo
[
qSlTag
].
evReq
 = 
REQ_SLOT_TAG_NONE
;

221 
qPoP
->
qPo
[
qSlTag
].
xtReq
 = 
REQ_SLOT_TAG_NONE
;

222 
blockedByBufDReqQ
.
hdReq
 = 
qSlTag
;

223 
blockedByBufDReqQ
.
Req
 = 
qSlTag
;

226 
qPoP
->
qPo
[
qSlTag
].
qQueueTy
 = 
REQ_QUEUE_TYPE_BLOCKED_BY_BUF_DEP
;

227 
blockedByBufDReqQ
.
qC
++;

228 
blockedReqC
++;

229 
	}
}

230 
	$SeiveGFromBlockedByBufDReqQ
(
qSlTag
)

232 
evReq
, 
xtReq
;

234 if(
qSlTag
 =
REQ_SLOT_TAG_NONE
)

235 
	`as
(!"[WARNING] WrongeqSlotTag [WARNING]");

237 
evReq
 = 
qPoP
->
qPo
[
qSlTag
].prevReq;

238 
xtReq
 = 
qPoP
->
qPo
[
qSlTag
].nextReq;

240 if((
xtReq
 !
REQ_SLOT_TAG_NONE
&& (
evReq
 != REQ_SLOT_TAG_NONE))

242 
qPoP
->
qPo
[
evReq
].
xtReq
 =extReq;

243 
qPoP
->
qPo
[
xtReq
].
evReq
 =revReq;

245 if((
xtReq
 =
REQ_SLOT_TAG_NONE
&& (
evReq
 != REQ_SLOT_TAG_NONE))

247 
qPoP
->
qPo
[
evReq
].
xtReq
 = 
REQ_SLOT_TAG_NONE
;

248 
blockedByBufDReqQ
.
Req
 = 
evReq
;

250 if((
xtReq
 !
REQ_SLOT_TAG_NONE
&& (
evReq
 == REQ_SLOT_TAG_NONE))

252 
qPoP
->
qPo
[
xtReq
].
evReq
 = 
REQ_SLOT_TAG_NONE
;

253 
blockedByBufDReqQ
.
hdReq
 = 
xtReq
;

257 
blockedByBufDReqQ
.
hdReq
 = 
REQ_SLOT_TAG_NONE
;

258 
blockedByBufDReqQ
.
Req
 = 
REQ_SLOT_TAG_NONE
;

261 
qPoP
->
qPo
[
qSlTag
].
qQueueTy
 = 
REQ_QUEUE_TYPE_NONE
;

262 
blockedByBufDReqQ
.
qC
--;

263 
blockedReqC
--;

264 
	}
}

266 
	$PutToBlockedByRowAddrDReqQ
(
qSlTag
, 
chNo
, 
wayNo
)

268 if(
blockedByRowAddrDReqQ
[
chNo
][
wayNo
].
Req
 !
REQ_SLOT_TAG_NONE
)

270 
qPoP
->
qPo
[
qSlTag
].
evReq
 = 
blockedByRowAddrDReqQ
[
chNo
][
wayNo
].
Req
;

271 
qPoP
->
qPo
[
qSlTag
].
xtReq
 = 
REQ_SLOT_TAG_NONE
;

272 
qPoP
->
qPo
[
blockedByRowAddrDReqQ
[
chNo
][
wayNo
].
Req
].
xtReq
 = 
qSlTag
;

273 
blockedByRowAddrDReqQ
[
chNo
][
wayNo
].
Req
 = 
qSlTag
;

277 
qPoP
->
qPo
[
qSlTag
].
evReq
 = 
REQ_SLOT_TAG_NONE
;

278 
qPoP
->
qPo
[
qSlTag
].
xtReq
 = 
REQ_SLOT_TAG_NONE
;

279 
blockedByRowAddrDReqQ
[
chNo
][
wayNo
].
hdReq
 = 
qSlTag
;

280 
blockedByRowAddrDReqQ
[
chNo
][
wayNo
].
Req
 = 
qSlTag
;

283 
qPoP
->
qPo
[
qSlTag
].
qQueueTy
 = 
REQ_QUEUE_TYPE_BLOCKED_BY_ROW_ADDR_DEP
;

284 
blockedByRowAddrDReqQ
[
chNo
][
wayNo
].
qC
++;

285 
blockedReqC
++;

286 
	}
}

287 
	$SeiveGFromBlockedByRowAddrDReqQ
(
qSlTag
, 
chNo
, 
wayNo
)

289 
evReq
, 
xtReq
;

291 if(
qSlTag
 =
REQ_SLOT_TAG_NONE
)

292 
	`as
(!"[WARNING] WrongeqSlotTag [WARNING]");

294 
evReq
 = 
qPoP
->
qPo
[
qSlTag
].prevReq;

295 
xtReq
 = 
qPoP
->
qPo
[
qSlTag
].nextReq;

297 if((
xtReq
 !
REQ_SLOT_TAG_NONE
&& (
evReq
 != REQ_SLOT_TAG_NONE))

299 
qPoP
->
qPo
[
evReq
].
xtReq
 =extReq;

300 
qPoP
->
qPo
[
xtReq
].
evReq
 =revReq;

302 if((
xtReq
 =
REQ_SLOT_TAG_NONE
&& (
evReq
 != REQ_SLOT_TAG_NONE))

304 
qPoP
->
qPo
[
evReq
].
xtReq
 = 
REQ_SLOT_TAG_NONE
;

305 
blockedByRowAddrDReqQ
[
chNo
][
wayNo
].
Req
 = 
evReq
;

307 if((
xtReq
 !
REQ_SLOT_TAG_NONE
&& (
evReq
 == REQ_SLOT_TAG_NONE))

309 
qPoP
->
qPo
[
xtReq
].
evReq
 = 
REQ_SLOT_TAG_NONE
;

310 
blockedByRowAddrDReqQ
[
chNo
][
wayNo
].
hdReq
 = 
xtReq
;

314 
blockedByRowAddrDReqQ
[
chNo
][
wayNo
].
hdReq
 = 
REQ_SLOT_TAG_NONE
;

315 
blockedByRowAddrDReqQ
[
chNo
][
wayNo
].
Req
 = 
REQ_SLOT_TAG_NONE
;

318 
qPoP
->
qPo
[
qSlTag
].
qQueueTy
 = 
REQ_QUEUE_TYPE_NONE
;

319 
blockedByRowAddrDReqQ
[
chNo
][
wayNo
].
qC
--;

320 
blockedReqC
--;

321 
	}
}

323 
	$PutToNvmeDmaReqQ
(
qSlTag
)

325 if(
nvmeDmaReqQ
.
Req
 !
REQ_SLOT_TAG_NONE
)

327 
qPoP
->
qPo
[
qSlTag
].
evReq
 = 
nvmeDmaReqQ
.
Req
;

328 
qPoP
->
qPo
[
qSlTag
].
xtReq
 = 
REQ_SLOT_TAG_NONE
;

329 
qPoP
->
qPo
[
nvmeDmaReqQ
.
Req
].
xtReq
 = 
qSlTag
;

330 
nvmeDmaReqQ
.
Req
 = 
qSlTag
;

334 
qPoP
->
qPo
[
qSlTag
].
evReq
 = 
REQ_SLOT_TAG_NONE
;

335 
qPoP
->
qPo
[
qSlTag
].
xtReq
 = 
REQ_SLOT_TAG_NONE
;

336 
nvmeDmaReqQ
.
hdReq
 = 
qSlTag
;

337 
nvmeDmaReqQ
.
Req
 = 
qSlTag
;

340 
qPoP
->
qPo
[
qSlTag
].
qQueueTy
 = 
REQ_QUEUE_TYPE_NVME_DMA
;

341 
nvmeDmaReqQ
.
qC
++;

342 
	}
}

344 
	$SeiveGFromNvmeDmaReqQ
(
qSlTag
)

346 
evReq
, 
xtReq
;

348 
evReq
 = 
qPoP
->
qPo
[
qSlTag
].prevReq;

349 
xtReq
 = 
qPoP
->
qPo
[
qSlTag
].nextReq;

351 if((
xtReq
 !
REQ_SLOT_TAG_NONE
&& (
evReq
 != REQ_SLOT_TAG_NONE))

353 
qPoP
->
qPo
[
evReq
].
xtReq
 =extReq;

354 
qPoP
->
qPo
[
xtReq
].
evReq
 =revReq;

356 if((
xtReq
 =
REQ_SLOT_TAG_NONE
&& (
evReq
 != REQ_SLOT_TAG_NONE))

358 
qPoP
->
qPo
[
evReq
].
xtReq
 = 
REQ_SLOT_TAG_NONE
;

359 
nvmeDmaReqQ
.
Req
 = 
evReq
;

361 if((
xtReq
 !
REQ_SLOT_TAG_NONE
&& (
evReq
 == REQ_SLOT_TAG_NONE))

363 
qPoP
->
qPo
[
xtReq
].
evReq
 = 
REQ_SLOT_TAG_NONE
;

364 
nvmeDmaReqQ
.
hdReq
 = 
xtReq
;

368 
nvmeDmaReqQ
.
hdReq
 = 
REQ_SLOT_TAG_NONE
;

369 
nvmeDmaReqQ
.
Req
 = 
REQ_SLOT_TAG_NONE
;

372 
qPoP
->
qPo
[
qSlTag
].
qQueueTy
 = 
REQ_QUEUE_TYPE_NONE
;

373 
nvmeDmaReqQ
.
qC
--;

375 
	`PutToFeReqQ
(
qSlTag
);

376 
	`RBlockedByBufDReq
(
qSlTag
);

377 
	}
}

379 
	$PutToNdReqQ
(
qSlTag
, 
chNo
, 
wayNo
)

381 if(
ndReqQ
[
chNo
][
wayNo
].
Req
 !
REQ_SLOT_TAG_NONE
)

383 
qPoP
->
qPo
[
qSlTag
].
evReq
 = 
ndReqQ
[
chNo
][
wayNo
].
Req
;

384 
qPoP
->
qPo
[
qSlTag
].
xtReq
 = 
REQ_SLOT_TAG_NONE
;

385 
qPoP
->
qPo
[
ndReqQ
[
chNo
][
wayNo
].
Req
].
xtReq
 = 
qSlTag
;

386 
ndReqQ
[
chNo
][
wayNo
].
Req
 = 
qSlTag
;

390 
qPoP
->
qPo
[
qSlTag
].
evReq
 = 
REQ_SLOT_TAG_NONE
;

391 
qPoP
->
qPo
[
qSlTag
].
xtReq
 = 
REQ_SLOT_TAG_NONE
;

392 
ndReqQ
[
chNo
][
wayNo
].
hdReq
 = 
qSlTag
;

393 
ndReqQ
[
chNo
][
wayNo
].
Req
 = 
qSlTag
;

396 
qPoP
->
qPo
[
qSlTag
].
qQueueTy
 = 
REQ_QUEUE_TYPE_NAND
;

397 
ndReqQ
[
chNo
][
wayNo
].
qC
++;

398 
nComedNdReqC
++;

399 
	}
}

401 
	$GFromNdReqQ
(
chNo
, 
wayNo
, 
qStus
, 
qCode
)

403 
qSlTag
;

405 
qSlTag
 = 
ndReqQ
[
chNo
][
wayNo
].
hdReq
;

406 if(
qSlTag
 =
REQ_SLOT_TAG_NONE
)

407 
	`as
(!"[WARNING]here isoequest in Nand-req-queue[WARNING]");

409 if(
qPoP
->
qPo
[
qSlTag
].
xtReq
 !
REQ_SLOT_TAG_NONE
)

411 
ndReqQ
[
chNo
][
wayNo
].
hdReq
 = 
qPoP
->
qPo
[
qSlTag
].
xtReq
;

412 
qPoP
->
qPo
[qPoP->qPo[
qSlTag
].
xtReq
].
evReq
 = 
REQ_SLOT_TAG_NONE
;

416 
ndReqQ
[
chNo
][
wayNo
].
hdReq
 = 
REQ_SLOT_TAG_NONE
;

417 
ndReqQ
[
chNo
][
wayNo
].
Req
 = 
REQ_SLOT_TAG_NONE
;

420 
qPoP
->
qPo
[
qSlTag
].
qQueueTy
 = 
REQ_QUEUE_TYPE_NONE
;

421 
ndReqQ
[
chNo
][
wayNo
].
qC
--;

422 
nComedNdReqC
--;

424 
	`PutToFeReqQ
(
qSlTag
);

425 
	`RBlockedByBufDReq
(
qSlTag
);

426 
	}
}

	@request_allocation.h

46 #ide
REQUEST_ALLOCATION_H_


47 
	#REQUEST_ALLOCATION_H_


	)

49 
	~"l_cfig.h
"

50 
	~"que_fm.h
"

51 
	~"que_queue.h
"

53 
	#AVAILABLE_OUNTSTANDING_REQ_COUNT
 ((
USER_DIES
) * 128)

54 

	)

55 
	#REQ_SLOT_TAG_NONE
 0xffff

	)

56 
	#REQ_SLOT_TAG_FAIL
 0xffff

	)

58 
	s_REQ_POOL


60 
SSD_REQ_FORMAT
 
	mqPo
[
AVAILABLE_OUNTSTANDING_REQ_COUNT
];

61 } 
	tREQ_POOL
, *
	tP_REQ_POOL
;

63 
InReqPo
();

65 
PutToFeReqQ
(
qSlTag
);

66 
GFromFeReqQ
();

68 
PutToSliReqQ
(
qSlTag
);

69 
GFromSliReqQ
();

71 
PutToBlockedByBufDReqQ
(
qSlTag
);

72 
SeiveGFromBlockedByBufDReqQ
(
qSlTag
);

74 
PutToBlockedByRowAddrDReqQ
(
qSlTag
, 
chNo
, 
wayNo
);

75 
SeiveGFromBlockedByRowAddrDReqQ
(
qSlTag
, 
chNo
, 
wayNo
);

77 
PutToNvmeDmaReqQ
(
qSlTag
);

78 
SeiveGFromNvmeDmaReqQ
(
gSlTag
);

80 
PutToNdReqQ
(
qSlTag
, 
chNo
, 
wayNo
);

81 
GFromNdReqQ
(
chNo
, 
wayNo
, 
qStus
, 
qCode
);

83 
P_REQ_POOL
 
qPoP
;

84 
FREE_REQUEST_QUEUE
 
ReqQ
;

85 
SLICE_REQUEST_QUEUE
 
iReqQ
;

86 
BLOCKED_BY_BUFFER_DEPENDENCY_REQUEST_QUEUE
 
blockedByBufDReqQ
;

87 
BLOCKED_BY_ROW_ADDR_DEPENDENCY_REQUEST_QUEUE
 
blockedByRowAddrDReqQ
[
USER_CHANNELS
][
USER_WAYS
];

88 
NVME_DMA_REQUEST_QUEUE
 
nvmeDmaReqQ
;

89 
NAND_REQUEST_QUEUE
 
ndReqQ
[
USER_CHANNELS
][
USER_WAYS
];

91 
nComedNdReqC
;

92 
blockedReqC
;

	@request_format.h

46 #ide
REQUEST_FORMAT_H_


47 
	#REQUEST_FORMAT_H_


	)

49 
	~"nvme/nvme.h
"

51 
	#REQ_TYPE_SLICE
 0x0

	)

52 
	#REQ_TYPE_NAND
 0x1

	)

53 
	#REQ_TYPE_NVME_DMA
 0x2

	)

55 
	#REQ_QUEUE_TYPE_NONE
 0x0

	)

56 
	#REQ_QUEUE_TYPE_FREE
 0x1

	)

57 
	#REQ_QUEUE_TYPE_SLICE
 0x2

	)

58 
	#REQ_QUEUE_TYPE_BLOCKED_BY_BUF_DEP
 0x3

	)

59 
	#REQ_QUEUE_TYPE_BLOCKED_BY_ROW_ADDR_DEP
 0x4

	)

60 
	#REQ_QUEUE_TYPE_NVME_DMA
 0x5

	)

61 
	#REQ_QUEUE_TYPE_NAND
 0x6

	)

63 
	#REQ_CODE_WRITE
 0x00

	)

64 
	#REQ_CODE_READ
 0x08

	)

65 
	#REQ_CODE_READ_TRANSFER
 0x09

	)

66 
	#REQ_CODE_ERASE
 0x0C

	)

67 
	#REQ_CODE_RESET
 0x0D

	)

68 
	#REQ_CODE_SET_FEATURE
 0x0E

	)

69 
	#REQ_CODE_FLUSH
 0x0F

	)

70 
	#REQ_CODE_RxDMA
 0x10

	)

71 
	#REQ_CODE_TxDMA
 0x20

	)

73 
	#REQ_CODE_DEALLOCATE
 0x30

	)

75 
	#REQ_CODE_OCSSD_PHY_TYPE_BASE
 0xA0

	)

76 
	#REQ_CODE_OCSSD_PHY_WRITE
 0xA0

	)

77 
	#REQ_CODE_OCSSD_PHY_READ
 0xA8

	)

78 
	#REQ_CODE_OCSSD_PHY_ERASE
 0xAC

	)

81 
	#REQ_OPT_DATA_BUF_ENTRY
 0

	)

82 
	#REQ_OPT_DATA_BUF_TEMP_ENTRY
 1

	)

83 
	#REQ_OPT_DATA_BUF_ADDR
 2

	)

84 
	#REQ_OPT_DATA_BUF_NONE
 3

	)

86 
	#REQ_OPT_NAND_ADDR_VSA
 0

	)

87 
	#REQ_OPT_NAND_ADDR_PHY_ORG
 1

	)

89 
	#REQ_OPT_NAND_ECC_OFF
 0

	)

90 
	#REQ_OPT_NAND_ECC_ON
 1

	)

92 
	#REQ_OPT_NAND_ECC_WARNING_OFF
 0

	)

93 
	#REQ_OPT_NAND_ECC_WARNING_ON
 1

	)

95 
	#REQ_OPT_WRAPPING_NONE
 0

	)

96 
	#REQ_OPT_WRAPPING_REQ
 1

	)

98 
	#REQ_OPT_ROW_ADDR_DEPENDENCY_NONE
 0

	)

99 
	#REQ_OPT_ROW_ADDR_DEPENDENCY_CHECK
 1

	)

101 
	#REQ_OPT_FORCE_UNIT_ACCESS_OFF
 0

	)

102 
	#REQ_OPT_FORCE_UNIT_ACCESS_ON
 1

	)

104 
	#REQ_INFO_ISSUED_FLAG_OFF
 0

	)

105 
	#REQ_INFO_ISSUED_FLAG_ON
 1

	)

107 
	#REQ_OPT_BLOCK_SPACE_MAIN
 0

	)

108 
	#REQ_OPT_BLOCK_SPACE_TOTAL
 1

	)

110 
	#LOGICAL_SLICE_ADDR_NONE
 0xffffffff

	)

112 
	s_DATA_BUF_INFO
{

114 
	maddr
;

115 
	my
;

117 } 
	tDATA_BUF_INFO
, *
	tP_DATA_BUF_INFO
;

120 
	s_NVME_DMA_INFO
{

121 
	mtIndex
 : 16;

122 
	mnvmeBlockOfft
 : 16;

123 
	mnumOfNvmeBlock
 : 16;

124 
	mqTa
 : 8;

125 
	missuedFg
 : 1;

126 
	mrved0
 : 7;

127 
	movFlowC
;

128 } 
	tNVME_DMA_INFO
, *
	tP_NVME_DMA_INFO
;

131 
	s_NAND_INFO
{

133 
	mvtuSliAddr
;

135 
	mphysilCh
 : 4;

136 
	mphysilWay
 : 4;

137 
	mphysilBlock
 : 16;

138 
	mphyRerved0
 : 8;

142 
	mogmmedPageC
;

144 
	mphysilPage
 : 16;

145 
	mphyRerved1
 : 16;

148 } 
	tNAND_INFO
, *
	tP_NAND_INFO
;

151 
	s_REQ_OPTION
{

152 
	mdaBufFm
 : 2;

153 
	mndAddr
 : 2;

154 
	mndEcc
 : 1;

155 
	mndEccWng
 : 1;

156 
	mrowAddrDdcyCheck
 : 1;

157 
	mfUnAcss
 : 1;

158 
	mblockS
 : 1;

159 
	mrved0
 : 23;

160 } 
	tREQ_OPTION
, *
	tP_REQ_OPTION
;

163 
	s_SSD_REQ_FORMAT


165 
	mqTy
 : 4;

166 
	mqQueueTy
 : 4;

167 
	mqCode
 : 8;

168 
	mnvmeCmdSlTag
 : 16;

169 
	mqID
 :16;

170 
	mcID
 :16;

172 
	mlogilSliAddr
;

174 
REQ_OPTION
 
	mqO
;

175 
DATA_BUF_INFO
 
	mdaBufInfo
;

176 
NVME_DMA_INFO
 
	mnvmeDmaInfo
;

177 
NAND_INFO
 
	mndInfo
;

179 
	mevReq
 : 16;

180 
	mxtReq
 : 16;

181 
	mevBlockgReq
 : 16;

182 
	mxtBlockgReq
 : 16;

184 } 
	tSSD_REQ_FORMAT
, *
	tP_SSD_REQ_FORMAT
;

	@request_queue.h

45 #ide
REQUEST_QUEUE_H_


46 
	#REQUEST_QUEUE_H_


	)

49 
	s_FREE_REQUEST_QUEUE


51 
	mhdReq
 : 16;

52 
	mReq
 : 16;

53 
	mqC
 : 16;

54 
	mrved0
 : 16;

55 } 
	tFREE_REQUEST_QUEUE
, *
	tP_FREE_REQUEST_QUEUE
;

57 
	s_SLICE_REQUEST_QUEUE


59 
	mhdReq
 : 16;

60 
	mReq
 : 16;

61 
	mqC
 : 16;

62 
	mrved0
 : 16;

63 } 
	tSLICE_REQUEST_QUEUE
, *
	tP_SLICE_REQUEST_QUEUE
;

65 
	s_BLOCKED_BY_BUFFER_DEPENDENCY_REQUEST_QUEUE


67 
	mhdReq
 : 16;

68 
	mReq
 : 16;

69 
	mqC
 : 16;

70 
	mrved0
 : 16;

71 } 
	tBLOCKED_BY_BUFFER_DEPENDENCY_REQUEST_QUEUE
, *
	tP_BLOCKED_BY_BUFFER_DEPENDENCY_REQUEST_QUEUE
;

73 
	s_BLOCKED_BY_ROW_ADDR_DEPENDENCY_REQUEST_QUEUE


75 
	mhdReq
 : 16;

76 
	mReq
 : 16;

77 
	mqC
 : 16;

78 
	mrved0
 : 16;

79 } 
	tBLOCKED_BY_ROW_ADDR_DEPENDENCY_REQUEST_QUEUE
, *
	tPBLOCKED_BY_ROW_ADDR_DEPENDENCY_REQUEST_QUEUE
;

81 
	s_NVME_DMA_REQUEST_QUEUE


83 
	mhdReq
 : 16;

84 
	mReq
 : 16;

85 
	mqC
 : 16;

86 
	mrved0
 : 16;

87 } 
	tNVME_DMA_REQUEST_QUEUE
, *
	tP_NVME_DMA_REQUEST_QUEUE
;

89 
	s_NAND_REQUEST_QUEUE


91 
	mhdReq
 : 16;

92 
	mReq
 : 16;

93 
	mqC
 : 16;

94 
	mrved0
 : 16;

95 } 
	tNAND_REQUEST_QUEUE
, *
	tP_NAND_REQUEST_QUEUE
;

	@request_schedule.c

49 
	~<as.h
>

50 
	~"x_tf.h
"

51 
	~"memy_m.h
"

52 
	~"nvme/debug.h
"

54 
P_COMPLETE_FLAG_TABLE
 
	gcomeFgTabP
;

55 
P_STATUS_REPORT_TABLE
 
	gusRtTabP
;

56 
P_ERROR_INFO_TABLE
 
	geccEInfoTabP
;

57 
P_RETRY_LIMIT_TABLE
 
	gyLimTabP
;

59 
P_DIE_STATE_TABLE
 
	gdSTabP
;

60 
P_WAY_PRIORITY_TABLE
 
	gwayPriܙyTabP
;

62 
	$InReqSchedur
()

64 
chNo
,
wayNo
;

66 
comeFgTabP
 = (
P_COMPLETE_FLAG_TABLE

COMPLETE_FLAG_TABLE_ADDR
;

67 
usRtTabP
 = (
P_STATUS_REPORT_TABLE

STATUS_REPORT_TABLE_ADDR
;

68 
eccEInfoTabP
 = (
P_ERROR_INFO_TABLE

ERROR_INFO_TABLE_ADDR
;

69 
yLimTabP
 = (
P_RETRY_LIMIT_TABLE

RETRY_LIMIT_TABLE_ADDR
;

71 
dSTabP
 = (
P_DIE_STATE_TABLE

DIE_STATE_TABLE_ADDR
;

72 
wayPriܙyTabP
 = (
P_WAY_PRIORITY_TABLE

WAY_PRIORITY_TABLE_ADDR
;

74 
chNo
=0; chNo<
USER_CHANNELS
; ++chNo)

76 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
idHd
 = 0;

77 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
idTa
 = 
USER_WAYS
 - 1;

78 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
usRtHd
 = 
WAY_NONE
;

79 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
usRtTa
 = 
WAY_NONE
;

80 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
aHd
 = 
WAY_NONE
;

81 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
aTa
 = 
WAY_NONE
;

82 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
adTriggHd
 = 
WAY_NONE
;

83 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
adTriggTa
 = 
WAY_NONE
;

84 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
wreHd
 = 
WAY_NONE
;

85 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
wreTa
 = 
WAY_NONE
;

86 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
adTnsrHd
 = 
WAY_NONE
;

87 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
adTnsrTa
 = 
WAY_NONE
;

88 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
usCheckHd
 = 
WAY_NONE
;

89 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
usCheckTa
 = 
WAY_NONE
;

91 
wayNo
=0; wayNo<
USER_WAYS
; ++wayNo)

93 
dSTabP
->
dS
[
chNo
][
wayNo
].dS = 
DIE_STATE_IDLE
;

94 
dSTabP
->
dS
[
chNo
][
wayNo
].
qStusCheckO
 = 
REQ_STATUS_CHECK_OPT_NONE
;

95 
dSTabP
->
dS
[
chNo
][
wayNo
].
evWay
 = wayNo - 1;

96 
dSTabP
->
dS
[
chNo
][
wayNo
].
xtWay
 = wayNo + 1;

98 
comeFgTabP
->
comeFg
[
chNo
][
wayNo
] = 0;

99 
usRtTabP
->
usRt
[
chNo
][
wayNo
] = 0;

100 
yLimTabP
->
yLim
[
chNo
][
wayNo
] = 
RETRY_LIMIT
;

102 
dSTabP
->
dS
[
chNo
][0].
evWay
 = 
WAY_NONE
;

103 
dSTabP
->
dS
[
chNo
][
USER_WAYS
-1].
xtWay
 = 
WAY_NONE
;

105 
	}
}

109 
	$SyncALowLevReqDe
()

111 (
nvmeDmaReqQ
.
hdReq
 !
REQ_SLOT_TAG_NONE
|| 
nComedNdReqC
 || 
blockedReqC
)

113 
	`CheckDeNvmeDmaReq
();

114 
	`SchedulgNdReq
();

116 
	}
}

118 
	$SyncAvaFeReq
()

120 
ReqQ
.
hdReq
 =
REQ_SLOT_TAG_NONE
)

122 
	`CheckDeNvmeDmaReq
();

123 
	`SchedulgNdReq
();

125 
	}
}

127 
	$SyncREReq
(
chNo
, 
wayNo
, 
blockNo
)

129 
rowAddrDdcyTabP
->
block
[
chNo
][
wayNo
][
blockNo
].
blockedEReqFg
)

131 
	`CheckDeNvmeDmaReq
();

132 
	`SchedulgNdReq
();

134 
	}
}

136 
	$SchedulgNdReq
()

138 
chNo
;

140 
chNo
 = 0; chN< 
USER_CHANNELS
; chNo++)

141 
	`SchedulgNdReqPCh
(
chNo
);

142 
	}
}

144 
	$SchedulgNdReqPCh
(
chNo
)

146 
adyBusy
, 
wayNo
, 
qStus
, 
xtWay
, 
waWayC
;

148 
waWayC
 = 0;

149 if(
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
idHd
 !
WAY_NONE
)

151 
wayNo
 = 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
idHd
;

153 
wayNo
 !
WAY_NONE
)

155 if(
ndReqQ
[
chNo
][
wayNo
].
hdReq
 =
REQ_SLOT_TAG_NONE
)

156 
	`RBlockedByRowAddrDReq
(
chNo
, 
wayNo
);

158 if(
ndReqQ
[
chNo
][
wayNo
].
hdReq
 !
REQ_SLOT_TAG_NONE
)

160 
xtWay
 = 
dSTabP
->
dS
[
chNo
][
wayNo
].nextWay;

162 
	`SeivGFromNdIdLi
(
chNo
, 
wayNo
);

163 
	`PutToNdWayPriܙyTab
(
ndReqQ
[
chNo
][
wayNo
].
hdReq
, chNo, wayNo);

164 
wayNo
 = 
xtWay
;

168 
wayNo
 = 
dSTabP
->
dS
[
chNo
][wayNo].
xtWay
;

170 
waWayC
++;

174 if(
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
usRtHd
 !
WAY_NONE
)

176 
adyBusy
 = 
	`V2FRdyBusyAsync
(&
chCReg
[
chNo
]);

177 
wayNo
 = 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
usRtHd
;

179 
wayNo
 !
WAY_NONE
)

181 if(
	`V2FWayRdy
(
adyBusy
, 
wayNo
))

183 
qStus
 = 
	`CheckReqStus
(
chNo
, 
wayNo
);

185 if(
qStus
 !
REQ_STATUS_RUNNING
)

187 
	`ExecuNdReq
(
chNo
, 
wayNo
, 
qStus
);

188 
xtWay
 = 
dSTabP
->
dS
[
chNo
][
wayNo
].nextWay;

189 
	`SeivGFromNdStusRtLi
(
chNo
, 
wayNo
);

191 if(
ndReqQ
[
chNo
][
wayNo
].
hdReq
 =
REQ_SLOT_TAG_NONE
)

192 
	`RBlockedByRowAddrDReq
(
chNo
, 
wayNo
);

194 if(
ndReqQ
[
chNo
][
wayNo
].
hdReq
 !
REQ_SLOT_TAG_NONE
)

195 
	`PutToNdWayPriܙyTab
(
ndReqQ
[
chNo
][
wayNo
].
hdReq
, chNo, wayNo);

198 
	`PutToNdIdLi
(
chNo
, 
wayNo
);

199 
waWayC
++;

202 
wayNo
 = 
xtWay
;

204 if(
dSTabP
->
dS
[
chNo
][
wayNo
].
qStusCheckO
 =
REQ_STATUS_CHECK_OPT_CHECK
)

206 
xtWay
 = 
dSTabP
->
dS
[
chNo
][
wayNo
].nextWay;

207 
	`SeivGFromNdStusRtLi
(
chNo
, 
wayNo
);

209 
	`PutToNdStusCheckLi
(
chNo
, 
wayNo
);

210 
wayNo
 = 
xtWay
;

214 
wayNo
 = 
dSTabP
->
dS
[
chNo
][wayNo].
xtWay
;

215 
waWayC
++;

220 
wayNo
 = 
dSTabP
->
dS
[
chNo
][wayNo].
xtWay
;

221 
waWayC
++;

225 if(
waWayC
 !
USER_WAYS
)

226 if(!
	`V2FIsCڌrBusy
(&
chCReg
[
chNo
]))

228 if(
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
usCheckHd
 !
WAY_NONE
)

230 
adyBusy
 = 
	`V2FRdyBusyAsync
(&
chCReg
[
chNo
]);

231 
wayNo
 = 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
usCheckHd
;

233 
wayNo
 !
WAY_NONE
)

235 if(
	`V2FWayRdy
(
adyBusy
, 
wayNo
))

237 
qStus
 = 
	`CheckReqStus
(
chNo
, 
wayNo
);

239 
	`SeiveGFromNdStusCheckLi
(
chNo
,
wayNo
);

240 
	`PutToNdStusRtLi
(
chNo
, 
wayNo
);

242 if(
	`V2FIsCڌrBusy
(&
chCReg
[
chNo
]))

246 
wayNo
 = 
dSTabP
->
dS
[
chNo
][wayNo].
xtWay
;

249 if(
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
adTriggHd
 !
WAY_NONE
)

251 
wayNo
 = 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
adTriggHd
;

253 
wayNo
 !
WAY_NONE
)

255 
	`ExecuNdReq
(
chNo
, 
wayNo
, 
REQ_STATUS_RUNNING
);

257 
	`SeiveGFromNdRdTriggLi
(
chNo
, 
wayNo
);

258 
	`PutToNdStusCheckLi
(
chNo
, 
wayNo
);

260 if(
	`V2FIsCڌrBusy
(&
chCReg
[
chNo
]))

263 
wayNo
 = 
dSTabP
->
dS
[
chNo
][wayNo].
xtWay
;

267 if(
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
aHd
 !
WAY_NONE
)

269 
wayNo
 = 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
aHd
;

272 
wayNo
 !
WAY_NONE
)

274 
	`ExecuNdReq
(
chNo
, 
wayNo
, 
REQ_STATUS_RUNNING
);

276 
	`SeiveGFromNdELi
(
chNo
, 
wayNo
);

277 
	`PutToNdStusCheckLi
(
chNo
, 
wayNo
);

279 if(
	`V2FIsCڌrBusy
(&
chCReg
[
chNo
]))

282 
wayNo
 = 
dSTabP
->
dS
[
chNo
][wayNo].
xtWay
;

285 if(
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
wreHd
 !
WAY_NONE
)

287 
wayNo
 = 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
wreHd
;

289 
wayNo
 !
WAY_NONE
)

291 
	`ExecuNdReq
(
chNo
, 
wayNo
, 
REQ_STATUS_RUNNING
);

293 
	`SeiveGFromNdWreLi
(
chNo
, 
wayNo
);

294 
	`PutToNdStusCheckLi
(
chNo
, 
wayNo
);

296 if(
	`V2FIsCڌrBusy
(&
chCReg
[
chNo
]))

299 
wayNo
 = 
dSTabP
->
dS
[
chNo
][wayNo].
xtWay
;

302 if(
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
adTnsrHd
 !
WAY_NONE
)

304 
wayNo
 = 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
adTnsrHd
;

306 
wayNo
 !
WAY_NONE
)

308 
	`ExecuNdReq
(
chNo
, 
wayNo
, 
REQ_STATUS_RUNNING
);

310 
	`SeiveGFromNdRdTnsrLi
(
chNo
, 
wayNo
);

311 
	`PutToNdStusRtLi
(
chNo
, 
wayNo
);

313 if(
	`V2FIsCڌrBusy
(&
chCReg
[
chNo
]))

316 
wayNo
 = 
dSTabP
->
dS
[
chNo
][wayNo].
xtWay
;

321 
	}
}

323 
	$PutToNdWayPriܙyTab
(
qSlTag
, 
chNo
, 
wayNo
)

325 if(
qPoP
->
qPo
[
qSlTag
].
qCode
 =
REQ_CODE_READ
)

326 
	`PutToNdRdTriggLi
(
chNo
, 
wayNo
);

327 if(
qPoP
->
qPo
[
qSlTag
].
qCode
 =
REQ_CODE_READ_TRANSFER
)

328 
	`PutToNdRdTnsrLi
(
chNo
, 
wayNo
);

329 if(
qPoP
->
qPo
[
qSlTag
].
qCode
 =
REQ_CODE_WRITE
)

330 
	`PutToNdWreLi
(
chNo
, 
wayNo
);

331 if(
qPoP
->
qPo
[
qSlTag
].
qCode
 =
REQ_CODE_ERASE
)

332 
	`PutToNdELi
(
chNo
, 
wayNo
);

333 if((
qPoP
->
qPo
[
qSlTag
].
qCode
 =
REQ_CODE_RESET
)|| (qPoP->qPo[qSlTag].qCod=
REQ_CODE_SET_FEATURE
))

334 
	`PutToNdWreLi
(
chNo
, 
wayNo
);

336 
	`as
(!"[WARNING] wrongeqCode [WARNING]");

338 
	}
}

340 
	$PutToNdIdLi
(
chNo
, 
wayNo
)

342 if(
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
idTa
 !
WAY_NONE
)

344 
dSTabP
->
dS
[
chNo
][
wayNo
].
evWay
 = 
wayPriܙyTabP
->
wayPriܙy
[chNo].
idTa
;

345 
dSTabP
->
dS
[
chNo
][
wayNo
].
xtWay
 = 
WAY_NONE
;

346 
dSTabP
->
dS
[
chNo
][
wayPriܙyTabP
->
wayPriܙy
[chNo].
idTa
].
xtWay
 = 
wayNo
;

347 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
idTa
 = 
wayNo
;

351 
dSTabP
->
dS
[
chNo
][
wayNo
].
evWay
 = 
WAY_NONE
;

352 
dSTabP
->
dS
[
chNo
][
wayNo
].
xtWay
 = 
WAY_NONE
;

353 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
idHd
 = 
wayNo
;

354 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
idTa
 = 
wayNo
;

356 
	}
}

359 
	$SeivGFromNdIdLi
(
chNo
, 
wayNo
)

361 if((
dSTabP
->
dS
[
chNo
][
wayNo
].
xtWay
 !
WAY_NONE
&& (dSTabP->dS[chNo][wayNo].
evWay
 != WAY_NONE))

363 
dSTabP
->
dS
[
chNo
][dSTabP->dS[chNo][
wayNo
].
evWay
].
xtWay
 = dieStateTablePtr->dieState[chNo][wayNo].nextWay;

364 
dSTabP
->
dS
[
chNo
][dSTabP->dS[chNo][
wayNo
].
xtWay
].
evWay
 = dieStateTablePtr->dieState[chNo][wayNo].prevWay;

366 if((
dSTabP
->
dS
[
chNo
][
wayNo
].
xtWay
 =
WAY_NONE
&& (dSTabP->dS[chNo][wayNo].
evWay
 != WAY_NONE))

368 
dSTabP
->
dS
[
chNo
][dSTabP->dS[chNo][
wayNo
].
evWay
].
xtWay
 = 
WAY_NONE
;

369 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
idTa
 = 
dSTabP
->
dS
[chNo][
wayNo
].
evWay
;

371 if((
dSTabP
->
dS
[
chNo
][
wayNo
].
xtWay
 !
WAY_NONE
&& (dSTabP->dS[chNo][wayNo].
evWay
 == WAY_NONE))

373 
dSTabP
->
dS
[
chNo
][dSTabP->dS[chNo][
wayNo
].
xtWay
].
evWay
 = 
WAY_NONE
;

374 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
idHd
 = 
dSTabP
->
dS
[chNo][
wayNo
].
xtWay
;

378 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
idHd
 = 
WAY_NONE
;

379 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
idTa
 = 
WAY_NONE
;

381 
	}
}

385 
	$PutToNdStusRtLi
(
chNo
, 
wayNo
)

387 if(
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
usRtTa
 !
WAY_NONE
)

389 
dSTabP
->
dS
[
chNo
][
wayNo
].
evWay
 = 
wayPriܙyTabP
->
wayPriܙy
[chNo].
usRtTa
;

390 
dSTabP
->
dS
[
chNo
][
wayNo
].
xtWay
 = 
WAY_NONE
;

391 
dSTabP
->
dS
[
chNo
][
wayPriܙyTabP
->
wayPriܙy
[chNo].
usRtTa
].
xtWay
 = 
wayNo
;

392 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
usRtTa
 = 
wayNo
;

396 
dSTabP
->
dS
[
chNo
][
wayNo
].
evWay
 = 
WAY_NONE
;

397 
dSTabP
->
dS
[
chNo
][
wayNo
].
xtWay
 = 
WAY_NONE
;

398 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
usRtHd
 = 
wayNo
;

399 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
usRtTa
 = 
wayNo
;

401 
	}
}

403 
	$SeivGFromNdStusRtLi
(
chNo
, 
wayNo
)

405 if((
dSTabP
->
dS
[
chNo
][
wayNo
].
xtWay
 !
WAY_NONE
&& (dSTabP->dS[chNo][wayNo].
evWay
 != WAY_NONE))

407 
dSTabP
->
dS
[
chNo
][dSTabP->dS[chNo][
wayNo
].
evWay
].
xtWay
 = dieStateTablePtr->dieState[chNo][wayNo].nextWay;

408 
dSTabP
->
dS
[
chNo
][dSTabP->dS[chNo][
wayNo
].
xtWay
].
evWay
 = dieStateTablePtr->dieState[chNo][wayNo].prevWay;

410 if((
dSTabP
->
dS
[
chNo
][
wayNo
].
xtWay
 =
WAY_NONE
&& (dSTabP->dS[chNo][wayNo].
evWay
 != WAY_NONE))

412 
dSTabP
->
dS
[
chNo
][dSTabP->dS[chNo][
wayNo
].
evWay
].
xtWay
 = 
WAY_NONE
;

413 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
usRtTa
 = 
dSTabP
->
dS
[chNo][
wayNo
].
evWay
;

415 if((
dSTabP
->
dS
[
chNo
][
wayNo
].
xtWay
 !
WAY_NONE
&& (dSTabP->dS[chNo][wayNo].
evWay
 == WAY_NONE))

417 
dSTabP
->
dS
[
chNo
][dSTabP->dS[chNo][
wayNo
].
xtWay
].
evWay
 = 
WAY_NONE
;

418 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
usRtHd
 = 
dSTabP
->
dS
[chNo][
wayNo
].
xtWay
;

422 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
usRtHd
 = 
WAY_NONE
;

423 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
usRtTa
 = 
WAY_NONE
;

425 
	}
}

428 
	$PutToNdRdTriggLi
(
chNo
, 
wayNo
)

430 if(
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
adTriggTa
 !
WAY_NONE
)

432 
dSTabP
->
dS
[
chNo
][
wayNo
].
evWay
 = 
wayPriܙyTabP
->
wayPriܙy
[chNo].
adTriggTa
;

433 
dSTabP
->
dS
[
chNo
][
wayNo
].
xtWay
 = 
WAY_NONE
;

434 
dSTabP
->
dS
[
chNo
][
wayPriܙyTabP
->
wayPriܙy
[chNo].
adTriggTa
].
xtWay
 = 
wayNo
;

435 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
adTriggTa
 = 
wayNo
;

439 
dSTabP
->
dS
[
chNo
][
wayNo
].
evWay
 = 
WAY_NONE
;

440 
dSTabP
->
dS
[
chNo
][
wayNo
].
xtWay
 = 
WAY_NONE
;

441 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
adTriggHd
 = 
wayNo
;

442 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
adTriggTa
 = 
wayNo
;

444 
	}
}

446 
	$SeiveGFromNdRdTriggLi
(
chNo
, 
wayNo
)

448 if((
dSTabP
->
dS
[
chNo
][
wayNo
].
xtWay
 !
WAY_NONE
&& (dSTabP->dS[chNo][wayNo].
evWay
 != WAY_NONE))

450 
dSTabP
->
dS
[
chNo
][dSTabP->dS[chNo][
wayNo
].
evWay
].
xtWay
 = dieStateTablePtr->dieState[chNo][wayNo].nextWay;

451 
dSTabP
->
dS
[
chNo
][dSTabP->dS[chNo][
wayNo
].
xtWay
].
evWay
 = dieStateTablePtr->dieState[chNo][wayNo].prevWay;

453 if((
dSTabP
->
dS
[
chNo
][
wayNo
].
xtWay
 =
WAY_NONE
&& (dSTabP->dS[chNo][wayNo].
evWay
 != WAY_NONE))

455 
dSTabP
->
dS
[
chNo
][dSTabP->dS[chNo][
wayNo
].
evWay
].
xtWay
 = 
WAY_NONE
;

456 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
adTriggTa
 = 
dSTabP
->
dS
[chNo][
wayNo
].
evWay
;

458 if((
dSTabP
->
dS
[
chNo
][
wayNo
].
xtWay
 !
WAY_NONE
&& (dSTabP->dS[chNo][wayNo].
evWay
 == WAY_NONE))

460 
dSTabP
->
dS
[
chNo
][dSTabP->dS[chNo][
wayNo
].
xtWay
].
evWay
 = 
WAY_NONE
;

461 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
adTriggHd
 = 
dSTabP
->
dS
[chNo][
wayNo
].
xtWay
;

465 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
adTriggHd
 = 
WAY_NONE
;

466 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
adTriggTa
 = 
WAY_NONE
;

468 
	}
}

470 
	$PutToNdWreLi
(
chNo
, 
wayNo
)

472 if(
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
wreTa
 !
WAY_NONE
)

474 
dSTabP
->
dS
[
chNo
][
wayNo
].
evWay
 = 
wayPriܙyTabP
->
wayPriܙy
[chNo].
wreTa
;

475 
dSTabP
->
dS
[
chNo
][
wayNo
].
xtWay
 = 
WAY_NONE
;

476 
dSTabP
->
dS
[
chNo
][
wayPriܙyTabP
->
wayPriܙy
[chNo].
wreTa
].
xtWay
 = 
wayNo
;

477 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
wreTa
 = 
wayNo
;

481 
dSTabP
->
dS
[
chNo
][
wayNo
].
evWay
 = 
WAY_NONE
;

482 
dSTabP
->
dS
[
chNo
][
wayNo
].
xtWay
 = 
WAY_NONE
;

483 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
wreHd
 = 
wayNo
;

484 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
wreTa
 = 
wayNo
;

486 
	}
}

488 
	$SeiveGFromNdWreLi
(
chNo
, 
wayNo
)

490 if((
dSTabP
->
dS
[
chNo
][
wayNo
].
xtWay
 !
WAY_NONE
&& (dSTabP->dS[chNo][wayNo].
evWay
 != WAY_NONE))

492 
dSTabP
->
dS
[
chNo
][dSTabP->dS[chNo][
wayNo
].
evWay
].
xtWay
 = dieStateTablePtr->dieState[chNo][wayNo].nextWay;

493 
dSTabP
->
dS
[
chNo
][dSTabP->dS[chNo][
wayNo
].
xtWay
].
evWay
 = dieStateTablePtr->dieState[chNo][wayNo].prevWay;

495 if((
dSTabP
->
dS
[
chNo
][
wayNo
].
xtWay
 =
WAY_NONE
&& (dSTabP->dS[chNo][wayNo].
evWay
 != WAY_NONE))

497 
dSTabP
->
dS
[
chNo
][dSTabP->dS[chNo][
wayNo
].
evWay
].
xtWay
 = 
WAY_NONE
;

498 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
wreTa
 = 
dSTabP
->
dS
[chNo][
wayNo
].
evWay
;

500 if((
dSTabP
->
dS
[
chNo
][
wayNo
].
xtWay
 !
WAY_NONE
&& (dSTabP->dS[chNo][wayNo].
evWay
 == WAY_NONE))

502 
dSTabP
->
dS
[
chNo
][dSTabP->dS[chNo][
wayNo
].
xtWay
].
evWay
 = 
WAY_NONE
;

503 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
wreHd
 = 
dSTabP
->
dS
[chNo][
wayNo
].
xtWay
;

507 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
wreHd
 = 
WAY_NONE
;

508 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
wreTa
 = 
WAY_NONE
;

511 
	}
}

513 
	$PutToNdRdTnsrLi
(
chNo
, 
wayNo
)

515 if(
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
adTnsrTa
 !
WAY_NONE
)

517 
dSTabP
->
dS
[
chNo
][
wayNo
].
evWay
 = 
wayPriܙyTabP
->
wayPriܙy
[chNo].
adTnsrTa
;

518 
dSTabP
->
dS
[
chNo
][
wayNo
].
xtWay
 = 
WAY_NONE
;

519 
dSTabP
->
dS
[
chNo
][
wayPriܙyTabP
->
wayPriܙy
[chNo].
adTnsrTa
].
xtWay
 = 
wayNo
;

520 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
adTnsrTa
 = 
wayNo
;

524 
dSTabP
->
dS
[
chNo
][
wayNo
].
evWay
 = 
WAY_NONE
;

525 
dSTabP
->
dS
[
chNo
][
wayNo
].
xtWay
 = 
WAY_NONE
;

526 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
adTnsrHd
 = 
wayNo
;

527 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
adTnsrTa
 = 
wayNo
;

529 
	}
}

531 
	$SeiveGFromNdRdTnsrLi
(
chNo
, 
wayNo
)

533 if((
dSTabP
->
dS
[
chNo
][
wayNo
].
xtWay
 !
WAY_NONE
&& (dSTabP->dS[chNo][wayNo].
evWay
 != WAY_NONE))

535 
dSTabP
->
dS
[
chNo
][dSTabP->dS[chNo][
wayNo
].
evWay
].
xtWay
 = dieStateTablePtr->dieState[chNo][wayNo].nextWay;

536 
dSTabP
->
dS
[
chNo
][dSTabP->dS[chNo][
wayNo
].
xtWay
].
evWay
 = dieStateTablePtr->dieState[chNo][wayNo].prevWay;

538 if((
dSTabP
->
dS
[
chNo
][
wayNo
].
xtWay
 =
WAY_NONE
&& (dSTabP->dS[chNo][wayNo].
evWay
 != WAY_NONE))

540 
dSTabP
->
dS
[
chNo
][dSTabP->dS[chNo][
wayNo
].
evWay
].
xtWay
 = 
WAY_NONE
;

541 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
adTnsrTa
 = 
dSTabP
->
dS
[chNo][
wayNo
].
evWay
;

543 if((
dSTabP
->
dS
[
chNo
][
wayNo
].
xtWay
 !
WAY_NONE
&& (dSTabP->dS[chNo][wayNo].
evWay
 == WAY_NONE))

545 
dSTabP
->
dS
[
chNo
][dSTabP->dS[chNo][
wayNo
].
xtWay
].
evWay
 = 
WAY_NONE
;

546 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
adTnsrHd
 = 
dSTabP
->
dS
[chNo][
wayNo
].
xtWay
;

550 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
adTnsrHd
 = 
WAY_NONE
;

551 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
adTnsrTa
 = 
WAY_NONE
;

553 
	}
}

556 
	$PutToNdELi
(
chNo
, 
wayNo
)

558 if(
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
aTa
 !
WAY_NONE
)

560 
dSTabP
->
dS
[
chNo
][
wayNo
].
evWay
 = 
wayPriܙyTabP
->
wayPriܙy
[chNo].
aTa
;

561 
dSTabP
->
dS
[
chNo
][
wayNo
].
xtWay
 = 
WAY_NONE
;

562 
dSTabP
->
dS
[
chNo
][
wayPriܙyTabP
->
wayPriܙy
[chNo].
aTa
].
xtWay
 = 
wayNo
;

563 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
aTa
 = 
wayNo
;

567 
dSTabP
->
dS
[
chNo
][
wayNo
].
evWay
 = 
WAY_NONE
;

568 
dSTabP
->
dS
[
chNo
][
wayNo
].
xtWay
 = 
WAY_NONE
;

569 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
aHd
 = 
wayNo
;

570 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
aTa
 = 
wayNo
;

572 
	}
}

575 
	$SeiveGFromNdELi
(
chNo
, 
wayNo
)

577 if((
dSTabP
->
dS
[
chNo
][
wayNo
].
xtWay
 !
WAY_NONE
&& (dSTabP->dS[chNo][wayNo].
evWay
 != WAY_NONE))

579 
dSTabP
->
dS
[
chNo
][dSTabP->dS[chNo][
wayNo
].
evWay
].
xtWay
 = dieStateTablePtr->dieState[chNo][wayNo].nextWay;

580 
dSTabP
->
dS
[
chNo
][dSTabP->dS[chNo][
wayNo
].
xtWay
].
evWay
 = dieStateTablePtr->dieState[chNo][wayNo].prevWay;

582 if((
dSTabP
->
dS
[
chNo
][
wayNo
].
xtWay
 =
WAY_NONE
&& (dSTabP->dS[chNo][wayNo].
evWay
 != WAY_NONE))

584 
dSTabP
->
dS
[
chNo
][dSTabP->dS[chNo][
wayNo
].
evWay
].
xtWay
 = 
WAY_NONE
;

585 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
aTa
 = 
dSTabP
->
dS
[chNo][
wayNo
].
evWay
;

587 if((
dSTabP
->
dS
[
chNo
][
wayNo
].
xtWay
 !
WAY_NONE
&& (dSTabP->dS[chNo][wayNo].
evWay
 == WAY_NONE))

589 
dSTabP
->
dS
[
chNo
][dSTabP->dS[chNo][
wayNo
].
xtWay
].
evWay
 = 
WAY_NONE
;

590 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
aHd
 = 
dSTabP
->
dS
[chNo][
wayNo
].
xtWay
;

594 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
aHd
 = 
WAY_NONE
;

595 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
aTa
 = 
WAY_NONE
;

597 
	}
}

599 
	$PutToNdStusCheckLi
(
chNo
, 
wayNo
)

601 if(
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
usCheckTa
 !
WAY_NONE
)

603 
dSTabP
->
dS
[
chNo
][
wayNo
].
evWay
 = 
wayPriܙyTabP
->
wayPriܙy
[chNo].
usCheckTa
;

604 
dSTabP
->
dS
[
chNo
][
wayNo
].
xtWay
 = 
WAY_NONE
;

605 
dSTabP
->
dS
[
chNo
][
wayPriܙyTabP
->
wayPriܙy
[chNo].
usCheckTa
].
xtWay
 = 
wayNo
;

606 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
usCheckTa
 = 
wayNo
;

610 
dSTabP
->
dS
[
chNo
][
wayNo
].
evWay
 = 
WAY_NONE
;

611 
dSTabP
->
dS
[
chNo
][
wayNo
].
xtWay
 = 
WAY_NONE
;

612 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
usCheckHd
 = 
wayNo
;

613 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
usCheckTa
 = 
wayNo
;

615 
	}
}

617 
	$SeiveGFromNdStusCheckLi
(
chNo
, 
wayNo
)

619 if((
dSTabP
->
dS
[
chNo
][
wayNo
].
xtWay
 !
WAY_NONE
&& (dSTabP->dS[chNo][wayNo].
evWay
 != WAY_NONE))

621 
dSTabP
->
dS
[
chNo
][dSTabP->dS[chNo][
wayNo
].
evWay
].
xtWay
 = dieStateTablePtr->dieState[chNo][wayNo].nextWay;

622 
dSTabP
->
dS
[
chNo
][dSTabP->dS[chNo][
wayNo
].
xtWay
].
evWay
 = dieStateTablePtr->dieState[chNo][wayNo].prevWay;

624 if((
dSTabP
->
dS
[
chNo
][
wayNo
].
xtWay
 =
WAY_NONE
&& (dSTabP->dS[chNo][wayNo].
evWay
 != WAY_NONE))

626 
dSTabP
->
dS
[
chNo
][dSTabP->dS[chNo][
wayNo
].
evWay
].
xtWay
 = 
WAY_NONE
;

627 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
usCheckTa
 = 
dSTabP
->
dS
[chNo][
wayNo
].
evWay
;

629 if((
dSTabP
->
dS
[
chNo
][
wayNo
].
xtWay
 !
WAY_NONE
&& (dSTabP->dS[chNo][wayNo].
evWay
 == WAY_NONE))

631 
dSTabP
->
dS
[
chNo
][dSTabP->dS[chNo][
wayNo
].
xtWay
].
evWay
 = 
WAY_NONE
;

632 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
usCheckHd
 = 
dSTabP
->
dS
[chNo][
wayNo
].
xtWay
;

636 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
usCheckHd
 = 
WAY_NONE
;

637 
wayPriܙyTabP
->
wayPriܙy
[
chNo
].
usCheckTa
 = 
WAY_NONE
;

640 
	}
}

642 
	$IssueNdReq
(
chNo
, 
wayNo
)

644 
qSlTag
, 
rowAddr
;

645 * 
daBufAddr
;

646 * 
eDaBufAddr
;

647 * 
rInfo
;

648 * 
comi
;

650 
qSlTag
 = 
ndReqQ
[
chNo
][
wayNo
].
hdReq
;

651 
rowAddr
 = 
	`GeNdRowAddr
(
qSlTag
);

652 
daBufAddr
 = (*)
	`GeDaBufAddr
(
qSlTag
);

653 
eDaBufAddr
 = (*)
	`GeSDaBufAddr
(
qSlTag
);

655 if(
qPoP
->
qPo
[
qSlTag
].
qCode
 =
REQ_CODE_READ
)

657 
dSTabP
->
dS
[
chNo
][
wayNo
].
qStusCheckO
 = 
REQ_STATUS_CHECK_OPT_CHECK
;

659 
	`V2FRdPageTriggAsync
(&
chCReg
[
chNo
], 
wayNo
, 
rowAddr
);

661 if(
qPoP
->
qPo
[
qSlTag
].
qCode
 =
REQ_CODE_READ_TRANSFER
)

663 
dSTabP
->
dS
[
chNo
][
wayNo
].
qStusCheckO
 = 
REQ_STATUS_CHECK_OPT_COMPLETION_FLAG
;

665 
rInfo
 = (*)(&
eccEInfoTabP
->rInfo[
chNo
][
wayNo
]);

666 
comi
 = (*)(&
comeFgTabP
->
comeFg
[
chNo
][
wayNo
]);

668 if(
qPoP
->
qPo
[
qSlTag
].
qO
.
ndEcc
 =
REQ_OPT_NAND_ECC_ON
)

669 
	`V2FRdPageTnsrAsync
(&
chCReg
[
chNo
], 
wayNo
, 
daBufAddr
, 
eDaBufAddr
, 
rInfo
, 
comi
, 
rowAddr
);

671 
	`V2FRdPageTnsrRawAsync
(&
chCReg
[
chNo
], 
wayNo
, 
daBufAddr
, 
comi
);

673 if(
qPoP
->
qPo
[
qSlTag
].
qCode
 =
REQ_CODE_WRITE
)

675 
dSTabP
->
dS
[
chNo
][
wayNo
].
qStusCheckO
 = 
REQ_STATUS_CHECK_OPT_CHECK
;

677 
	`V2FProgmPageAsync
(&
chCReg
[
chNo
], 
wayNo
, 
rowAddr
, 
daBufAddr
, 
eDaBufAddr
);

679 if(
qPoP
->
qPo
[
qSlTag
].
qCode
 =
REQ_CODE_ERASE
)

681 
dSTabP
->
dS
[
chNo
][
wayNo
].
qStusCheckO
 = 
REQ_STATUS_CHECK_OPT_CHECK
;

683 
	`V2FEBlockAsync
(&
chCReg
[
chNo
], 
wayNo
, 
rowAddr
);

685 if(
qPoP
->
qPo
[
qSlTag
].
qCode
 =
REQ_CODE_RESET
)

687 
dSTabP
->
dS
[
chNo
][
wayNo
].
qStusCheckO
 = 
REQ_STATUS_CHECK_OPT_NONE
;

689 
	`V2FRetSync
(&
chCReg
[
chNo
], 
wayNo
);

691 if(
qPoP
->
qPo
[
qSlTag
].
qCode
 =
REQ_CODE_SET_FEATURE
)

693 
dSTabP
->
dS
[
chNo
][
wayNo
].
qStusCheckO
 = 
REQ_STATUS_CHECK_OPT_NONE
;

695 
	`V2FEToggMode
(&
chCReg
[
chNo
], 
wayNo
, 
TEMPORARY_PAY_LOAD_ADDR
);

698 
	`as
(!"[WARNING]ot definedandeq [WARNING]");

700 
	}
}

702 
	$GeNdRowAddr
(
qSlTag
)

704 
rowAddr
, 
lun
, 
vtuBlockNo
, 
mpBlockNo
, 
phyBlockNo
, 
mpPageNo
, 
dNo
;

706 if(
qPoP
->
qPo
[
qSlTag
].
qO
.
ndAddr
 =
REQ_OPT_NAND_ADDR_VSA
)

708 
dNo
 = 
	`V2VdTni
(
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
vtuSliAddr
);

709 
vtuBlockNo
 = 
	`V2VblockTni
(
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
vtuSliAddr
);

710 
phyBlockNo
 = 
	`Vblock2PblockOfTbsTni
(
vtuBlockNo
);

711 
lun
 = 
phyBlockNo
 / 
TOTAL_BLOCKS_PER_LUN
;

712 
mpBlockNo
 = 
phyBlockMP
->
phyBlock
[
dNo
][
phyBlockNo
].
mdPhyBlock
 % 
TOTAL_BLOCKS_PER_LUN
;

713 
mpPageNo
 = 
	`V2VgeTni
(
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
vtuSliAddr
);

718 if(
qPoP
->
qPo
[
qSlTag
].
qO
.
ndAddr
 =
REQ_OPT_NAND_ADDR_PHY_ORG
)

720 
dNo
 = 
	`Pcw2VdTni
(
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
physilCh
,eqPoP->qPo[qSlTag].ndInfo.
physilWay
);

721 if(
qPoP
->
qPo
[
qSlTag
].
qO
.
blockS
 =
REQ_OPT_BLOCK_SPACE_TOTAL
)

723 
lun
 = 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
physilBlock
 / 
TOTAL_BLOCKS_PER_LUN
;

725 
mpBlockNo
 = 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
physilBlock
 % 
TOTAL_BLOCKS_PER_LUN
;

726 
mpPageNo
 = 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
physilPage
;

728 if(
qPoP
->
qPo
[
qSlTag
].
qO
.
blockS
 =
REQ_OPT_BLOCK_SPACE_MAIN
)

730 
lun
 = 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
physilBlock
 / 
MAIN_BLOCKS_PER_LUN
;

731 
mpBlockNo
 = 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
physilBlock
 % 
MAIN_BLOCKS_PER_LUN
 + 
lun
 * 
TOTAL_BLOCKS_PER_LUN
;

734 
mpBlockNo
 = 
phyBlockMP
->
phyBlock
[
dNo
][mpBlockNo].
mdPhyBlock
 % 
TOTAL_BLOCKS_PER_LUN
;

735 
mpPageNo
 = 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
physilPage
;

739 
	`as
(!"[WARNING] wrongandddr option [WARNING]");

741 if(
lun
 == 0)

742 
rowAddr
 = 
LUN_0_BASE_ADDR
 + 
mpBlockNo
 * 
PAGES_PER_MLC_BLOCK
 + 
mpPageNo
;

744 
rowAddr
 = 
LUN_1_BASE_ADDR
 + 
mpBlockNo
 * 
PAGES_PER_MLC_BLOCK
 + 
mpPageNo
;

746  
rowAddr
;

747 
	}
}

749 
	$GeDaBufAddr
(
qSlTag
)

751 if(
qPoP
->
qPo
[
qSlTag
].
qTy
 =
REQ_TYPE_NAND
)

753 if(
qPoP
->
qPo
[
qSlTag
].
qO
.
daBufFm
 =
REQ_OPT_DATA_BUF_ENTRY
)

754  (
DATA_BUFFER_BASE_ADDR
 + 
qPoP
->
qPo
[
qSlTag
].
daBufInfo
.
y
 * 
BYTES_PER_DATA_REGION_OF_SLICE_FOR_DATA_BUFFER
);

755 if(
qPoP
->
qPo
[
qSlTag
].
qO
.
daBufFm
 =
REQ_OPT_DATA_BUF_TEMP_ENTRY
)

756  (
TEMPORARY_DATA_BUFFER_BASE_ADDR
 + 
qPoP
->
qPo
[
qSlTag
].
daBufInfo
.
y
 * 
BYTES_PER_DATA_REGION_OF_SLICE_FOR_DATA_BUFFER
);

757 if(
qPoP
->
qPo
[
qSlTag
].
qO
.
daBufFm
 =
REQ_OPT_DATA_BUF_ADDR
)

758  
qPoP
->
qPo
[
qSlTag
].
daBufInfo
.
addr
;

760  
RESERVED_DATA_BUFFER_BASE_ADDR
;

762 if(
qPoP
->
qPo
[
qSlTag
].
qTy
 =
REQ_TYPE_NVME_DMA
)

764 if(
qPoP
->
qPo
[
qSlTag
].
qO
.
daBufFm
 =
REQ_OPT_DATA_BUF_ENTRY
)

765  (
DATA_BUFFER_BASE_ADDR
 + 
qPoP
->
qPo
[
qSlTag
].
daBufInfo
.
y
 * 
BYTES_PER_DATA_REGION_OF_SLICE
 +eqPoP->qPo[qSlTag].
nvmeDmaInfo
.
nvmeBlockOfft
 * 
BYTES_PER_NVME_BLOCK
);

767 
	`as
(!"[WARNING] wrongeqOpt-dataBufFormat [WARNING]");

770 
	`as
(!"[WARNING] wrongeqType [WARNING]");

772 
	}
}

774 
	$GeSDaBufAddr
(
qSlTag
)

776 if(
qPoP
->
qPo
[
qSlTag
].
qTy
 =
REQ_TYPE_NAND
)

778 if(
qPoP
->
qPo
[
qSlTag
].
qO
.
daBufFm
 =
REQ_OPT_DATA_BUF_ENTRY
)

779  (
SPARE_DATA_BUFFER_BASE_ADDR
 + 
qPoP
->
qPo
[
qSlTag
].
daBufInfo
.
y
 * 
BYTES_PER_SPARE_REGION_OF_SLICE
);

780 if(
qPoP
->
qPo
[
qSlTag
].
qO
.
daBufFm
 =
REQ_OPT_DATA_BUF_TEMP_ENTRY
)

781  (
TEMPORARY_SPARE_DATA_BUFFER_BASE_ADDR
 + 
qPoP
->
qPo
[
qSlTag
].
daBufInfo
.
y
 * 
BYTES_PER_SPARE_REGION_OF_SLICE
);

782 if(
qPoP
->
qPo
[
qSlTag
].
qO
.
daBufFm
 =
REQ_OPT_DATA_BUF_ADDR
)

783  (
qPoP
->
qPo
[
qSlTag
].
daBufInfo
.
addr
 + 
BYTES_PER_DATA_REGION_OF_SLICE
);

785  (
RESERVED_DATA_BUFFER_BASE_ADDR
 + 
BYTES_PER_DATA_REGION_OF_SLICE
);

787 if(
qPoP
->
qPo
[
qSlTag
].
qTy
 =
REQ_TYPE_NVME_DMA
)

789 if(
qPoP
->
qPo
[
qSlTag
].
qO
.
daBufFm
 =
REQ_OPT_DATA_BUF_ENTRY
)

790  (
SPARE_DATA_BUFFER_BASE_ADDR
 + 
qPoP
->
qPo
[
qSlTag
].
daBufInfo
.
y
 * 
BYTES_PER_SPARE_REGION_OF_SLICE
);

792 
	`as
(!"[WARNING] wrongeqOpt-dataBufFormat [WARNING]");

795 
	`as
(!"[WARNING] wrongeqType [WARNING]");

797 
	}
}

800 
	$CheckReqStus
(
chNo
, 
wayNo
)

802 
qSlTag
, 
comeFg
, 
usRt
, 
rInfo
, 
adyBusy
, 
us
;

803 * 
usRtP
;

805 
qSlTag
 = 
ndReqQ
[
chNo
][
wayNo
].
hdReq
;

806 if(
dSTabP
->
dS
[
chNo
][
wayNo
].
qStusCheckO
 =
REQ_STATUS_CHECK_OPT_COMPLETION_FLAG
)

808 
comeFg
 = 
comeFgTabP
->comeFg[
chNo
][
wayNo
];

810 if(
	`V2FTnsrCome
(
comeFg
))

812 if(
qPoP
->
qPo
[
qSlTag
].
qO
.
ndEcc
 =
REQ_OPT_NAND_ECC_ON
)

814 
rInfo
 = 
	`CheckEccEInfo
(
chNo
, 
wayNo
);

816 i(
rInfo
 =
ERROR_INFO_WARNING
)

817  
REQ_STATUS_WARNING
;

818 i(
rInfo
 =
ERROR_INFO_FAIL
)

819  
REQ_STATUS_FAIL
;

821  
REQ_STATUS_DONE
;

824 if(
dSTabP
->
dS
[
chNo
][
wayNo
].
qStusCheckO
 =
REQ_STATUS_CHECK_OPT_CHECK
)

826 
usRtP
 = (*)(&
usRtTabP
->
usRt
[
chNo
][
wayNo
]);

828 
	`V2FStusCheckAsync
(&
chCReg
[
chNo
], 
wayNo
, 
usRtP
);

830 
dSTabP
->
dS
[
chNo
][
wayNo
].
qStusCheckO
 = 
REQ_STATUS_CHECK_OPT_REPORT
;

832 if(
dSTabP
->
dS
[
chNo
][
wayNo
].
qStusCheckO
 =
REQ_STATUS_CHECK_OPT_REPORT
)

834 
usRt
 = 
usRtTabP
->usRt[
chNo
][
wayNo
];

836 if(
	`V2FRequeRtDe
(
usRt
))

838 
us
 = 
	`V2FElimeRtDeFg
(
usRt
);

839 if(
	`V2FRequeCome
(
us
))

841 i(
	`V2FRequeFa
(
us
))

842  
REQ_STATUS_FAIL
;

844 
dSTabP
->
dS
[
chNo
][
wayNo
].
qStusCheckO
 = 
REQ_STATUS_CHECK_OPT_NONE
;

845  
REQ_STATUS_DONE
;

848 
dSTabP
->
dS
[
chNo
][
wayNo
].
qStusCheckO
 = 
REQ_STATUS_CHECK_OPT_CHECK
;

851 if(
dSTabP
->
dS
[
chNo
][
wayNo
].
qStusCheckO
 =
REQ_STATUS_CHECK_OPT_NONE
)

853 
adyBusy
 = 
	`V2FRdyBusyAsync
(&
chCReg
[
chNo
]);

855 if(
	`V2FWayRdy
(
adyBusy
, 
wayNo
))

856  
REQ_STATUS_DONE
;

859 
	`as
(!"[WARNING] wrongequest status check option [WARNING]");

861  
REQ_STATUS_RUNNING
;

862 
	}
}

864 
	$CheckEccEInfo
(
chNo
, 
wayNo
)

866 
rInfo0
, 
rInfo1
, 
qSlTag
;

868 
qSlTag
 = 
ndReqQ
[
chNo
][
wayNo
].
hdReq
;

870 
rInfo0
 = 
eccEInfoTabP
->
rInfo
[
chNo
][
wayNo
][0];

871 
rInfo1
 = 
eccEInfoTabP
->
rInfo
[
chNo
][
wayNo
][1];

873 i(
	`V2FCrcVid
(
eccEInfoTabP
->
rInfo
[
chNo
][
wayNo
]))

876 if(
qPoP
->
qPo
[
qSlTag
].
qO
.
ndEccWng
 =
REQ_OPT_NAND_ECC_WARNING_ON
)

877 if(
	`V2FWܡChunkECou
(&
rInfo0
)> 
BIT_ERROR_THRESHOLD_PER_CHUNK
)

878  
ERROR_INFO_WARNING
;

880  
ERROR_INFO_PASS
;

883  
ERROR_INFO_FAIL
;

884 
	}
}

886 
	$ExecuNdReq
(
chNo
, 
wayNo
, 
qStus
)

888 
qSlTag
, 
rowAddr
, 
phyBlockNo
;

889 * 
badCheck
 ;

891 
qSlTag
 = 
ndReqQ
[
chNo
][
wayNo
].
hdReq
;

893 
dSTabP
->
dS
[
chNo
][
wayNo
].dieState)

895 
DIE_STATE_IDLE
:

896 
	`IssueNdReq
(
chNo
, 
wayNo
);

897 
dSTabP
->
dS
[
chNo
][
wayNo
].dS = 
DIE_STATE_EXE
;

899 
DIE_STATE_EXE
:

900 if(
qStus
 =
REQ_STATUS_DONE
)

902 if(
qPoP
->
qPo
[
qSlTag
].
qCode
 =
REQ_CODE_READ
)

903 
qPoP
->
qPo
[
qSlTag
].
qCode
 = 
REQ_CODE_READ_TRANSFER
;

906 
yLimTabP
->
yLim
[
chNo
][
wayNo
] = 
RETRY_LIMIT
;

907 
	`GFromNdReqQ
(
chNo
, 
wayNo
, 
qStus
, 
qPoP
->
qPo
[
qSlTag
].
qCode
);

910 
dSTabP
->
dS
[
chNo
][
wayNo
].dS = 
DIE_STATE_IDLE
;

912 if(
qStus
 =
REQ_STATUS_FAIL
)

914 if((
qPoP
->
qPo
[
qSlTag
].
qCode
 =
REQ_CODE_READ
|| (qPoP->qPo[qSlTag].qCod=
REQ_CODE_READ_TRANSFER
))

915 if(
yLimTabP
->
yLim
[
chNo
][
wayNo
] > 0)

917 
yLimTabP
->
yLim
[
chNo
][
wayNo
]--;

919 if(
qPoP
->
qPo
[
qSlTag
].
qCode
 =
REQ_CODE_READ_TRANSFER
)

920 
qPoP
->
qPo
[
qSlTag
].
qCode
 = 
REQ_CODE_READ
;

922 
dSTabP
->
dS
[
chNo
][
wayNo
].dS = 
DIE_STATE_IDLE
;

937 
rowAddr
 = 
	`GeNdRowAddr
(
qSlTag
);

939 if(
qPoP
->
qPo
[
qSlTag
].
qO
.
ndEcc
 =
REQ_OPT_NAND_ECC_OFF
)

940 if(
qPoP
->
qPo
[
qSlTag
].
qO
.
daBufFm
 =
REQ_OPT_DATA_BUF_ADDR
)

943 
badCheck
 = (*)
qPoP
->
qPo
[
qSlTag
].
daBufInfo
.
addr
;

944 *
badCheck
 = 
PSEUDO_BAD_BLOCK_MARK
;

948 
phyBlockNo
 = ((
rowAddr
 % 
LUN_1_BASE_ADDR
/ 
PAGES_PER_MLC_BLOCK
+ (owAdd/ LUN_1_BASE_ADDR)* 
TOTAL_BLOCKS_PER_LUN
);

949 
	`UpdePhyBlockMFGrownBadBlock
(
	`Pcw2VdTni
(
chNo
, 
wayNo
), 
phyBlockNo
);

951 
yLimTabP
->
yLim
[
chNo
][
wayNo
] = 
RETRY_LIMIT
;

952 
	`GFromNdReqQ
(
chNo
, 
wayNo
, 
qStus
, 
qPoP
->
qPo
[
qSlTag
].
qCode
);

953 
dSTabP
->
dS
[
chNo
][
wayNo
].dS = 
DIE_STATE_IDLE
;

955 if(
qStus
 =
REQ_STATUS_WARNING
)

957 
rowAddr
 = 
	`GeNdRowAddr
(
qSlTag
);

961 
phyBlockNo
 = ((
rowAddr
 % 
LUN_1_BASE_ADDR
/ 
PAGES_PER_MLC_BLOCK
+ (owAdd/ LUN_1_BASE_ADDR)* 
TOTAL_BLOCKS_PER_LUN
);

962 
	`UpdePhyBlockMFGrownBadBlock
(
	`Pcw2VdTni
(
chNo
, 
wayNo
), 
phyBlockNo
);

964 
yLimTabP
->
yLim
[
chNo
][
wayNo
] = 
RETRY_LIMIT
;

965 
	`GFromNdReqQ
(
chNo
, 
wayNo
, 
qStus
, 
qPoP
->
qPo
[
qSlTag
].
qCode
);

966 
dSTabP
->
dS
[
chNo
][
wayNo
].dS = 
DIE_STATE_IDLE
;

968 if(
qStus
 =
REQ_STATUS_RUNNING
)

971 
	`as
(!"[WARNING] wrongeq status [WARNING]");

974 
	}
}

	@request_schedule.h

48 #ide
REQUEST_SCHEDULE_H_


49 
	#REQUEST_SCHEDULE_H_


	)

51 
	~"l_cfig.h
"

53 
	#WAY_NONE
 0xF

	)

55 
	#LUN_0_BASE_ADDR
 0x00000000

	)

56 
	#LUN_1_BASE_ADDR
 0x00100000

	)

58 
	#PSEUDO_BAD_BLOCK_MARK
 0

	)

60 
	#RETRY_LIMIT
 5

61 

	)

62 
	#DIE_STATE_IDLE
 0

	)

63 
	#DIE_STATE_EXE
 1

	)

65 
	#REQ_STATUS_CHECK_OPT_NONE
 0

	)

66 
	#REQ_STATUS_CHECK_OPT_CHECK
 1

	)

67 
	#REQ_STATUS_CHECK_OPT_REPORT
 2

	)

68 
	#REQ_STATUS_CHECK_OPT_COMPLETION_FLAG
 3

	)

70 
	#REQ_STATUS_RUNNING
 0

	)

71 
	#REQ_STATUS_DONE
 1

	)

72 
	#REQ_STATUS_FAIL
 2

	)

73 
	#REQ_STATUS_WARNING
 3

	)

75 
	#ERROR_INFO_FAIL
 0

	)

76 
	#ERROR_INFO_PASS
 1

	)

77 
	#ERROR_INFO_WARNING
 2

	)

80 
	s_COMPLETE_FLAG_TABLE
 {

81 
	mcomeFg
[
USER_CHANNELS
][
USER_WAYS
];

82 } 
	tCOMPLETE_FLAG_TABLE
, *
	tP_COMPLETE_FLAG_TABLE
;

84 
	s_STATUS_REPORT_TABLE
 {

85 
	musRt
[
USER_CHANNELS
][
USER_WAYS
];

86 } 
	tSTATUS_REPORT_TABLE
, *
	tP_STATUS_REPORT_TABLE
;

88 
	s_ERROR_INFO_TABLE
 {

89 
	mrInfo
[
USER_CHANNELS
][
USER_WAYS
][
ERROR_INFO_WORD_COUNT
];

90 } 
	tERROR_INFO_TABLE
, *
	tP_ERROR_INFO_TABLE
;

92 
	s_RETRY_LIMIT_TABLE
 {

93 
	myLim
[
USER_CHANNELS
][
USER_WAYS
];

94 } 
	tRETRY_LIMIT_TABLE
, *
	tP_RETRY_LIMIT_TABLE
;

96 
	s_DIE_STATE_ENTRY
 {

97 
	mdS
 : 8;

98 
	mqStusCheckO
 : 4;

99 
	mevWay
 : 4;

100 
	mxtWay
 : 4;

101 
	mrved
 : 12;

102 } 
	tDIE_STATE_ENTRY
, *
	tP_DIE_STATE_ENTRY
;

104 
	s_DIE_STATE_TABLE
 {

105 
DIE_STATE_ENTRY
 
	mdS
[
USER_CHANNELS
][
USER_WAYS
];

106 } 
	tDIE_STATE_TABLE
, *
	tP_DIE_STATE_TABLE
;

109 
	s_WAY_PRIORITY_ENTRY
 {

110 
	midHd
 : 4;

111 
	midTa
 : 4;

112 
	musRtHd
 : 4;

113 
	musRtTa
 : 4;

114 
	madTriggHd
 : 4;

115 
	madTriggTa
 : 4;

116 
	mwreHd
 : 4;

117 
	mwreTa
 : 4;

118 
	madTnsrHd
 : 4;

119 
	madTnsrTa
 : 4;

120 
	maHd
 : 4;

121 
	maTa
 : 4;

122 
	musCheckHd
 : 4;

123 
	musCheckTa
 : 4;

124 
	mrved
 : 8;

125 } 
	tWAY_PRIORITY_ENTRY
, *
	tP_WAY_PRIORITY_ENTRY
;

127 
	s_WAY_PRIORITY_TABLE
 {

128 
WAY_PRIORITY_ENTRY
 
	mwayPriܙy
[
USER_CHANNELS
];

129 } 
	tWAY_PRIORITY_TABLE
, *
	tP_WAY_PRIORITY_TABLE
;

132 
InReqSchedur
();

134 
SyncALowLevReqDe
();

135 
SyncAvaFeReq
();

136 
SyncREReq
(
chNo
, 
wayNo
, 
blockNo
);

137 
SchedulgNdReq
();

138 
SchedulgNdReqPCh
(
chNo
);

140 
PutToNdWayPriܙyTab
(
qSlTag
, 
chNo
, 
wayNo
);

141 
PutToNdIdLi
(
chNo
, 
wayNo
);

142 
SeivGFromNdIdLi
(
chNo
, 
wayNo
);

143 
PutToNdStusRtLi
(
chNo
, 
wayNo
);

144 
SeivGFromNdStusRtLi
(
chNo
, 
wayNo
);

145 
PutToNdRdTriggLi
(
chNo
, 
wayNo
);

146 
SeiveGFromNdRdTriggLi
(
chNo
, 
wayNo
);

147 
PutToNdWreLi
(
chNo
, 
wayNo
);

148 
SeiveGFromNdWreLi
(
chNo
, 
wayNo
);

149 
PutToNdRdTnsrLi
(
chNo
, 
wayNo
);

150 
SeiveGFromNdRdTnsrLi
(
chNo
, 
wayNo
);

151 
PutToNdELi
(
chNo
, 
wayNo
);

152 
SeiveGFromNdELi
(
chNo
, 
wayNo
);

153 
PutToNdStusCheckLi
(
chNo
, 
wayNo
);

154 
SeiveGFromNdStusCheckLi
(
chNo
, 
wayNo
);

156 
IssueNdReq
(
chNo
, 
wayNo
);

157 
GeNdRowAddr
(
qSlTag
);

158 
GeDaBufAddr
(
qSlTag
);

159 
GeSDaBufAddr
(
qSlTag
);

160 
CheckReqStus
(
chNo
, 
wayNo
);

161 
CheckEccEInfo
(
chNo
, 
wayNo
);

163 
ExecuNdReq
(
chNo
, 
wayNo
, 
qStus
);

166 
P_COMPLETE_FLAG_TABLE
 
comeFgTabP
;

167 
P_STATUS_REPORT_TABLE
 
usRtTabP
;

168 
P_ERROR_INFO_TABLE
 
eccEInfoTabP
;

169 
P_RETRY_LIMIT_TABLE
 
yLimTabP
;

170 
P_DIE_STATE_TABLE
 
dStusTabP
;

171 
P_WAY_PRIORITY_TABLE
 
wayPriܙyTabP
;

	@request_transform.c

50 
	~"x_tf.h
"

51 
	~<as.h
>

52 
	~"nvme/nvme.h
"

53 
	~"nvme/ho_d.h
"

54 
	~"memy_m.h
"

55 
	~"l_cfig.h
"

57 
P_ROW_ADDR_DEPENDENCY_TABLE
 
	growAddrDdcyTabP
;

59 
	$InDdcyTab
()

61 
blockNo
, 
wayNo
, 
chNo
;

62 
rowAddrDdcyTabP
 = (
P_ROW_ADDR_DEPENDENCY_TABLE
)
ROW_ADDR_DEPENDENCY_TABLE_ADDR
;

64 
blockNo
=0 ; blockNo<
MAIN_BLOCKS_PER_DIE
 ; blockNo++)

66 
wayNo
=0 ; wayNo<
USER_WAYS
 ; wayNo++)

68 
chNo
=0 ; chNo<
USER_CHANNELS
 ; chNo++)

70 
rowAddrDdcyTabP
->
block
[
chNo
][
wayNo
][
blockNo
].
rmdProgPage
 = 0;

71 
rowAddrDdcyTabP
->
block
[
chNo
][
wayNo
][
blockNo
].
blockedRdReqC
 = 0;

72 
rowAddrDdcyTabP
->
block
[
chNo
][
wayNo
][
blockNo
].
blockedEReqFg
 = 0;

76 
	}
}

78 
	$ReqTnsNvmeToSli
(
cmdSlTag
, 
qID
, 
cID
, 
tLba
, 
b
, 
cmdCode
, 
fua
)

80 
qSlTag
, 
queedNvmeBlock
, 
mpNumOfNvmeBlock
, 
sCou
, 
mpL
, 
lo
, 
nvmeBlockOfft
, 
nvmeDmaSIndex
, 
qCode
;

83 if(
NVME_BLOCKS_PER_SLICE
 == 4)

85 
	`as
(0);

87 
queedNvmeBlock
 = 
b
 + 1;

88 
sCou
 = 0;

89 
nvmeDmaSIndex
 = 0;

90 
mpL
 = 
tLba
 / 
NVME_BLOCKS_PER_SLICE
;

91 
lo
 = ((
tLba
 % 
NVME_BLOCKS_PER_SLICE
+ 
queedNvmeBlock
) / NVME_BLOCKS_PER_SLICE;

93 if(
cmdCode
 =
IO_NVM_WRITE
)

94 
qCode
 = 
REQ_CODE_WRITE
;

95 if(
cmdCode
 =
IO_NVM_READ
)

96 
qCode
 = 
REQ_CODE_READ
;

98 
	`as
(!"[WARNING] Not supported command code [WARNING]");

100 #i(
PRINT_DEBUG_MSG_FUA
 == 1)

101 if(
fua
 =
REQ_OPT_FORCE_UNIT_ACCESS_ON
)

103 if(
qCode
 =
REQ_CODE_WRITE
)

104 
	`x_tf
("IO CMD FUA WrcmdSlTag %d SLb%d NvmeBlock %d\r\n", 
cmdSlTag
, 
tLba
, 
queedNvmeBlock
);

105 if(
qCode
 =
REQ_CODE_READ
)

106 
	`x_tf
("IO CMD FUA Rd cmdSlTag %d SLb%d NvmeBlock %d\r\n", 
cmdSlTag
, 
tLba
, 
queedNvmeBlock
);

108 
	`as
(!"[WARNING] Not supported command code [WARNING]");

112 if(
qCode
 =
REQ_CODE_WRITE
)

113 
	`x_tf
("IO CMD WrcmdSlTag %d SLb%d NvmeBlock %d\r\n", 
cmdSlTag
, 
tLba
, 
queedNvmeBlock
);

114 if(
qCode
 =
REQ_CODE_READ
)

115 
	`x_tf
("IO CMD Rd cmdSlTag %d SLb%d NvmeBlock %d\r\n", 
cmdSlTag
, 
tLba
, 
queedNvmeBlock
);

117 
	`as
(!"[WARNING] Not supported command code [WARNING]");

122 
nvmeBlockOfft
 = (
tLba
 % 
NVME_BLOCKS_PER_SLICE
);

123 if(
lo
)

124 
mpNumOfNvmeBlock
 = 
NVME_BLOCKS_PER_SLICE
 - 
nvmeBlockOfft
;

126 
mpNumOfNvmeBlock
 = 
queedNvmeBlock
;

128 
qSlTag
 = 
	`GFromFeReqQ
();

130 
qPoP
->
qPo
[
qSlTag
].
qTy
 = 
REQ_TYPE_SLICE
;

131 
qPoP
->
qPo
[
qSlTag
].
qCode
 =eqCode;

132 
qPoP
->
qPo
[
qSlTag
].
nvmeCmdSlTag
 = 
cmdSlTag
;

133 
qPoP
->
qPo
[
qSlTag
].
qID
 = qID;

134 
qPoP
->
qPo
[
qSlTag
].
cID
 = cID;

135 
qPoP
->
qPo
[
qSlTag
].
logilSliAddr
 = 
mpL
;

136 
qPoP
->
qPo
[
qSlTag
].
nvmeDmaInfo
.
tIndex
 = 
nvmeDmaSIndex
;

137 
qPoP
->
qPo
[
qSlTag
].
nvmeDmaInfo
.
nvmeBlockOfft
 =vmeBlockOffset;

138 
qPoP
->
qPo
[
qSlTag
].
nvmeDmaInfo
.
numOfNvmeBlock
 = 
mpNumOfNvmeBlock
;

139 
qPoP
->
qPo
[
qSlTag
].
nvmeDmaInfo
.
issuedFg
 = 
REQ_INFO_ISSUED_FLAG_OFF
;

140 
qPoP
->
qPo
[
qSlTag
].
qO
.
fUnAcss
 = 
fua
;

142 
	`PutToSliReqQ
(
qSlTag
);

144 
mpL
++;

145 
sCou
++;

146 
nvmeDmaSIndex
 +
mpNumOfNvmeBlock
;

148 if(
cmdCode
 =
IO_NVM_WRITE
) {

149 
g_l_num_ho_wre
++;

153 
sCou
 < 
lo
)

155 
nvmeBlockOfft
 = 0;

156 
mpNumOfNvmeBlock
 = 
NVME_BLOCKS_PER_SLICE
;

158 
qSlTag
 = 
	`GFromFeReqQ
();

160 
qPoP
->
qPo
[
qSlTag
].
qTy
 = 
REQ_TYPE_SLICE
;

161 
qPoP
->
qPo
[
qSlTag
].
qCode
 =eqCode;

162 
qPoP
->
qPo
[
qSlTag
].
nvmeCmdSlTag
 = 
cmdSlTag
;

163 
qPoP
->
qPo
[
qSlTag
].
qID
 = qID;

164 
qPoP
->
qPo
[
qSlTag
].
cID
 = cID;

165 
qPoP
->
qPo
[
qSlTag
].
logilSliAddr
 = 
mpL
;

166 
qPoP
->
qPo
[
qSlTag
].
nvmeDmaInfo
.
tIndex
 = 
nvmeDmaSIndex
;

167 
qPoP
->
qPo
[
qSlTag
].
nvmeDmaInfo
.
nvmeBlockOfft
 =vmeBlockOffset;

168 
qPoP
->
qPo
[
qSlTag
].
nvmeDmaInfo
.
numOfNvmeBlock
 = 
mpNumOfNvmeBlock
;

169 
qPoP
->
qPo
[
qSlTag
].
nvmeDmaInfo
.
issuedFg
 = 
REQ_INFO_ISSUED_FLAG_OFF
;

170 
qPoP
->
qPo
[
qSlTag
].
qO
.
fUnAcss
 = 
fua
;

172 
	`PutToSliReqQ
(
qSlTag
);

174 
mpL
++;

175 
sCou
++;

176 
nvmeDmaSIndex
 +
mpNumOfNvmeBlock
;

178 if(
cmdCode
 =
IO_NVM_WRITE
) {

179 
g_l_num_ho_wre
++;

184 
nvmeBlockOfft
 = 0;

185 
mpNumOfNvmeBlock
 = (
tLba
 + 
queedNvmeBlock
% 
NVME_BLOCKS_PER_SLICE
;

186 if((
mpNumOfNvmeBlock
 =0|| (
lo
 == 0))

189 
qSlTag
 = 
	`GFromFeReqQ
();

191 
qPoP
->
qPo
[
qSlTag
].
qTy
 = 
REQ_TYPE_SLICE
;

192 
qPoP
->
qPo
[
qSlTag
].
qCode
 =eqCode;

193 
qPoP
->
qPo
[
qSlTag
].
nvmeCmdSlTag
 = 
cmdSlTag
;

194 
qPoP
->
qPo
[
qSlTag
].
qID
 = qID;

195 
qPoP
->
qPo
[
qSlTag
].
cID
 = cID;

196 
qPoP
->
qPo
[
qSlTag
].
logilSliAddr
 = 
mpL
;

197 
qPoP
->
qPo
[
qSlTag
].
nvmeDmaInfo
.
tIndex
 = 
nvmeDmaSIndex
;

198 
qPoP
->
qPo
[
qSlTag
].
nvmeDmaInfo
.
nvmeBlockOfft
 =vmeBlockOffset;

199 
qPoP
->
qPo
[
qSlTag
].
nvmeDmaInfo
.
numOfNvmeBlock
 = 
mpNumOfNvmeBlock
;

200 
qPoP
->
qPo
[
qSlTag
].
nvmeDmaInfo
.
issuedFg
 = 
REQ_INFO_ISSUED_FLAG_OFF
;

201 
qPoP
->
qPo
[
qSlTag
].
qO
.
fUnAcss
 = 
fua
;

203 
	`PutToSliReqQ
(
qSlTag
);

205 if(
NVME_BLOCKS_PER_SLICE
 == 1)

207 
queedNvmeBlock
 = 
b
 + 1;

208 
nvmeDmaSIndex
 = 0;

209 
mpL
 = 
tLba
;

210 
lo
 = 
queedNvmeBlock
;

212 if(
cmdCode
 =
IO_NVM_WRITE
)

213 
qCode
 = 
REQ_CODE_WRITE
;

214 if(
cmdCode
 =
IO_NVM_READ
)

215 
qCode
 = 
REQ_CODE_READ
;

217 
	`as
(!"[WARNING] Not supported command code [WARNING]");

219 
sCou
 = 0;nsCou < 
lo
;ransCounter++)

221 
qSlTag
 = 
	`GFromFeReqQ
();

223 
qPoP
->
qPo
[
qSlTag
].
qTy
 = 
REQ_TYPE_SLICE
;

224 
qPoP
->
qPo
[
qSlTag
].
qCode
 =eqCode;

225 
qPoP
->
qPo
[
qSlTag
].
nvmeCmdSlTag
 = 
cmdSlTag
;

226 
qPoP
->
qPo
[
qSlTag
].
qID
 = qID;

227 
qPoP
->
qPo
[
qSlTag
].
cID
 = cID;

228 
qPoP
->
qPo
[
qSlTag
].
logilSliAddr
 = 
mpL
;

229 
qPoP
->
qPo
[
qSlTag
].
nvmeDmaInfo
.
tIndex
 = 
nvmeDmaSIndex
;

230 
qPoP
->
qPo
[
qSlTag
].
nvmeDmaInfo
.
nvmeBlockOfft
 = 0;

231 
qPoP
->
qPo
[
qSlTag
].
nvmeDmaInfo
.
numOfNvmeBlock
 = 1;

232 
qPoP
->
qPo
[
qSlTag
].
nvmeDmaInfo
.
issuedFg
 = 
REQ_INFO_ISSUED_FLAG_OFF
;

233 
qPoP
->
qPo
[
qSlTag
].
qO
.
fUnAcss
 = 
fua
;

235 
	`PutToSliReqQ
(
qSlTag
);

237 
mpL
++;

238 
nvmeDmaSIndex
++;

242 
	`as
(!"[WARNING] Not supported NVME_BLOCKS_PER_SLICE [WARNING]");

244 if(
cmdCode
 =
IO_NVM_WRITE
) {

245 
g_l_num_ho_wre
++;

247 
	}
}

249 
	$EviDaBufEry
(
igReqSlTag
)

251 
qSlTag
, 
vtuSliAddr
, 
daBufEry
;

253 
daBufEry
 = 
qPoP
->
qPo
[
igReqSlTag
].
daBufInfo
.
y
;

254 if(
daBufMP
->
daBuf
[
daBufEry
].
dty
 =
DATA_BUF_DIRTY
)

256 
qSlTag
 = 
	`GFromFeReqQ
();

257 
vtuSliAddr
 = 
	`AddrTnsWre
(
daBufMP
->
daBuf
[
daBufEry
].
logilSliAddr
);

259 
qPoP
->
qPo
[
qSlTag
].
qTy
 = 
REQ_TYPE_NAND
;

260 
qPoP
->
qPo
[
qSlTag
].
qCode
 = 
REQ_CODE_WRITE
;

261 
qPoP
->
qPo
[
qSlTag
].
nvmeCmdSlTag
 =eqPoP->qPo[
igReqSlTag
].nvmeCmdSlotTag;

262 
qPoP
->
qPo
[
qSlTag
].
qID
 =eqPoP->qPo[
igReqSlTag
].qID;

263 
qPoP
->
qPo
[
qSlTag
].
cID
 =eqPoP->qPo[
igReqSlTag
].cID;

264 
qPoP
->
qPo
[
qSlTag
].
logilSliAddr
 = 
daBufMP
->
daBuf
[
daBufEry
].logicalSliceAddr;

265 
qPoP
->
qPo
[
qSlTag
].
qO
.
daBufFm
 = 
REQ_OPT_DATA_BUF_ENTRY
;

266 
qPoP
->
qPo
[
qSlTag
].
qO
.
ndAddr
 = 
REQ_OPT_NAND_ADDR_VSA
;

267 
qPoP
->
qPo
[
qSlTag
].
qO
.
ndEcc
 = 
REQ_OPT_NAND_ECC_ON
;

268 
qPoP
->
qPo
[
qSlTag
].
qO
.
ndEccWng
 = 
REQ_OPT_NAND_ECC_WARNING_ON
;

269 
qPoP
->
qPo
[
qSlTag
].
qO
.
rowAddrDdcyCheck
 = 
REQ_OPT_ROW_ADDR_DEPENDENCY_CHECK
;

270 
qPoP
->
qPo
[
qSlTag
].
qO
.
blockS
 = 
REQ_OPT_BLOCK_SPACE_MAIN
;

271 
qPoP
->
qPo
[
qSlTag
].
qO
.
fUnAcss
 =eqPoP->qPo[
igReqSlTag
].reqOpt.forceUnitAccess;

273 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
vtuSliAddr
 = virtualSliceAddr;

274 
qPoP
->
qPo
[
qSlTag
].
daBufInfo
.
y
 = 
daBufEry
;

275 
	`UpdeDaBufEryInfoBlockgReq
(
daBufEry
, 
qSlTag
);

277 
	`SeLowLevReqQ
(
qSlTag
);

279 
daBufMP
->
daBuf
[
daBufEry
].
dty
 = 
DATA_BUF_CLEAN
;

281 
	}
}

283 
	$DaRdFromNd
(
igReqSlTag
)

285 
qSlTag
, 
vtuSliAddr
;

287 
vtuSliAddr
 = 
	`AddrTnsRd
(
qPoP
->
qPo
[
igReqSlTag
].
logilSliAddr
);

289 if(
vtuSliAddr
 !
VSA_FAIL
)

291 
qSlTag
 = 
	`GFromFeReqQ
();

293 
qPoP
->
qPo
[
qSlTag
].
qTy
 = 
REQ_TYPE_NAND
;

294 
qPoP
->
qPo
[
qSlTag
].
qCode
 = 
REQ_CODE_READ
;

295 
qPoP
->
qPo
[
qSlTag
].
nvmeCmdSlTag
 =eqPoP->qPo[
igReqSlTag
].nvmeCmdSlotTag;

296 
qPoP
->
qPo
[
qSlTag
].
qID
 =eqPoP->qPo[
igReqSlTag
].qID;

297 
qPoP
->
qPo
[
qSlTag
].
cID
 =eqPoP->qPo[
igReqSlTag
].cID;

298 
qPoP
->
qPo
[
qSlTag
].
logilSliAddr
 =eqPoP->qPo[
igReqSlTag
].logicalSliceAddr;

299 
qPoP
->
qPo
[
qSlTag
].
qO
.
daBufFm
 = 
REQ_OPT_DATA_BUF_ENTRY
;

300 
qPoP
->
qPo
[
qSlTag
].
qO
.
ndAddr
 = 
REQ_OPT_NAND_ADDR_VSA
;

301 
qPoP
->
qPo
[
qSlTag
].
qO
.
ndEcc
 = 
REQ_OPT_NAND_ECC_ON
;

302 
qPoP
->
qPo
[
qSlTag
].
qO
.
ndEccWng
 = 
REQ_OPT_NAND_ECC_WARNING_ON
;

303 
qPoP
->
qPo
[
qSlTag
].
qO
.
rowAddrDdcyCheck
 = 
REQ_OPT_ROW_ADDR_DEPENDENCY_CHECK
;

304 
qPoP
->
qPo
[
qSlTag
].
qO
.
blockS
 = 
REQ_OPT_BLOCK_SPACE_MAIN
;

305 
qPoP
->
qPo
[
qSlTag
].
qO
.
fUnAcss
 =eqPoP->qPo[
igReqSlTag
].reqOpt.forceUnitAccess;

307 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
vtuSliAddr
 = virtualSliceAddr;

308 
qPoP
->
qPo
[
qSlTag
].
daBufInfo
.
y
 =eqPoP->qPo[
igReqSlTag
].dataBufInfo.entry;

309 
	`UpdeDaBufEryInfoBlockgReq
(
qPoP
->
qPo
[
qSlTag
].
daBufInfo
.
y
,eqSlotTag);

311 
	`SeLowLevReqQ
(
qSlTag
);

313 
	}
}

316 
	$ReqTnsSliToLowLev
()

318 
qSlTag
, 
daBufEry
;

319 
nmBufEry
;

321 
iReqQ
.
hdReq
 !
REQ_SLOT_TAG_NONE
)

323 
qSlTag
 = 
	`GFromSliReqQ
();

324 if(
qSlTag
 =
REQ_SLOT_TAG_FAIL
)

327 
nmBufEry
 = 
	`CheckDaBufH
(
qSlTag
);

329 if(
nmBufEry
 !
DATA_BUF_FAIL
)

332 
daBufEry
 = 
	`AoDaBufH
(
qSlTag
);

334 if(
nmBufEry
 !
daBufEry
)

335 
	`as
("[WARNING] Wrong bufferllocation! [WARNING]\r\n");

336 
qPoP
->
qPo
[
qSlTag
].
daBufInfo
.
y
 = 
daBufEry
;

338 if(
qPoP
->
qPo
[
qSlTag
].
qO
.
fUnAcss
 =
REQ_OPT_FORCE_UNIT_ACCESS_ON
)

340 if(
qPoP
->
qPo
[
qSlTag
].
qCode
 =
REQ_CODE_READ
)

342 
	`EviDaBufEry
(
qSlTag
);

343 
	`DaRdFromNd
(
qSlTag
);

351 
daBufEry
 = 
	`AoDaBufMiss
();

352 
qPoP
->
qPo
[
qSlTag
].
daBufInfo
.
y
 = 
daBufEry
;

355 
	`EviDaBufEry
(
qSlTag
);

358 
daBufMP
->
daBuf
[
daBufEry
].
logilSliAddr
 = 
qPoP
->
qPo
[
qSlTag
].logicalSliceAddr;

359 
	`PutToDaBufHashLi
(
daBufEry
);

361 if(
qPoP
->
qPo
[
qSlTag
].
qCode
 =
REQ_CODE_READ
)

362 
	`DaRdFromNd
(
qSlTag
);

363 if(
qPoP
->
qPo
[
qSlTag
].
qCode
 =
REQ_CODE_WRITE
)

364 if(
qPoP
->
qPo
[
qSlTag
].
nvmeDmaInfo
.
numOfNvmeBlock
 !
NVME_BLOCKS_PER_SLICE
)

365 
	`DaRdFromNd
(
qSlTag
);

369 if(
qPoP
->
qPo
[
qSlTag
].
qCode
 =
REQ_CODE_WRITE
)

371 
daBufMP
->
daBuf
[
daBufEry
].
dty
 = 
DATA_BUF_DIRTY
;

372 
qPoP
->
qPo
[
qSlTag
].
qCode
 = 
REQ_CODE_RxDMA
;

374 if(
qPoP
->
qPo
[
qSlTag
].
qCode
 =
REQ_CODE_READ
)

375 
qPoP
->
qPo
[
qSlTag
].
qCode
 = 
REQ_CODE_TxDMA
;

377 
	`as
(!"[WARNING] Not supportedeqCode. [WARNING]");

379 
qPoP
->
qPo
[
qSlTag
].
qTy
 = 
REQ_TYPE_NVME_DMA
;

380 
qPoP
->
qPo
[
qSlTag
].
qO
.
daBufFm
 = 
REQ_OPT_DATA_BUF_ENTRY
;

382 
	`UpdeDaBufEryInfoBlockgReq
(
daBufEry
, 
qSlTag
);

385 if(
qPoP
->
qPo
[
qSlTag
].
qO
.
fUnAcss
 =
REQ_OPT_FORCE_UNIT_ACCESS_ON
)

387 
	`SFUANvmeIoCmd
(
qPoP
->
qPo
[
qSlTag
].
nvmeCmdSlTag
,eqSlTag,eqPoP->qPo[qSlTag].
qID
,eqPoP->qPo[qSlTag].
cID
);

388 if(
qPoP
->
qPo
[
qSlTag
].
qCode
 =
REQ_CODE_RxDMA
)

390 
	`AoNComedRxfNvmeIoCmd
(
qPoP
->
qPo
[
qSlTag
].
nvmeCmdSlTag
,eqPoP->qPo[qSlTag].
daBufInfo
.
y
, 
	`GeDaBufAddr
(reqSlotTag));

391 
	`AoNIssuedRxfNvmeIoCmd
(
qPoP
->
qPo
[
qSlTag
].
nvmeCmdSlTag
,eqPoP->qPo[qSlTag].
daBufInfo
.
y
, 
	`GeDaBufAddr
(reqSlotTag));

393 if(
qPoP
->
qPo
[
qSlTag
].
qCode
 =
REQ_CODE_TxDMA
)

395 
	`AoNComedTxfNvmeIoCmd
(
qPoP
->
qPo
[
qSlTag
].
nvmeCmdSlTag
,eqPoP->qPo[qSlTag].
daBufInfo
.
y
, 
	`GeDaBufAddr
(reqSlotTag));

396 
	`AoNIssuedTxfNvmeIoCmd
(
qPoP
->
qPo
[
qSlTag
].
nvmeCmdSlTag
,eqPoP->qPo[qSlTag].
daBufInfo
.
y
, 
	`GeDaBufAddr
(reqSlotTag));

400 if(
qPoP
->
qPo
[
qSlTag
].
qO
.
fUnAcss
 =
REQ_OPT_FORCE_UNIT_ACCESS_ON
)

402 if(
qPoP
->
qPo
[
qSlTag
].
qCode
 =
REQ_CODE_RxDMA
)

405 
	`EviDaBufEry
(
qSlTag
);

407 if(
qPoP
->
qPo
[
qSlTag
].
qCode
 =
REQ_CODE_TxDMA
)

413 
	`SeLowLevReqQ
(
qSlTag
);

415 
	}
}

417 
	$CheckBufD
(
qSlTag
)

419 if(
qPoP
->
qPo
[
qSlTag
].
evBlockgReq
 =
REQ_SLOT_TAG_NONE
)

420  
BUF_DEPENDENCY_REPORT_PASS
;

422  
BUF_DEPENDENCY_REPORT_BLOCKED
;

423 
	}
}

426 
	$CheckRowAddrD
(
qSlTag
, 
checkRowAddrDO
)

428 
dNo
,
chNo
, 
wayNo
, 
blockNo
, 
geNo
;

430 if(
qPoP
->
qPo
[
qSlTag
].
qO
.
ndAddr
 =
REQ_OPT_NAND_ADDR_VSA
)

432 
dNo
 = 
	`V2VdTni
(
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
vtuSliAddr
);

433 
chNo
 = 
	`Vd2PchTni
(
dNo
);

434 
wayNo
 = 
	`Vd2PwayTni
(
dNo
);

435 
blockNo
 = 
	`V2VblockTni
(
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
vtuSliAddr
);

436 
geNo
 = 
	`V2VgeTni
(
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
vtuSliAddr
);

439 
	`as
(!"[WARNING] Not supportedeqOpt-nandAddress [WARNING]");

441 if(
qPoP
->
qPo
[
qSlTag
].
qCode
 =
REQ_CODE_READ
)

443 if(
checkRowAddrDO
 =
ROW_ADDR_DEPENDENCY_CHECK_OPT_SELECT
)

445 if(
rowAddrDdcyTabP
->
block
[
chNo
][
wayNo
][
blockNo
].
blockedEReqFg
)

446 
	`SyncREReq
(
chNo
, 
wayNo
, 
blockNo
);

448 if(
geNo
 < 
rowAddrDdcyTabP
->
block
[
chNo
][
wayNo
][
blockNo
].
rmdProgPage
)

449  
ROW_ADDR_DEPENDENCY_REPORT_PASS
;

451 
rowAddrDdcyTabP
->
block
[
chNo
][
wayNo
][
blockNo
].
blockedRdReqC
++;

453 if(
checkRowAddrDO
 =
ROW_ADDR_DEPENDENCY_CHECK_OPT_RELEASE
)

455 if(
geNo
 < 
rowAddrDdcyTabP
->
block
[
chNo
][
wayNo
][
blockNo
].
rmdProgPage
)

457 
rowAddrDdcyTabP
->
block
[
chNo
][
wayNo
][
blockNo
].
blockedRdReqC
--;

458  
ROW_ADDR_DEPENDENCY_REPORT_PASS
;

462 
	`as
(!"[WARNING] Not supported checkRowAddrDepOpt [WARNING]");

464 if(
qPoP
->
qPo
[
qSlTag
].
qCode
 =
REQ_CODE_WRITE
)

466 if(
geNo
 =
rowAddrDdcyTabP
->
block
[
chNo
][
wayNo
][
blockNo
].
rmdProgPage
)

468 
rowAddrDdcyTabP
->
block
[
chNo
][
wayNo
][
blockNo
].
rmdProgPage
++;

470  
ROW_ADDR_DEPENDENCY_REPORT_PASS
;

473 if(
qPoP
->
qPo
[
qSlTag
].
qCode
 =
REQ_CODE_ERASE
)

475 if(
rowAddrDdcyTabP
->
block
[
chNo
][
wayNo
][
blockNo
].
rmdProgPage
 =
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
ogmmedPageC
)

476 if(
rowAddrDdcyTabP
->
block
[
chNo
][
wayNo
][
blockNo
].
blockedRdReqC
 == 0)

478 
rowAddrDdcyTabP
->
block
[
chNo
][
wayNo
][
blockNo
].
rmdProgPage
 = 0;

479 
rowAddrDdcyTabP
->
block
[
chNo
][
wayNo
][
blockNo
].
blockedEReqFg
 = 0;

481  
ROW_ADDR_DEPENDENCY_REPORT_PASS
;

484 if(
checkRowAddrDO
 =
ROW_ADDR_DEPENDENCY_CHECK_OPT_SELECT
)

485 
rowAddrDdcyTabP
->
block
[
chNo
][
wayNo
][
blockNo
].
blockedEReqFg
 = 1;

486 if(
checkRowAddrDO
 =
ROW_ADDR_DEPENDENCY_CHECK_OPT_RELEASE
)

491 
	`as
(!"[WARNING] Not supported checkRowAddrDepOpt [WARNING]");

494 
	`as
(!"[WARNING] Not supportedeqCode [WARNING]");

496  
ROW_ADDR_DEPENDENCY_REPORT_BLOCKED
;

497 
	}
}

500 
	$UpdeRowAddrDTabFBufBlockedReq
(
qSlTag
)

502 
dNo
, 
chNo
, 
wayNo
, 
blockNo
, 
geNo
, 
bufDCheckRt
;

504 if(
qPoP
->
qPo
[
qSlTag
].
qO
.
ndAddr
 =
REQ_OPT_NAND_ADDR_VSA
)

506 
dNo
 = 
	`V2VdTni
(
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
vtuSliAddr
);

507 
chNo
 = 
	`Vd2PchTni
(
dNo
);

508 
wayNo
 = 
	`Vd2PwayTni
(
dNo
);

509 
blockNo
 = 
	`V2VblockTni
(
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
vtuSliAddr
);

510 
geNo
 = 
	`V2VgeTni
(
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
vtuSliAddr
);

513 
	`as
(!"[WARNING] Not supportedeqOpt-nandAddress [WARNING]");

515 if(
qPoP
->
qPo
[
qSlTag
].
qCode
 =
REQ_CODE_READ
)

517 if(
rowAddrDdcyTabP
->
block
[
chNo
][
wayNo
][
blockNo
].
blockedEReqFg
)

519 
	`SyncREReq
(
chNo
, 
wayNo
, 
blockNo
);

521 
bufDCheckRt
 = 
	`CheckBufD
(
qSlTag
);

522 if(
bufDCheckRt
 =
BUF_DEPENDENCY_REPORT_PASS
)

524 if(
geNo
 < 
rowAddrDdcyTabP
->
block
[
chNo
][
wayNo
][
blockNo
].
rmdProgPage
)

525 
	`PutToNdReqQ
(
qSlTag
, 
chNo
, 
wayNo
);

528 
rowAddrDdcyTabP
->
block
[
chNo
][
wayNo
][
blockNo
].
blockedRdReqC
++;

529 
	`PutToBlockedByRowAddrDReqQ
(
qSlTag
, 
chNo
, 
wayNo
);

532  
ROW_ADDR_DEPENDENCY_TABLE_UPDATE_REPORT_SYNC
;

535 
rowAddrDdcyTabP
->
block
[
chNo
][
wayNo
][
blockNo
].
blockedRdReqC
++;

537 if(
qPoP
->
qPo
[
qSlTag
].
qCode
 =
REQ_CODE_ERASE
)

538 
rowAddrDdcyTabP
->
block
[
chNo
][
wayNo
][
blockNo
].
blockedEReqFg
 = 1;

540  
ROW_ADDR_DEPENDENCY_TABLE_UPDATE_REPORT_DONE
;

541 
	}
}

545 
	$SeLowLevReqQ
(
qSlTag
)

547 
dNo
, 
chNo
, 
wayNo
, 
bufDCheckRt
, 
rowAddrDCheckRt
, 
rowAddrDTabUpdeRt
;

549 
bufDCheckRt
 = 
	`CheckBufD
(
qSlTag
);

550 if(
bufDCheckRt
 =
BUF_DEPENDENCY_REPORT_PASS
)

552 if(
qPoP
->
qPo
[
qSlTag
].
qTy
 =
REQ_TYPE_NVME_DMA
)

554 
	`IssueNvmeDmaReq
(
qSlTag
);

555 
	`PutToNvmeDmaReqQ
(
qSlTag
);

557 if(
qPoP
->
qPo
[
qSlTag
].
qTy
 =
REQ_TYPE_NAND
)

559 if(
qPoP
->
qPo
[
qSlTag
].
qO
.
ndAddr
 =
REQ_OPT_NAND_ADDR_VSA
)

561 
dNo
 = 
	`V2VdTni
(
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
vtuSliAddr
);

562 
chNo
 = 
	`Vd2PchTni
(
dNo
);

563 
wayNo
 = 
	`Vd2PwayTni
(
dNo
);

565 if(
qPoP
->
qPo
[
qSlTag
].
qO
.
ndAddr
 =
REQ_OPT_NAND_ADDR_PHY_ORG
)

567 
chNo
 = 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
physilCh
;

568 
wayNo
 = 
qPoP
->
qPo
[
qSlTag
].
ndInfo
.
physilWay
;

571 
	`as
(!"[WARNING] Not supportedeqOpt-nandAddress [WARNING]");

573 if(
qPoP
->
qPo
[
qSlTag
].
qO
.
rowAddrDdcyCheck
 =
REQ_OPT_ROW_ADDR_DEPENDENCY_CHECK
)

575 
rowAddrDCheckRt
 = 
	`CheckRowAddrD
(
qSlTag
, 
ROW_ADDR_DEPENDENCY_CHECK_OPT_SELECT
);

577 if(
rowAddrDCheckRt
 =
ROW_ADDR_DEPENDENCY_REPORT_PASS
)

578 
	`PutToNdReqQ
(
qSlTag
, 
chNo
, 
wayNo
);

579 if(
rowAddrDCheckRt
 =
ROW_ADDR_DEPENDENCY_REPORT_BLOCKED
)

580 
	`PutToBlockedByRowAddrDReqQ
(
qSlTag
, 
chNo
, 
wayNo
);

582 
	`as
(!"[WARNING] Not supportedeport [WARNING]");

584 if(
qPoP
->
qPo
[
qSlTag
].
qO
.
rowAddrDdcyCheck
 =
REQ_OPT_ROW_ADDR_DEPENDENCY_NONE
)

585 
	`PutToNdReqQ
(
qSlTag
, 
chNo
, 
wayNo
);

587 
	`as
(!"[WARNING] Not supportedeqOpt [WARNING]");

591 
	`as
(!"[WARNING] Not supportedeqType [WARNING]");

593 if(
bufDCheckRt
 =
BUF_DEPENDENCY_REPORT_BLOCKED
)

595 if(
qPoP
->
qPo
[
qSlTag
].
qTy
 =
REQ_TYPE_NAND
)

596 if(
qPoP
->
qPo
[
qSlTag
].
qO
.
rowAddrDdcyCheck
 =
REQ_OPT_ROW_ADDR_DEPENDENCY_CHECK
)

598 
rowAddrDTabUpdeRt
 = 
	`UpdeRowAddrDTabFBufBlockedReq
(
qSlTag
);

600 if(
rowAddrDTabUpdeRt
 =
ROW_ADDR_DEPENDENCY_TABLE_UPDATE_REPORT_DONE
)

604 if(
rowAddrDTabUpdeRt
 =
ROW_ADDR_DEPENDENCY_TABLE_UPDATE_REPORT_SYNC
)

607 
	`as
(!"[WARNING] Not supportedeport [WARNING]");

610 
	`PutToBlockedByBufDReqQ
(
qSlTag
);

613 
	`as
(!"[WARNING] Not supportedeport [WARNING]");

614 
	}
}

617 
	$RBlockedByBufDReq
(
qSlTag
)

619 
rgReqSlTag
, 
dNo
, 
chNo
, 
wayNo
, 
rowAddrDCheckRt
;

621 
rgReqSlTag
 = 
REQ_SLOT_TAG_NONE
;

622 if(
qPoP
->
qPo
[
qSlTag
].
xtBlockgReq
 !
REQ_SLOT_TAG_NONE
)

624 
rgReqSlTag
 = 
qPoP
->
qPo
[
qSlTag
].
xtBlockgReq
;

625 
qPoP
->
qPo
[
rgReqSlTag
].
evBlockgReq
 = 
REQ_SLOT_TAG_NONE
;

626 
qPoP
->
qPo
[
qSlTag
].
xtBlockgReq
 = 
REQ_SLOT_TAG_NONE
;

629 if(
qPoP
->
qPo
[
qSlTag
].
qO
.
daBufFm
 =
REQ_OPT_DATA_BUF_ENTRY
)

631 if(
daBufMP
->
daBuf
[
qPoP
->
qPo
[
qSlTag
].
daBufInfo
.
y
].
blockgReqTa
 ==eqSlotTag)

632 
daBufMP
->
daBuf
[
qPoP
->
qPo
[
qSlTag
].
daBufInfo
.
y
].
blockgReqTa
 = 
REQ_SLOT_TAG_NONE
;

634 if(
qPoP
->
qPo
[
qSlTag
].
qO
.
daBufFm
 =
REQ_OPT_DATA_BUF_TEMP_ENTRY
)

636 if(
mpDaBufMP
->
mpDaBuf
[
qPoP
->
qPo
[
qSlTag
].
daBufInfo
.
y
].
blockgReqTa
 ==eqSlotTag)

637 
mpDaBufMP
->
mpDaBuf
[
qPoP
->
qPo
[
qSlTag
].
daBufInfo
.
y
].
blockgReqTa
 = 
REQ_SLOT_TAG_NONE
;

640 if((
rgReqSlTag
 !
REQ_SLOT_TAG_NONE
&& (
qPoP
->
qPo
[rgReqSlTag].
qQueueTy
 =
REQ_QUEUE_TYPE_BLOCKED_BY_BUF_DEP
))

642 
	`SeiveGFromBlockedByBufDReqQ
(
rgReqSlTag
);

644 if(
qPoP
->
qPo
[
rgReqSlTag
].
qTy
 =
REQ_TYPE_NVME_DMA
)

646 
	`IssueNvmeDmaReq
(
rgReqSlTag
);

647 
	`PutToNvmeDmaReqQ
(
rgReqSlTag
);

649 if(
qPoP
->
qPo
[
rgReqSlTag
].
qTy
 =
REQ_TYPE_NAND
)

651 if(
qPoP
->
qPo
[
rgReqSlTag
].
qO
.
ndAddr
 =
REQ_OPT_NAND_ADDR_VSA
)

653 
dNo
 = 
	`V2VdTni
(
qPoP
->
qPo
[
rgReqSlTag
].
ndInfo
.
vtuSliAddr
);

654 
chNo
 = 
	`Vd2PchTni
(
dNo
);

655 
wayNo
 = 
	`Vd2PwayTni
(
dNo
);

658 
	`as
(!"[WARNING] Not supportedeqOpt-nandAddress [WARNING]");

660 if(
qPoP
->
qPo
[
rgReqSlTag
].
qO
.
rowAddrDdcyCheck
 =
REQ_OPT_ROW_ADDR_DEPENDENCY_CHECK
)

662 
rowAddrDCheckRt
 = 
	`CheckRowAddrD
(
rgReqSlTag
, 
ROW_ADDR_DEPENDENCY_CHECK_OPT_RELEASE
);

664 if(
rowAddrDCheckRt
 =
ROW_ADDR_DEPENDENCY_REPORT_PASS
)

665 
	`PutToNdReqQ
(
rgReqSlTag
, 
chNo
, 
wayNo
);

666 if(
rowAddrDCheckRt
 =
ROW_ADDR_DEPENDENCY_REPORT_BLOCKED
)

667 
	`PutToBlockedByRowAddrDReqQ
(
rgReqSlTag
, 
chNo
, 
wayNo
);

669 
	`as
(!"[WARNING] Not supportedeport [WARNING]");

671 if(
qPoP
->
qPo
[
rgReqSlTag
].
qO
.
rowAddrDdcyCheck
 =
REQ_OPT_ROW_ADDR_DEPENDENCY_NONE
)

672 
	`PutToNdReqQ
(
rgReqSlTag
, 
chNo
, 
wayNo
);

674 
	`as
(!"[WARNING] Not supportedeqOpt [WARNING]");

677 
	}
}

680 
	$RBlockedByRowAddrDReq
(
chNo
, 
wayNo
)

682 
qSlTag
, 
xtReq
, 
rowAddrDCheckRt
;

684 
qSlTag
 = 
blockedByRowAddrDReqQ
[
chNo
][
wayNo
].
hdReq
;

686 
qSlTag
 !
REQ_SLOT_TAG_NONE
)

688 
xtReq
 = 
qPoP
->
qPo
[
qSlTag
].nextReq;

690 if(
qPoP
->
qPo
[
qSlTag
].
qO
.
rowAddrDdcyCheck
 =
REQ_OPT_ROW_ADDR_DEPENDENCY_CHECK
)

692 
rowAddrDCheckRt
 = 
	`CheckRowAddrD
(
qSlTag
, 
ROW_ADDR_DEPENDENCY_CHECK_OPT_RELEASE
);

694 if(
rowAddrDCheckRt
 =
ROW_ADDR_DEPENDENCY_REPORT_PASS
)

696 
	`SeiveGFromBlockedByRowAddrDReqQ
(
qSlTag
, 
chNo
, 
wayNo
);

697 
	`PutToNdReqQ
(
qSlTag
, 
chNo
, 
wayNo
);

699 if(
rowAddrDCheckRt
 =
ROW_ADDR_DEPENDENCY_REPORT_BLOCKED
)

704 
	`as
(!"[WARNING] Not supportedeport [WARNING]");

707 
	`as
(!"[WARNING] Not supportedeqOpt [WARNING]");

709 
qSlTag
 = 
xtReq
;

711 
	}
}

714 
	$IssueNvmeDmaReq
(
qSlTag
)

716 
devAddr
, 
dmaIndex
, 
numOfNvmeBlock
;

718 
dmaIndex
 = 
qPoP
->
qPo
[
qSlTag
].
nvmeDmaInfo
.
tIndex
;

719 
devAddr
 = 
	`GeDaBufAddr
(
qSlTag
);

720 
numOfNvmeBlock
 = 0;

722 if(
qPoP
->
qPo
[
qSlTag
].
qCode
 =
REQ_CODE_RxDMA
)

724 
numOfNvmeBlock
 < 
qPoP
->
qPo
[
qSlTag
].
nvmeDmaInfo
.numOfNvmeBlock)

726 
	`t_auto_rx_dma
(
qPoP
->
qPo
[
qSlTag
].
nvmeCmdSlTag
, 
dmaIndex
, 
devAddr
, 
NVME_COMMAND_AUTO_COMPLETION_ON
);

728 
numOfNvmeBlock
++;

729 
dmaIndex
++;

730 
devAddr
 +
BYTES_PER_NVME_BLOCK
;

732 
qPoP
->
qPo
[
qSlTag
].
nvmeDmaInfo
.
qTa
 = 
g_hoDmaStus
.
fifoTa
.
autoDmaRx
;

733 
qPoP
->
qPo
[
qSlTag
].
nvmeDmaInfo
.
ovFlowC
 = 
g_hoDmaAssiStus
.
autoDmaRxOvFlowC
;

735 if(
qPoP
->
qPo
[
qSlTag
].
qCode
 =
REQ_CODE_TxDMA
)

737 
numOfNvmeBlock
 < 
qPoP
->
qPo
[
qSlTag
].
nvmeDmaInfo
.numOfNvmeBlock)

739 
	`t_auto_tx_dma
(
qPoP
->
qPo
[
qSlTag
].
nvmeCmdSlTag
, 
dmaIndex
, 
devAddr
, 
NVME_COMMAND_AUTO_COMPLETION_ON
);

741 
numOfNvmeBlock
++;

742 
dmaIndex
++;

743 
devAddr
 +
BYTES_PER_NVME_BLOCK
;

745 
qPoP
->
qPo
[
qSlTag
].
nvmeDmaInfo
.
qTa
 = 
g_hoDmaStus
.
fifoTa
.
autoDmaTx
;

746 
qPoP
->
qPo
[
qSlTag
].
nvmeDmaInfo
.
ovFlowC
 = 
g_hoDmaAssiStus
.
autoDmaTxOvFlowC
;

749 
	`as
(!"[WARNING] Not supportedeqCode [WARNING]");

750 
	}
}

752 
	$CheckDeNvmeDmaReq
()

754 
qSlTag
, 
evReq
;

755 
rxDe
, 
txDe
;

757 
qSlTag
 = 
nvmeDmaReqQ
.
Req
;

758 
rxDe
 = 0;

759 
txDe
 = 0;

761 
qSlTag
 !
REQ_SLOT_TAG_NONE
)

763 
evReq
 = 
qPoP
->
qPo
[
qSlTag
].prevReq;

765 if(
qPoP
->
qPo
[
qSlTag
].
qCode
 =
REQ_CODE_RxDMA
)

767 if(!
rxDe
)

768 
rxDe
 = 
	`check_auto_rx_dma_l_de
(
qPoP
->
qPo
[
qSlTag
].
nvmeDmaInfo
.
qTa
 ,eqPoP->qPo[qSlTag].nvmeDmaInfo.
ovFlowC
);

770 if(
rxDe
)

771 
	`SeiveGFromNvmeDmaReqQ
(
qSlTag
);

775 if(!
txDe
)

776 
txDe
 = 
	`check_auto_tx_dma_l_de
(
qPoP
->
qPo
[
qSlTag
].
nvmeDmaInfo
.
qTa
 ,eqPoP->qPo[qSlTag].nvmeDmaInfo.
ovFlowC
);

778 if(
txDe
)

779 
	`SeiveGFromNvmeDmaReqQ
(
qSlTag
);

782 
qSlTag
 = 
evReq
;

784 
	}
}

	@request_transform.h

46 #ide
REQUEST_TRANSFORM_H_


47 
	#REQUEST_TRANSFORM_H_


	)

49 
	~"l_cfig.h
"

50 
	~"nvme/nvme.h
"

52 
	#NVME_COMMAND_AUTO_COMPLETION_OFF
 0

	)

53 
	#NVME_COMMAND_AUTO_COMPLETION_ON
 1

	)

55 
	#ROW_ADDR_DEPENDENCY_CHECK_OPT_SELECT
 0

	)

56 
	#ROW_ADDR_DEPENDENCY_CHECK_OPT_RELEASE
 1

	)

58 
	#BUF_DEPENDENCY_REPORT_BLOCKED
 0

	)

59 
	#BUF_DEPENDENCY_REPORT_PASS
 1

	)

61 
	#ROW_ADDR_DEPENDENCY_REPORT_BLOCKED
 0

	)

62 
	#ROW_ADDR_DEPENDENCY_REPORT_PASS
 1

	)

64 
	#ROW_ADDR_DEPENDENCY_TABLE_UPDATE_REPORT_DONE
 0

	)

65 
	#ROW_ADDR_DEPENDENCY_TABLE_UPDATE_REPORT_SYNC
 1

	)

68 
	s_ROW_ADDR_DEPENDENCY_ENTRY
 {

69 
	mrmdProgPage
 : 12;

70 
	mblockedRdReqC
 : 16;

71 
	mblockedEReqFg
 : 1;

72 
	mrved0
 : 3;

73 } 
	tROW_ADDR_DEPENDENCY_ENTRY
, *
	tP_ROW_ADDR_DEPENDENCY_ENTRY
;

75 
	s_ROW_ADDR_DEPENDENCY_TABLE
 {

76 
ROW_ADDR_DEPENDENCY_ENTRY
 
	mblock
[
USER_CHANNELS
][
USER_WAYS
][
MAIN_BLOCKS_PER_DIE
];

77 } 
	tROW_ADDR_DEPENDENCY_TABLE
, *
	tP_ROW_ADDR_DEPENDENCY_TABLE
;

79 
InDdcyTab
();

80 
ReqTnsNvmeToSli
(
cmdSlTag
, 
qID
, 
cID
, 
tLba
, 
b
, 
cmdCode
, 
fua
);

81 
ReqTnsSliToLowLev
();

82 
IssueNvmeDmaReq
(
qSlTag
);

83 
CheckDeNvmeDmaReq
();

85 
SeLowLevReqQ
(
qSlTag
);

86 
RBlockedByBufDReq
(
qSlTag
);

87 
RBlockedByRowAddrDReq
(
chNo
, 
wayNo
);

89 
P_ROW_ADDR_DEPENDENCY_TABLE
 
rowAddrDdcyTabP
;

	@share/share.c

1 
	~"she.h
"

3 
	$InvideDaBufr
(
bufEry
)

5 
evEry
, 
xtEry
, 
Ery
;

7 i(
daBufLruLi
.
Ery
 =
bufEry
)

8 
vide
;

11 
evEry
 = 
daBufMP
->
daBuf
[
bufEry
].prevEntry;

12 
xtEry
 = 
daBufMP
->
daBuf
[
bufEry
].nextEntry;

14 i(
xtEry
 !
DATA_BUF_NONE
 && 
evEry
 != DATA_BUF_NONE) {

15 
daBufMP
->
daBuf
[
evEry
].
xtEry
 =extEntry;

16 
daBufMP
->
daBuf
[
xtEry
].
evEry
 =revEntry;

17 } i(
xtEry
 =
DATA_BUF_NONE
 && 
evEry
 != DATA_BUF_NONE) {

18 
	`as
(0);

19 } i(
xtEry
 !
DATA_BUF_NONE
 && 
evEry
 == DATA_BUF_NONE) {

20 
daBufLruLi
.
hdEry
 = 
xtEry
;

21 
daBufMP
->
daBuf
[
xtEry
].
evEry
 = 
DATA_BUF_NONE
;

23 
	`as
(0);

26 
vide
:

28 
Ery
 = 
daBufLruLi
.tailEntry;

29 
	`as
(
Ery
 !
DATA_BUF_NONE
);

31 
daBufLruLi
.
Ery
 = 
bufEry
;

32 
daBufMP
->
daBuf
[
Ery
].
xtEry
 = 
bufEry
;

34 
daBufMP
->
daBuf
[
bufEry
].
evEry
 = 
Ery
;

35 
daBufMP
->
daBuf
[
bufEry
].
xtEry
 = 
DATA_BUF_NONE
;

38 
	`SeiveGFromDaBufHashLi
(
bufEry
);

40 
daBufMP
->
daBuf
[
bufEry
].
logilSliAddr
 = 
LSA_NONE
;

41 
daBufMP
->
daBuf
[
bufEry
].
dty
 = 
DATA_BUF_CLEAN
;

42 
	}
}

44 
	$she_ce
(
l1
, 
l2
, 
cmdSlTag
,

45 
NVME_IO_COMMAND
 *
nvmeIOCmd
, 
qID
)

47 
l1_bufEry
 = 
	`CheckDaBufHFShe
(
l1
);

48 
l2_bufEry
 = 
	`CheckDaBufHFShe
(
l2
);

49 
v1
, 
v2
;

51 
	`as
(
v1
 !
VSA_NONE
);

52 
	`as
(
v2
 !
VSA_NONE
);

54 i(
l1_bufEry
 =
DATA_BUF_FAIL
 && 
l2_bufEry
 == DATA_BUF_FAIL) {

55 
v1
 = 
logilSliMP
->
logilSli
[
l1
].
vtuSliAddr
;

56 
	`InvideOldV
(
l2
);

58 
logilSliMP
->
logilSli
[
l2
].
vtuSliAddr
 = 
v1
;

59 
vtuSliMP
->
vtuSli
[
v1
].
logilSliAddr
 = 
l2
;

61 
logilSliMP
->
logilSli
[
l1
].
vtuSliAddr
 = 
VSA_NONE
;

63 } i(
l1_bufEry
 !
DATA_BUF_FAIL
 && 
l2_bufEry
 == DATA_BUF_FAIL) {

64 
	`InvideOldV
(
l2
);

67 
	`SeiveGFromDaBufHashLi
(
l1_bufEry
);

69 
daBufMP
->
daBuf
[
l1_bufEry
].
logilSliAddr
 = 
l2
;

70 
daBufMP
->
daBuf
[
l1_bufEry
].
dty
 = 
DATA_BUF_DIRTY
;

73 
	`PutToDaBufHashLi
(
l1_bufEry
);

74 } i(
l1_bufEry
 =
DATA_BUF_FAIL
 && 
l2_bufEry
 != DATA_BUF_FAIL) {

75 
v1
 = 
logilSliMP
->
logilSli
[
l1
].
vtuSliAddr
;

77 
	`as
(
daBufMP
->
daBuf
[
l2_bufEry
].
logilSliAddr
 =
l2
);

78 
	`InvideDaBufr
(
l2_bufEry
);

79 
	`InvideOldV
(
l2
);

81 
logilSliMP
->
logilSli
[
l2
].
vtuSliAddr
 = 
v1
;

82 
vtuSliMP
->
vtuSli
[
v1
].
logilSliAddr
 = 
l2
;

84 
logilSliMP
->
logilSli
[
l1
].
vtuSliAddr
 = 
VSA_NONE
;

90 
	`as
(
daBufMP
->
daBuf
[
l2_bufEry
].
logilSliAddr
 =
l2
);

91 
	`InvideDaBufr
(
l2_bufEry
);

92 
	`InvideOldV
(
l2
);

95 
	`SeiveGFromDaBufHashLi
(
l1_bufEry
);

97 
daBufMP
->
daBuf
[
l1_bufEry
].
logilSliAddr
 = 
l2
;

98 
daBufMP
->
daBuf
[
l1_bufEry
].
dty
 = 
DATA_BUF_DIRTY
;

101 
	`PutToDaBufHashLi
(
l1_bufEry
);

103 
	}
}

105 
	$she_v2
(
lba1
, 
lba2
, 
n
,

106 
cmdSlTag
, 
NVME_IO_COMMAND
 *
nvmeIOCmd
, 
qID
) {

108 
queedNvmeBlock
, 
sCou
, 
lo
, 
nvmeBlockOfft
;

109 
mpNumOfNvmeBlock
, 
nvmeDmaSIndex
, 
mpL1
, 
mpL2
;

111 
mpL1
 = 
lba1
 / 
NVME_BLOCKS_PER_SLICE
;

112 
mpL2
 = 
lba2
 / 
NVME_BLOCKS_PER_SLICE
;

114 
queedNvmeBlock
 = 
n
 + 1;

115 
sCou
 = 0;

116 
nvmeDmaSIndex
 = 0;

117 
lo
 = ((
lba1
 % 
NVME_BLOCKS_PER_SLICE
+ 
queedNvmeBlock
) / NVME_BLOCKS_PER_SLICE;

120 
nvmeBlockOfft
 = (
lba1
 % 
NVME_BLOCKS_PER_SLICE
);

121 if(
lo
)

122 
mpNumOfNvmeBlock
 = 
NVME_BLOCKS_PER_SLICE
 - 
nvmeBlockOfft
;

124 
mpNumOfNvmeBlock
 = 
queedNvmeBlock
;

126 
	`she_ce
(
mpL1
, 
mpL2
, 
cmdSlTag
, 
nvmeIOCmd
, 
qID
);

128 
mpL1
++;

129 
mpL2
++;

130 
sCou
++;

131 
nvmeDmaSIndex
 +
mpNumOfNvmeBlock
;

133 
sCou
 < 
lo
) {

134 
	`she_ce
(
mpL1
, 
mpL2
, 
cmdSlTag
, 
nvmeIOCmd
, 
qID
);

135 
mpL1
++;

136 
mpL2
++;

137 
sCou
++;

138 
nvmeDmaSIndex
 +
mpNumOfNvmeBlock
;

143 
nvmeBlockOfft
 = 0;

144 
mpNumOfNvmeBlock
 = (
lba1
 + 
queedNvmeBlock
% 
NVME_BLOCKS_PER_SLICE
;

145 if((
mpNumOfNvmeBlock
 =0|| (
lo
 == 0))

148 
	`she_ce
(
mpL1
, 
mpL2
, 
cmdSlTag
, 
nvmeIOCmd
, 
qID
);

150 
	}
}

152 
	$hd_nvme_io_she_v2
(
cmdSlTag
, 
NVME_IO_COMMAND
 *
nvmeIOCmd
, 
qID
)

154 
IO_DATASET_MANAGEMENT_COMMAND_DW10
 
dsm10
;

155 
IO_DATASET_MANAGEMENT_COMMAND_DW11
 
dsm11
;

157 
dsm10
.
dwd
 = 
nvmeIOCmd
->dword[10];

158 
dsm11
.
dwd
 = 
nvmeIOCmd
->dword[11];

160 

, 
n
;

162 

 = 
dsm10
.
NR
;

163 
n
 = 
dsm11
.
dwd
;

165 
w_addr
 = 0;

166 
diff
 = 
RESERVED0_START_ADDR
 % 4096;

167 i(
diff
 != 0) {

168 
w_addr
 = 
RESERVED0_START_ADDR
 + (4096 - 
diff
);

170 
w_addr
 = 
RESERVED0_START_ADDR
 ;

173 
	`t_de_rx_dma
((
w_addr
), 
nvmeIOCmd
->
PRP1
[1],vmeIOCmd->PRP1[0], 4096);

174 
	`check_de_rx_dma_de
();

176 
i
;

177 
LBA1
[2];

178 
LBA2
[2];

180 
i
=0; i<

; i++) {

181 
DATASET_MANAGEMENT_RANGE_SHARE
* 
dmrs
 = (DATASET_MANAGEMENT_RANGE_SHARE*)

182 (
w_addr
 + ((*
dmrs
)*
i
));

185 
n
 = 
dmrs
->
ngth
;

186 
LBA1
[0] = 
dmrs
->LBA1[0];

187 
LBA2
[0] = 
dmrs
->LBA2[0];

189 
	`she_v2
(
LBA1
[0], 
LBA2
[0], 
n
 ,
cmdSlTag
, 
nvmeIOCmd
, 
qID
);

191 
	}
}

193 
	$DisrdBlocks
(
t_lba
, 
n
)

195 
lba
, 
buf_y
;

197 
	`as
(
t_lba
 =(t_lb/ 
NVME_BLOCKS_PER_SLICE
));

199 
lba
 = 
t_lba
;b< (t_lb+ 
n
);ba++) {

200 
buf_y
 = 
	`CheckDaBufHFShe
(
lba
);

202 i(
buf_y
 !
DATA_BUF_FAIL
)

203 
	`InvideDaBufr
(
buf_y
);

205 
	`InvideOldV
(
lba
);

207 
	}
}

	@share/share.h

1 #ide
__SHARE_H__


2 
	#__SAHRE_H__


	)

4 
	~"../memy_m.h
"

5 
	~"x_tf.h
"

6 
	~"../l_cfig.h
"

7 
	~"../da_bufr.h
"

8 
	~"../addss_i.h
"

9 
	~<ys.h
>

10 
	~<as.h
>

12 
hd_nvme_io_she_v2
(
cmdSlTag
, 
NVME_IO_COMMAND
 *
nvmeIOCmd
, 
qID
);

13 
DisrdBlocks
(
t_lba
, 
n
);

	@t4nsc_pm.h

1 #ide
T4NSC_PM_H_


2 
	#T4NSC_PM_H_


	)

6 
	mriod
;

7 
	mcou
;

8 } 
	tT4EXT_PM_SiglCou
;

12 
T4EXT_PM_SiglCou
 
	mscLLNFCCmdIdTime
;

13 
T4EXT_PM_SiglCou
 
	mscLLNFCWreDaIdTime
;

14 
T4EXT_PM_SiglCou
 
	mscLLNFCRdDaIdTime
;

15 
T4EXT_PM_SiglCou
 
	mscDPLWreCmdIdTime
;

16 
T4EXT_PM_SiglCou
 
	mscDPLWreDaIdTime
;

17 
T4EXT_PM_SiglCou
 
	mscDPLRdCmdIdTime
;

18 
T4EXT_PM_SiglCou
 
	mscDPLRdDaIdTime
;

19 } 
	tT4EXT_PM
;

	@t4nsc_ucode.h

1 #ide
T4NSC_UCODE_H_


2 
	#T4NSC_UCODE_H_


	)

4 
	gT4NSCuCode_Comm
[] =

214 
	gT4NSCuCode_Indexed
[]=

561 
	gT4NSCuCode_PϚOps
[]=

892 cڡ 
	gT4NSCu_Comm_CodeWdLgth
 = (
T4NSCuCode_Comm
) / ();

893 cڡ 
	gT4NSCu_Indexed_CodeWdLgth
 = (
T4NSCuCode_Indexed
) / ();

894 cڡ 
	gT4NSCu_PϚOps_CodeWdLgth
 = (
T4NSCuCode_PϚOps
) / ();

	@/usr/include/assert.h

22 #ifdef 
_ASSERT_H


24 #unde
_ASSERT_H


25 #unde
as


26 #unde
__ASSERT_VOID_CAST


28 #ifdef 
__USE_GNU


29 #unde
as_


34 
	#_ASSERT_H
 1

	)

35 
	~<us.h
>

37 #i
defed
 
__lulus
 && 
__GNUC_PREREQ
 (2,95)

38 
	#__ASSERT_VOID_CAST
 
ic_
<>

	)

40 
	#__ASSERT_VOID_CAST
 ()

	)

48 #ifdef 
NDEBUG


50 
	#as
(
ex
(
	`__ASSERT_VOID_CAST
 (0))

	)

58 #ifdef 
__USE_GNU


59 
	#as_
(
um
(
	`__ASSERT_VOID_CAST
 (0))

	)

64 #ide
_ASSERT_H_DECLS


65 
	#_ASSERT_H_DECLS


	)

66 
__BEGIN_DECLS


69 
	$__as_
 (cڡ *
__asi
, cڡ *
__fe
,

70 
__le
, cڡ *
__funi
)

71 
__THROW
 
	`__ibu__
 ((
__nܑu__
));

74 
	$__as__
 (
__um
, cڡ *
__fe
,

75 
__le
, cڡ *
__funi
)

76 
__THROW
 
	`__ibu__
 ((
__nܑu__
));

81 
	$__as
 (cڡ *
__asi
, cڡ *
__fe
, 
__le
)

82 
__THROW
 
	`__ibu__
 ((
__nܑu__
));

85 
__END_DECLS


91 #i
defed
 
__lulus


92 
	#as
(
ex
) \

93 (
ic_
 <
bo
> (
ex
) \

95 : 
	`__as_
 (#ex, 
__FILE__
, 
__LINE__
, 
__ASSERT_FUNCTION
))

	)

96 #i!
defed
 
__GNUC__
 || defed 
__STRICT_ANSI__


97 
	#as
(
ex
) \

98 ((
ex
) \

99 ? 
	`__ASSERT_VOID_CAST
 (0) \

100 : 
	`__as_
 (#ex, 
__FILE__
, 
__LINE__
, 
__ASSERT_FUNCTION
))

	)

107 
	#as
(
ex
) \

108 (( ((
ex
? 1 : 0), 
	`__exnsi__
 ({ \

109 i(
ex
) \

112 
	`__as_
 (#ex, 
__FILE__
, 
__LINE__
, 
__ASSERT_FUNCTION
); \

113 
	}
}))

	)

116 #ifdef 
__USE_GNU


117 
	#as_
(
um
) \

118 (!(
um
) \

119 ? 
	`__ASSERT_VOID_CAST
 (0) \

120 : 
	`__as__
 ((
um
), 
__FILE__
, 
__LINE__
, 
__ASSERT_FUNCTION
))

	)

128 #i
defed
 
__lulus
 ? 
__GNUC_PREREQ
 (2, 6) : __GNUC_PREREQ (2, 4)

129 
	#__ASSERT_FUNCTION
 
__exnsi__
 
__PRETTY_FUNCTION__


	)

131 #i
defed
 
__STDC_VERSION__
 && __STDC_VERSION__ >= 199901L

132 
	#__ASSERT_FUNCTION
 
__func__


	)

134 
	#__ASSERT_FUNCTION
 ((cڡ *0)

	)

141 #i
defed
 
__USE_ISOC11
 && !defed 
__lulus


142 #unde
ic_as


143 
	#ic_as
 
_Stic_as


	)

	@/usr/include/inttypes.h

22 #ide
_INTTYPES_H


23 
	#_INTTYPES_H
 1

	)

25 
	~<us.h
>

27 
	~<dt.h
>

30 #ide
____gwch_t_defed


31 #ifde
__lulus


32 
	#__gwch_t
 
wch_t


	)

33 #i
defed
 
__WCHAR_TYPE__


34 
__WCHAR_TYPE__
 
	t__gwch_t
;

36 
	#__ed_wch_t


	)

37 
	~<ddef.h
>

38 
wch_t
 
	t__gwch_t
;

40 
	#____gwch_t_defed
 1

	)

43 #i
__WORDSIZE
 == 64

44 
	#__PRI64_PREFIX
 "l"

	)

45 
	#__PRIPTR_PREFIX
 "l"

	)

47 
	#__PRI64_PREFIX
 ""

	)

48 
	#__PRIPTR_PREFIX


	)

54 
	#PRId8
 "d"

	)

55 
	#PRId16
 "d"

	)

56 
	#PRId32
 "d"

	)

57 
	#PRId64
 
__PRI64_PREFIX
 "d"

	)

59 
	#PRIdLEAST8
 "d"

	)

60 
	#PRIdLEAST16
 "d"

	)

61 
	#PRIdLEAST32
 "d"

	)

62 
	#PRIdLEAST64
 
__PRI64_PREFIX
 "d"

	)

64 
	#PRIdFAST8
 "d"

	)

65 
	#PRIdFAST16
 
__PRIPTR_PREFIX
 "d"

	)

66 
	#PRIdFAST32
 
__PRIPTR_PREFIX
 "d"

	)

67 
	#PRIdFAST64
 
__PRI64_PREFIX
 "d"

	)

70 
	#PRIi8
 "i"

	)

71 
	#PRIi16
 "i"

	)

72 
	#PRIi32
 "i"

	)

73 
	#PRIi64
 
__PRI64_PREFIX
 "i"

	)

75 
	#PRIiLEAST8
 "i"

	)

76 
	#PRIiLEAST16
 "i"

	)

77 
	#PRIiLEAST32
 "i"

	)

78 
	#PRIiLEAST64
 
__PRI64_PREFIX
 "i"

	)

80 
	#PRIiFAST8
 "i"

	)

81 
	#PRIiFAST16
 
__PRIPTR_PREFIX
 "i"

	)

82 
	#PRIiFAST32
 
__PRIPTR_PREFIX
 "i"

	)

83 
	#PRIiFAST64
 
__PRI64_PREFIX
 "i"

	)

86 
	#PRIo8
 "o"

	)

87 
	#PRIo16
 "o"

	)

88 
	#PRIo32
 "o"

	)

89 
	#PRIo64
 
__PRI64_PREFIX
 "o"

	)

91 
	#PRIoLEAST8
 "o"

	)

92 
	#PRIoLEAST16
 "o"

	)

93 
	#PRIoLEAST32
 "o"

	)

94 
	#PRIoLEAST64
 
__PRI64_PREFIX
 "o"

	)

96 
	#PRIoFAST8
 "o"

	)

97 
	#PRIoFAST16
 
__PRIPTR_PREFIX
 "o"

	)

98 
	#PRIoFAST32
 
__PRIPTR_PREFIX
 "o"

	)

99 
	#PRIoFAST64
 
__PRI64_PREFIX
 "o"

	)

102 
	#PRIu8
 "u"

	)

103 
	#PRIu16
 "u"

	)

104 
	#PRIu32
 "u"

	)

105 
	#PRIu64
 
__PRI64_PREFIX
 "u"

	)

107 
	#PRIuLEAST8
 "u"

	)

108 
	#PRIuLEAST16
 "u"

	)

109 
	#PRIuLEAST32
 "u"

	)

110 
	#PRIuLEAST64
 
__PRI64_PREFIX
 "u"

	)

112 
	#PRIuFAST8
 "u"

	)

113 
	#PRIuFAST16
 
__PRIPTR_PREFIX
 "u"

	)

114 
	#PRIuFAST32
 
__PRIPTR_PREFIX
 "u"

	)

115 
	#PRIuFAST64
 
__PRI64_PREFIX
 "u"

	)

118 
	#PRIx8
 "x"

	)

119 
	#PRIx16
 "x"

	)

120 
	#PRIx32
 "x"

	)

121 
	#PRIx64
 
__PRI64_PREFIX
 "x"

	)

123 
	#PRIxLEAST8
 "x"

	)

124 
	#PRIxLEAST16
 "x"

	)

125 
	#PRIxLEAST32
 "x"

	)

126 
	#PRIxLEAST64
 
__PRI64_PREFIX
 "x"

	)

128 
	#PRIxFAST8
 "x"

	)

129 
	#PRIxFAST16
 
__PRIPTR_PREFIX
 "x"

	)

130 
	#PRIxFAST32
 
__PRIPTR_PREFIX
 "x"

	)

131 
	#PRIxFAST64
 
__PRI64_PREFIX
 "x"

	)

134 
	#PRIX8
 "X"

	)

135 
	#PRIX16
 "X"

	)

136 
	#PRIX32
 "X"

	)

137 
	#PRIX64
 
__PRI64_PREFIX
 "X"

	)

139 
	#PRIXLEAST8
 "X"

	)

140 
	#PRIXLEAST16
 "X"

	)

141 
	#PRIXLEAST32
 "X"

	)

142 
	#PRIXLEAST64
 
__PRI64_PREFIX
 "X"

	)

144 
	#PRIXFAST8
 "X"

	)

145 
	#PRIXFAST16
 
__PRIPTR_PREFIX
 "X"

	)

146 
	#PRIXFAST32
 
__PRIPTR_PREFIX
 "X"

	)

147 
	#PRIXFAST64
 
__PRI64_PREFIX
 "X"

	)

151 
	#PRIdMAX
 
__PRI64_PREFIX
 "d"

	)

152 
	#PRIiMAX
 
__PRI64_PREFIX
 "i"

	)

153 
	#PRIoMAX
 
__PRI64_PREFIX
 "o"

	)

154 
	#PRIuMAX
 
__PRI64_PREFIX
 "u"

	)

155 
	#PRIxMAX
 
__PRI64_PREFIX
 "x"

	)

156 
	#PRIXMAX
 
__PRI64_PREFIX
 "X"

	)

160 
	#PRIdPTR
 
__PRIPTR_PREFIX
 "d"

	)

161 
	#PRIiPTR
 
__PRIPTR_PREFIX
 "i"

	)

162 
	#PRIoPTR
 
__PRIPTR_PREFIX
 "o"

	)

163 
	#PRIuPTR
 
__PRIPTR_PREFIX
 "u"

	)

164 
	#PRIxPTR
 
__PRIPTR_PREFIX
 "x"

	)

165 
	#PRIXPTR
 
__PRIPTR_PREFIX
 "X"

	)

171 
	#SCNd8
 "hhd"

	)

172 
	#SCNd16
 "hd"

	)

173 
	#SCNd32
 "d"

	)

174 
	#SCNd64
 
__PRI64_PREFIX
 "d"

	)

176 
	#SCNdLEAST8
 "hhd"

	)

177 
	#SCNdLEAST16
 "hd"

	)

178 
	#SCNdLEAST32
 "d"

	)

179 
	#SCNdLEAST64
 
__PRI64_PREFIX
 "d"

	)

181 
	#SCNdFAST8
 "hhd"

	)

182 
	#SCNdFAST16
 
__PRIPTR_PREFIX
 "d"

	)

183 
	#SCNdFAST32
 
__PRIPTR_PREFIX
 "d"

	)

184 
	#SCNdFAST64
 
__PRI64_PREFIX
 "d"

	)

187 
	#SCNi8
 "hhi"

	)

188 
	#SCNi16
 "hi"

	)

189 
	#SCNi32
 "i"

	)

190 
	#SCNi64
 
__PRI64_PREFIX
 "i"

	)

192 
	#SCNiLEAST8
 "hhi"

	)

193 
	#SCNiLEAST16
 "hi"

	)

194 
	#SCNiLEAST32
 "i"

	)

195 
	#SCNiLEAST64
 
__PRI64_PREFIX
 "i"

	)

197 
	#SCNiFAST8
 "hhi"

	)

198 
	#SCNiFAST16
 
__PRIPTR_PREFIX
 "i"

	)

199 
	#SCNiFAST32
 
__PRIPTR_PREFIX
 "i"

	)

200 
	#SCNiFAST64
 
__PRI64_PREFIX
 "i"

	)

203 
	#SCNu8
 "hhu"

	)

204 
	#SCNu16
 "hu"

	)

205 
	#SCNu32
 "u"

	)

206 
	#SCNu64
 
__PRI64_PREFIX
 "u"

	)

208 
	#SCNuLEAST8
 "hhu"

	)

209 
	#SCNuLEAST16
 "hu"

	)

210 
	#SCNuLEAST32
 "u"

	)

211 
	#SCNuLEAST64
 
__PRI64_PREFIX
 "u"

	)

213 
	#SCNuFAST8
 "hhu"

	)

214 
	#SCNuFAST16
 
__PRIPTR_PREFIX
 "u"

	)

215 
	#SCNuFAST32
 
__PRIPTR_PREFIX
 "u"

	)

216 
	#SCNuFAST64
 
__PRI64_PREFIX
 "u"

	)

219 
	#SCNo8
 "hho"

	)

220 
	#SCNo16
 "ho"

	)

221 
	#SCNo32
 "o"

	)

222 
	#SCNo64
 
__PRI64_PREFIX
 "o"

	)

224 
	#SCNoLEAST8
 "hho"

	)

225 
	#SCNoLEAST16
 "ho"

	)

226 
	#SCNoLEAST32
 "o"

	)

227 
	#SCNoLEAST64
 
__PRI64_PREFIX
 "o"

	)

229 
	#SCNoFAST8
 "hho"

	)

230 
	#SCNoFAST16
 
__PRIPTR_PREFIX
 "o"

	)

231 
	#SCNoFAST32
 
__PRIPTR_PREFIX
 "o"

	)

232 
	#SCNoFAST64
 
__PRI64_PREFIX
 "o"

	)

235 
	#SCNx8
 "hhx"

	)

236 
	#SCNx16
 "hx"

	)

237 
	#SCNx32
 "x"

	)

238 
	#SCNx64
 
__PRI64_PREFIX
 "x"

	)

240 
	#SCNxLEAST8
 "hhx"

	)

241 
	#SCNxLEAST16
 "hx"

	)

242 
	#SCNxLEAST32
 "x"

	)

243 
	#SCNxLEAST64
 
__PRI64_PREFIX
 "x"

	)

245 
	#SCNxFAST8
 "hhx"

	)

246 
	#SCNxFAST16
 
__PRIPTR_PREFIX
 "x"

	)

247 
	#SCNxFAST32
 
__PRIPTR_PREFIX
 "x"

	)

248 
	#SCNxFAST64
 
__PRI64_PREFIX
 "x"

	)

252 
	#SCNdMAX
 
__PRI64_PREFIX
 "d"

	)

253 
	#SCNiMAX
 
__PRI64_PREFIX
 "i"

	)

254 
	#SCNoMAX
 
__PRI64_PREFIX
 "o"

	)

255 
	#SCNuMAX
 
__PRI64_PREFIX
 "u"

	)

256 
	#SCNxMAX
 
__PRI64_PREFIX
 "x"

	)

259 
	#SCNdPTR
 
__PRIPTR_PREFIX
 "d"

	)

260 
	#SCNiPTR
 
__PRIPTR_PREFIX
 "i"

	)

261 
	#SCNoPTR
 
__PRIPTR_PREFIX
 "o"

	)

262 
	#SCNuPTR
 
__PRIPTR_PREFIX
 "u"

	)

263 
	#SCNxPTR
 
__PRIPTR_PREFIX
 "x"

	)

266 
	g__BEGIN_DECLS


268 #i
__WORDSIZE
 == 64

273 
	mqu
;

274 
	mm
;

275 } 
	timaxdiv_t
;

282 
__exnsi__
 
	mqu
;

283 
__exnsi__
 
	mm
;

284 } 
	timaxdiv_t
;

290 
tmax_t
 
	$imaxabs
 (
tmax_t
 
__n

__THROW
 
	`__ibu__
 ((
__cڡ__
));

293 
imaxdiv_t
 
	$imaxdiv
 (
tmax_t
 
__num
, imax_
__dom
)

294 
__THROW
 
	`__ibu__
 ((
__cڡ__
));

297 
tmax_t
 
	$oimax
 (cڡ *
__ri
 
__Ō
,

298 **
__ri
 
__dr
, 
__ba

__THROW
;

301 
utmax_t
 
	$oumax
 (cڡ *
__ri
 
__Ō
,

302 ** 
__ri
 
__dr
, 
__ba

__THROW
;

305 
tmax_t
 
	$wcoimax
 (cڡ 
__gwch_t
 *
__ri
 
__Ō
,

306 
__gwch_t
 **
__ri
 
__dr
, 
__ba
)

307 
__THROW
;

310 
utmax_t
 
	$wcoumax
 (cڡ 
__gwch_t
 *
__ri
 
__Ō
,

311 
__gwch_t
 ** 
__ri
 
__dr
, 
__ba
)

312 
__THROW
;

314 #ifde
__USE_EXTERN_INLINES


316 #i
__WORDSIZE
 == 64

318 
	$___
 (cڡ *
__ri
 
__Ō
,

319 **
__ri
 
__dr
,

320 
__ba
, 
__group
)

321 
__THROW
 
	`__nnu
 ((1)
__wur
;

323 
__ex_le
 
tmax_t


324 
	`__NTH
 (
	$oimax
 (cڡ *
__ri
 
Ō
, **__ri 
dr
,

325 
ba
))

327  
	`___
 (
Ō
, 
dr
, 
ba
, 0);

328 
	}
}

330 
	$__oul_
 (cڡ *
__ri
 
__Ō
,

331 ** 
__ri
 
__dr
,

332 
__ba
, 
__group
)

333 
__THROW
 
	`__nnu
 ((1)
__wur
;

335 
__ex_le
 
utmax_t


336 
	`__NTH
 (
	$oumax
 (cڡ *
__ri
 
Ō
, **__ri 
dr
,

337 
ba
))

339  
	`__oul_
 (
Ō
, 
dr
, 
ba
, 0);

340 
	}
}

342 
	$__wc_
 (cڡ 
__gwch_t
 * 
__ri
 
__Ō
,

343 
__gwch_t
 **
__ri
 
__dr
,

344 
__ba
, 
__group
)

345 
__THROW
 
	`__nnu
 ((1)
__wur
;

347 
__ex_le
 
tmax_t


348 
	`__NTH
 (
	$wcoimax
 (cڡ 
__gwch_t
 *
__ri
 
Ō
,

349 
__gwch_t
 **
__ri
 
dr
, 
ba
))

351  
	`__wc_
 (
Ō
, 
dr
, 
ba
, 0);

352 
	}
}

354 
	$__wcoul_
 (cڡ 
__gwch_t
 *

355 
__ri
 
__Ō
,

356 
__gwch_t
 **

357 
__ri
 
__dr
,

358 
__ba
, 
__group
)

359 
__THROW
 
	`__nnu
 ((1)
__wur
;

361 
__ex_le
 
utmax_t


362 
	`__NTH
 (
	$wcoumax
 (cڡ 
__gwch_t
 *
__ri
 
Ō
,

363 
__gwch_t
 **
__ri
 
dr
, 
ba
))

365  
	`__wcoul_
 (
Ō
, 
dr
, 
ba
, 0);

366 
	}
}

370 
__exnsi__


371 
	$__l_
 (cڡ *
__ri
 
__Ō
,

372 **
__ri
 
__dr
,

373 
__ba
, 
__group
)

374 
__THROW
 
	`__nnu
 ((1)
__wur
;

376 
__ex_le
 
tmax_t


377 
	`__NTH
 (
	$oimax
 (cڡ *
__ri
 
Ō
, **__ri 
dr
,

378 
ba
))

380  
	`__l_
 (
Ō
, 
dr
, 
ba
, 0);

381 
	}
}

383 
__exnsi__


384 
	$__ou_
 (const *

385 
__ri
 
__Ō
,

387 
__ri
 
__dr
,

388 
__ba
,

389 
__group
)

390 
__THROW
 
	`__nnu
 ((1)
__wur
;

392 
__ex_le
 
utmax_t


393 
	`__NTH
 (
	$oumax
 (cڡ *
__ri
 
Ō
, **__ri 
dr
,

394 
ba
))

396  
	`__ou_
 (
Ō
, 
dr
, 
ba
, 0);

397 
	}
}

399 
__exnsi__


400 
	$__wcl_
 (cڡ 
__gwch_t
 *
__ri
 
__Ō
,

401 
__gwch_t
 **
__ri
 
__dr
,

402 
__ba
, 
__group
)

403 
__THROW
 
	`__nnu
 ((1)
__wur
;

405 
__ex_le
 
tmax_t


406 
	`__NTH
 (
	$wcoimax
 (cڡ 
__gwch_t
 *
__ri
 
Ō
,

407 
__gwch_t
 **
__ri
 
dr
, 
ba
))

409  
	`__wcl_
 (
Ō
, 
dr
, 
ba
, 0);

410 
	}
}

413 
__exnsi__


414 
	$__wcou_
 (cڡ 
__gwch_t
 *

415 
__ri
 
__Ō
,

416 
__gwch_t
 **

417 
__ri
 
__dr
,

418 
__ba
,

419 
__group
)

420 
__THROW
 
	`__nnu
 ((1)
__wur
;

422 
__ex_le
 
utmax_t


423 
	`__NTH
 (
	$wcoumax
 (cڡ 
__gwch_t
 *
__ri
 
Ō
,

424 
__gwch_t
 **
__ri
 
dr
, 
ba
))

426  
	`__wcou_
 (
Ō
, 
dr
, 
ba
, 0);

427 
	}
}

432 
	g__END_DECLS


	@/usr/include/stdio.h

23 #ide
_STDIO_H


24 
	#_STDIO_H
 1

	)

26 
	#__GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION


	)

27 
	~<bs/libc-hd-t.h
>

29 
	g__BEGIN_DECLS


31 
	#__ed_size_t


	)

32 
	#__ed_NULL


	)

33 
	~<ddef.h
>

35 
	#__ed___va_li


	)

36 
	~<dg.h
>

38 
	~<bs/tys.h
>

39 
	~<bs/tys/__os_t.h
>

40 
	~<bs/tys/__os64_t.h
>

41 
	~<bs/tys/__FILE.h
>

42 
	~<bs/tys/FILE.h
>

43 
	~<bs/tys/ru_FILE.h
>

45 #ifde
__USE_GNU


46 
	~<bs/tys/cook_io_funis_t.h
>

49 #i
defed
 
__USE_XOPEN
 || defed 
__USE_XOPEN2K8


50 #ifde
__GNUC__


51 #ide
_VA_LIST_DEFINED


52 
__gnuc_va_li
 
	tva_li
;

53 
	#_VA_LIST_DEFINED


	)

56 
	~<dg.h
>

60 #i
defed
 
__USE_UNIX98
 || defed 
__USE_XOPEN2K


61 #ide
__off_t_defed


62 #ide
__USE_FILE_OFFSET64


63 
__off_t
 
	toff_t
;

65 
__off64_t
 
	toff_t
;

67 
	#__off_t_defed


	)

69 #i
defed
 
__USE_LARGEFILE64
 && !defed 
__off64_t_defed


70 
__off64_t
 
	toff64_t
;

71 
	#__off64_t_defed


	)

75 #ifde
__USE_XOPEN2K8


76 #ide
__ssize_t_defed


77 
__ssize_t
 
	tssize_t
;

78 
	#__ssize_t_defed


	)

83 #ide
__USE_FILE_OFFSET64


84 
__os_t
 
	tos_t
;

86 
__os64_t
 
	tos_t
;

88 #ifde
__USE_LARGEFILE64


89 
__os64_t
 
	tos64_t
;

93 
	#_IOFBF
 0

	)

94 
	#_IOLBF
 1

	)

95 
	#_IONBF
 2

	)

99 
	#BUFSIZ
 8192

	)

104 
	#EOF
 (-1)

	)

109 
	#SEEK_SET
 0

	)

110 
	#SEEK_CUR
 1

	)

111 
	#SEEK_END
 2

	)

112 #ifde
__USE_GNU


113 
	#SEEK_DATA
 3

	)

114 
	#SEEK_HOLE
 4

	)

118 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN


120 
	#P_tmpd
 "/tmp"

	)

133 
	~<bs/dio_lim.h
>

137 
FILE
 *
d
;

138 
FILE
 *
dout
;

139 
FILE
 *
dr
;

141 
	#d
 
d


	)

142 
	#dout
 
dout


	)

143 
	#dr
 
dr


	)

146 
	$move
 (cڡ *
__fame

__THROW
;

148 
	$me
 (cڡ *
__d
, cڡ *
__w

__THROW
;

150 #ifde
__USE_ATFILE


152 
	$mt
 (
__dfd
, cڡ *
__d
, 
__wfd
,

153 cڡ *
__w

__THROW
;

156 #ifde
__USE_GNU


158 
	#RENAME_NOREPLACE
 (1 << 0)

	)

159 
	#RENAME_EXCHANGE
 (1 << 1)

	)

160 
	#RENAME_WHITEOUT
 (1 << 2)

	)

164 
	$mt2
 (
__dfd
, cڡ *
__d
, 
__wfd
,

165 cڡ *
__w
, 
__ags

__THROW
;

172 #ide
__USE_FILE_OFFSET64


173 
FILE
 *
	$tmpfe
 (
__wur
;

175 #ifde
__REDIRECT


176 
FILE
 *
	`__REDIRECT
 (
tmpfe
, (), 
tmpfe64

__wur
;

178 
	#tmpfe
 
tmpfe64


	)

182 #ifde
__USE_LARGEFILE64


183 
FILE
 *
	$tmpfe64
 (
__wur
;

187 *
	$tmam
 (*
__s

__THROW
 
__wur
;

189 #ifde
__USE_MISC


192 *
	$tmam_r
 (*
__s

__THROW
 
__wur
;

196 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN


204 *
	$mam
 (cڡ *
__d
, cڡ *
__pfx
)

205 
__THROW
 
__ibu_mloc__
 
__wur
;

213 
	`fo
 (
FILE
 *
__am
);

218 
	`fush
 (
FILE
 *
__am
);

220 #ifde
__USE_MISC


227 
	`fush_uocked
 (
FILE
 *
__am
);

230 #ifde
__USE_GNU


237 
	`fol
 ();

241 #ide
__USE_FILE_OFFSET64


246 
FILE
 *
	$fݒ
 (cڡ *
__ri
 
__fame
,

247 cڡ *
__ri
 
__modes

__wur
;

252 
FILE
 *
	$eݒ
 (cڡ *
__ri
 
__fame
,

253 cڡ *
__ri
 
__modes
,

254 
FILE
 *
__ri
 
__am

__wur
;

256 #ifde
__REDIRECT


257 
FILE
 *
	`__REDIRECT
 (
fݒ
, (cڡ *
__ri
 
__fame
,

258 cڡ *
__ri
 
__modes
), 
fݒ64
)

259 
__wur
;

260 
FILE
 *
	`__REDIRECT
 (
eݒ
, (cڡ *
__ri
 
__fame
,

261 cڡ *
__ri
 
__modes
,

262 
FILE
 *
__ri
 
__am
), 
eݒ64
)

263 
__wur
;

265 
	#fݒ
 
fݒ64


	)

266 
	#eݒ
 
eݒ64


	)

269 #ifde
__USE_LARGEFILE64


270 
FILE
 *
	$fݒ64
 (cڡ *
__ri
 
__fame
,

271 cڡ *
__ri
 
__modes

__wur
;

272 
FILE
 *
	$eݒ64
 (cڡ *
__ri
 
__fame
,

273 cڡ *
__ri
 
__modes
,

274 
FILE
 *
__ri
 
__am

__wur
;

277 #ifdef 
__USE_POSIX


279 
FILE
 *
	$fdݒ
 (
__fd
, cڡ *
__modes

__THROW
 
__wur
;

282 #ifdef 
__USE_GNU


285 
FILE
 *
	$fݒcook
 (*
__ri
 
__magic_cook
,

286 cڡ *
__ri
 
__modes
,

287 
cook_io_funis_t
 
__io_funcs

__THROW
 
__wur
;

290 #i
defed
 
__USE_XOPEN2K8
 || 
	`__GLIBC_USE
 (
LIB_EXT2
)

292 
FILE
 *
	$fmemݒ
 (*
__s
, 
size_t
 
__n
, cڡ *
__modes
)

293 
__THROW
 
__wur
;

298 
FILE
 *
	$ݒ_memam
 (**
__buoc
, 
size_t
 *
__sizoc

__THROW
 
__wur
;

304 
	$tbuf
 (
FILE
 *
__ri
 
__am
, *__ri 
__buf

__THROW
;

308 
	$tvbuf
 (
FILE
 *
__ri
 
__am
, *__ri 
__buf
,

309 
__modes
, 
size_t
 
__n

__THROW
;

311 #ifdef 
__USE_MISC


314 
	$tbufr
 (
FILE
 *
__ri
 
__am
, *__ri 
__buf
,

315 
size_t
 
__size

__THROW
;

318 
	$ebuf
 (
FILE
 *
__am

__THROW
;

326 
	`rtf
 (
FILE
 *
__ri
 
__am
,

327 cڡ *
__ri
 
__fm
, ...);

332 
	`tf
 (cڡ *
__ri
 
__fm
, ...);

334 
	$rtf
 (*
__ri
 
__s
,

335 cڡ *
__ri
 
__fm
, ...
__THROWNL
;

341 
	`vrtf
 (
FILE
 *
__ri
 
__s
, cڡ *__ri 
__fm
,

342 
__gnuc_va_li
 
__g
);

347 
	`vtf
 (cڡ *
__ri
 
__fm
, 
__gnuc_va_li
 
__g
);

349 
	$vrtf
 (*
__ri
 
__s
, cڡ *__ri 
__fm
,

350 
__gnuc_va_li
 
__g

__THROWNL
;

352 #i
defed
 
__USE_ISOC99
 || defed 
__USE_UNIX98


354 
	$tf
 (*
__ri
 
__s
, 
size_t
 
__maxn
,

355 cڡ *
__ri
 
__fm
, ...)

356 
__THROWNL
 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 3, 4)));

358 
	$vtf
 (*
__ri
 
__s
, 
size_t
 
__maxn
,

359 cڡ *
__ri
 
__fm
, 
__gnuc_va_li
 
__g
)

360 
__THROWNL
 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 3, 0)));

363 #i
	`__GLIBC_USE
 (
LIB_EXT2
)

366 
	$vartf
 (**
__ri
 
__r
, cڡ *__ri 
__f
,

367 
__gnuc_va_li
 
__g
)

368 
__THROWNL
 
	`__ibu__
 ((
	$__fm__
 (
__tf__
, 2, 0))
__wur
;

369 
	$__artf
 (**
__ri
 
__r
,

370 cڡ *
__ri
 
__fmt
, ...)

371 
__THROWNL
 
	`__ibu__
 ((
	$__fm__
 (
__tf__
, 2, 3))
__wur
;

372 
	$artf
 (**
__ri
 
__r
,

373 cڡ *
__ri
 
__fmt
, ...)

374 
__THROWNL
 
	`__ibu__
 ((
	$__fm__
 (
__tf__
, 2, 3))
__wur
;

377 #ifde
__USE_XOPEN2K8


379 
	$vdtf
 (
__fd
, cڡ *
__ri
 
__fmt
,

380 
__gnuc_va_li
 
__g
)

381 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 2, 0)));

382 
	$dtf
 (
__fd
, cڡ *
__ri
 
__fmt
, ...)

383 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 2, 3)));

391 
	$fsnf
 (
FILE
 *
__ri
 
__am
,

392 cڡ *
__ri
 
__fm
, ...
__wur
;

397 
	$snf
 (cڡ *
__ri
 
__fm
, ...
__wur
;

399 
	$ssnf
 (cڡ *
__ri
 
__s
,

400 cڡ *
__ri
 
__fm
, ...
__THROW
;

405 #i!
	`__GLIBC_USE
 (
DEPRECATED_SCANF
&& !
defed
 
__LDBL_COMPAT


406 #ifde
__REDIRECT


407 
	`__REDIRECT
 (
fsnf
, (
FILE
 *
__ri
 
__am
,

408 cڡ *
__ri
 
__fm
, ...),

409 
__isoc99_fsnf

__wur
;

410 
	`__REDIRECT
 (
snf
, (cڡ *
__ri
 
__fm
, ...),

411 
__isoc99_snf

__wur
;

412 
	`__REDIRECT_NTH
 (
ssnf
, (cڡ *
__ri
 
__s
,

413 cڡ *
__ri
 
__fm
, ...),

414 
__isoc99_ssnf
);

416 
	$__isoc99_fsnf
 (
FILE
 *
__ri
 
__am
,

417 cڡ *
__ri
 
__fm
, ...
__wur
;

418 
	$__isoc99_snf
 (cڡ *
__ri
 
__fm
, ...
__wur
;

419 
	$__isoc99_ssnf
 (cڡ *
__ri
 
__s
,

420 cڡ *
__ri
 
__fm
, ...
__THROW
;

421 
	#fsnf
 
__isoc99_fsnf


	)

422 
	#snf
 
__isoc99_snf


	)

423 
	#ssnf
 
__isoc99_ssnf


	)

427 #ifdef 
__USE_ISOC99


432 
	$vfsnf
 (
FILE
 *
__ri
 
__s
, cڡ *__ri 
__fm
,

433 
__gnuc_va_li
 
__g
)

434 
	`__ibu__
 ((
	$__fm__
 (
__snf__
, 2, 0))
__wur
;

440 
	$vsnf
 (cڡ *
__ri
 
__fm
, 
__gnuc_va_li
 
__g
)

441 
	`__ibu__
 ((
	$__fm__
 (
__snf__
, 1, 0))
__wur
;

444 
	$vssnf
 (cڡ *
__ri
 
__s
,

445 cڡ *
__ri
 
__fm
, 
__gnuc_va_li
 
__g
)

446 
__THROW
 
	`__ibu__
 ((
	`__fm__
 (
__snf__
, 2, 0)));

449 #i!
	`__GLIBC_USE
 (
DEPRECATED_SCANF
)

450 #i
defed
 
__REDIRECT
 && !defed 
__LDBL_COMPAT


451 
	`__REDIRECT
 (
vfsnf
,

452 (
FILE
 *
__ri
 
__s
,

453 cڡ *
__ri
 
__fm
, 
__gnuc_va_li
 
__g
),

454 
__isoc99_vfsnf
)

455 
	`__ibu__
 ((
	$__fm__
 (
__snf__
, 2, 0))
__wur
;

456 
	`__REDIRECT
 (
vsnf
, (cڡ *
__ri
 
__fm
,

457 
__gnuc_va_li
 
__g
), 
__isoc99_vsnf
)

458 
	`__ibu__
 ((
	$__fm__
 (
__snf__
, 1, 0))
__wur
;

459 
	`__REDIRECT_NTH
 (
vssnf
,

460 (cڡ *
__ri
 
__s
,

461 cڡ *
__ri
 
__fm
,

462 
__gnuc_va_li
 
__g
), 
__isoc99_vssnf
)

463 
	`__ibu__
 ((
	`__fm__
 (
__snf__
, 2, 0)));

464 #i!
defed
 
__REDIRECT


465 
	$__isoc99_vfsnf
 (
FILE
 *
__ri
 
__s
,

466 cڡ *
__ri
 
__fm
,

467 
__gnuc_va_li
 
__g

__wur
;

468 
	$__isoc99_vsnf
 (cڡ *
__ri
 
__fm
,

469 
__gnuc_va_li
 
__g

__wur
;

470 
	$__isoc99_vssnf
 (cڡ *
__ri
 
__s
,

471 cڡ *
__ri
 
__fm
,

472 
__gnuc_va_li
 
__g

__THROW
;

473 
	#vfsnf
 
__isoc99_vfsnf


	)

474 
	#vsnf
 
__isoc99_vsnf


	)

475 
	#vssnf
 
__isoc99_vssnf


	)

485 
	`fgc
 (
FILE
 *
__am
);

486 
	`gc
 (
FILE
 *
__am
);

492 
	`gch
 ();

494 #ifde
__USE_POSIX199506


499 
	`gc_uocked
 (
FILE
 *
__am
);

500 
	`gch_uocked
 ();

503 #ifde
__USE_MISC


510 
	`fgc_uocked
 (
FILE
 *
__am
);

521 
	`utc
 (
__c
, 
FILE
 *
__am
);

522 
	`putc
 (
__c
, 
FILE
 *
__am
);

528 
	`putch
 (
__c
);

530 #ifde
__USE_MISC


537 
	`utc_uocked
 (
__c
, 
FILE
 *
__am
);

540 #ifde
__USE_POSIX199506


545 
	`putc_uocked
 (
__c
, 
FILE
 *
__am
);

546 
	`putch_uocked
 (
__c
);

550 #i
defed
 
__USE_MISC
 \

551 || (
defed
 
__USE_XOPEN
 && !defed 
__USE_XOPEN2K
)

553 
	`gw
 (
FILE
 *
__am
);

556 
	`putw
 (
__w
, 
FILE
 *
__am
);

564 *
	$fgs
 (*
__ri
 
__s
, 
__n
, 
FILE
 *__ri 
__am
)

565 
__wur
;

567 #i
	`__GLIBC_USE
 (
DEPRECATED_GETS
)

577 *
	$gs
 (*
__s

__wur
 
__ibu_dd__
;

580 #ifde
__USE_GNU


587 *
	$fgs_uocked
 (*
__ri
 
__s
, 
__n
,

588 
FILE
 *
__ri
 
__am

__wur
;

592 #i
defed
 
__USE_XOPEN2K8
 || 
	`__GLIBC_USE
 (
LIB_EXT2
)

603 
__ssize_t
 
	$__gdim
 (**
__ri
 
__l
,

604 
size_t
 *
__ri
 
__n
, 
__dim
,

605 
FILE
 *
__ri
 
__am

__wur
;

606 
__ssize_t
 
	$gdim
 (**
__ri
 
__l
,

607 
size_t
 *
__ri
 
__n
, 
__dim
,

608 
FILE
 *
__ri
 
__am

__wur
;

616 
__ssize_t
 
	$gle
 (**
__ri
 
__l
,

617 
size_t
 *
__ri
 
__n
,

618 
FILE
 *
__ri
 
__am

__wur
;

626 
	`uts
 (cڡ *
__ri
 
__s
, 
FILE
 *__ri 
__am
);

632 
	`puts
 (cڡ *
__s
);

639 
	`ungc
 (
__c
, 
FILE
 *
__am
);

646 
size_t
 
	$d
 (*
__ri
 
__r
, 
size_t
 
__size
,

647 
size_t
 
__n
, 
FILE
 *
__ri
 
__am

__wur
;

652 
size_t
 
	`fwre
 (cڡ *
__ri
 
__r
, size_
__size
,

653 
size_t
 
__n
, 
FILE
 *
__ri
 
__s
);

655 #ifde
__USE_GNU


662 
	`uts_uocked
 (cڡ *
__ri
 
__s
,

663 
FILE
 *
__ri
 
__am
);

666 #ifde
__USE_MISC


673 
size_t
 
	$d_uocked
 (*
__ri
 
__r
, 
size_t
 
__size
,

674 
size_t
 
__n
, 
FILE
 *
__ri
 
__am

__wur
;

675 
size_t
 
	`fwre_uocked
 (cڡ *
__ri
 
__r
, size_
__size
,

676 
size_t
 
__n
, 
FILE
 *
__ri
 
__am
);

684 
	`fek
 (
FILE
 *
__am
, 
__off
, 
__wh
);

689 
	$l
 (
FILE
 *
__am

__wur
;

694 
	`wd
 (
FILE
 *
__am
);

701 #i
defed
 
__USE_LARGEFILE
 || defed 
__USE_XOPEN2K


702 #ide
__USE_FILE_OFFSET64


707 
	`feko
 (
FILE
 *
__am
, 
__off_t
 
__off
, 
__wh
);

712 
__off_t
 
	$lo
 (
FILE
 *
__am

__wur
;

714 #ifde
__REDIRECT


715 
	`__REDIRECT
 (
feko
,

716 (
FILE
 *
__am
, 
__off64_t
 
__off
, 
__wh
),

717 
feko64
);

718 
__off64_t
 
	`__REDIRECT
 (
lo
, (
FILE
 *
__am
), 
lo64
);

720 
	#feko
 
feko64


	)

721 
	#lo
 
lo64


	)

726 #ide
__USE_FILE_OFFSET64


731 
	`fgpos
 (
FILE
 *
__ri
 
__am
, 
os_t
 *__ri 
__pos
);

736 
	`fos
 (
FILE
 *
__am
, cڡ 
os_t
 *
__pos
);

738 #ifde
__REDIRECT


739 
	`__REDIRECT
 (
fgpos
, (
FILE
 *
__ri
 
__am
,

740 
os_t
 *
__ri
 
__pos
), 
fgpos64
);

741 
	`__REDIRECT
 (
fos
,

742 (
FILE
 *
__am
, cڡ 
os_t
 *
__pos
), 
fos64
);

744 
	#fgpos
 
fgpos64


	)

745 
	#fos
 
fos64


	)

749 #ifde
__USE_LARGEFILE64


750 
	`feko64
 (
FILE
 *
__am
, 
__off64_t
 
__off
, 
__wh
);

751 
__off64_t
 
	$lo64
 (
FILE
 *
__am

__wur
;

752 
	`fgpos64
 (
FILE
 *
__ri
 
__am
, 
os64_t
 *__ri 
__pos
);

753 
	`fos64
 (
FILE
 *
__am
, cڡ 
os64_t
 *
__pos
);

757 
	$
 (
FILE
 *
__am

__THROW
;

759 
	$of
 (
FILE
 *
__am

__THROW
 
__wur
;

761 
	$
 (
FILE
 *
__am

__THROW
 
__wur
;

763 #ifde
__USE_MISC


765 
	$_uocked
 (
FILE
 *
__am

__THROW
;

766 
	$of_uocked
 (
FILE
 *
__am

__THROW
 
__wur
;

767 
	$_uocked
 (
FILE
 *
__am

__THROW
 
__wur
;

775 
	`
 (cڡ *
__s
);

781 
	~<bs/sys_i.h
>

784 #ifdef 
__USE_POSIX


786 
	$fo
 (
FILE
 *
__am

__THROW
 
__wur
;

789 #ifde
__USE_MISC


791 
	$fo_uocked
 (
FILE
 *
__am

__THROW
 
__wur
;

795 #ifde
__USE_POSIX2


800 
FILE
 *
	$pݒ
 (cڡ *
__commd
, cڡ *
__modes

__wur
;

806 
	`po
 (
FILE
 *
__am
);

810 #ifdef 
__USE_POSIX


812 *
	$mid
 (*
__s

__THROW
;

816 #i(
defed
 
__USE_XOPEN
 && !defed 
__USE_XOPEN2K
|| defed 
__USE_GNU


818 *
	`curid
 (*
__s
);

822 #ifdef 
__USE_GNU


823 
oback
;

826 
	$oback_tf
 (
oback
 *
__ri
 
__oback
,

827 cڡ *
__ri
 
__fm
, ...)

828 
__THROWNL
 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 2, 3)));

829 
	$oback_vtf
 (
oback
 *
__ri
 
__oback
,

830 cڡ *
__ri
 
__fm
,

831 
__gnuc_va_li
 
__gs
)

832 
__THROWNL
 
	`__ibu__
 ((
	`__fm__
 (
__tf__
, 2, 0)));

836 #ifde
__USE_POSIX199506


840 
	$ockfe
 (
FILE
 *
__am

__THROW
;

844 
	$rylockfe
 (
FILE
 *
__am

__THROW
 
__wur
;

847 
	$fuockfe
 (
FILE
 *
__am

__THROW
;

850 #i
defed
 
__USE_XOPEN
 && !defed 
__USE_XOPEN2K
 && !defed 
__USE_GNU


853 
	~<bs/gt_posix.h
>

858 
	`__uow
 (
FILE
 *);

859 
	`__ovow
 (
FILE
 *, );

863 #ifde
__USE_EXTERN_INLINES


864 
	~<bs/dio.h
>

866 #i
__USE_FORTIFY_LEVEL
 > 0 && 
defed
 
__ftify_funi


867 
	~<bs/dio2.h
>

869 #ifde
__LDBL_COMPAT


870 
	~<bs/dio-ldbl.h
>

873 
__END_DECLS


	@/usr/include/string.h

22 #idef 
_STRING_H


23 
	#_STRING_H
 1

	)

25 
	#__GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION


	)

26 
	~<bs/libc-hd-t.h
>

28 
	g__BEGIN_DECLS


31 
	#__ed_size_t


	)

32 
	#__ed_NULL


	)

33 
	~<ddef.h
>

36 #i
defed
 
__lulus
 && (
__GNUC_PREREQ
 (4, 4) \

37 || 
	$__glibc_g_eq
 (3, 5))

38 
	#__CORRECT_ISO_CPP_STRING_H_PROTO


	)

43 *
	$memy
 (*
__ri
 
__de
, cڡ *__ri 
__c
,

44 
size_t
 
__n

__THROW
 
	`__nnu
 ((1, 2));

47 *
	$memmove
 (*
__de
, cڡ *
__c
, 
size_t
 
__n
)

48 
__THROW
 
	`__nnu
 ((1, 2));

53 #i
defed
 
__USE_MISC
 || defed 
__USE_XOPEN
 || 
	`__GLIBC_USE
 (
ISOC2X
)

54 *
	$memcy
 (*
__ri
 
__de
, cڡ *__ri 
__c
,

55 
__c
, 
size_t
 
__n
)

56 
__THROW
 
	`__nnu
 ((1, 2));

61 *
	$memt
 (*
__s
, 
__c
, 
size_t
 
__n

__THROW
 
	`__nnu
 ((1));

64 
	$memcmp
 (cڡ *
__s1
, cڡ *
__s2
, 
size_t
 
__n
)

65 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

68 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


71 *
	`memchr
 (*
__s
, 
__c
, 
size_t
 
__n
)

72 
__THROW
 
	`__asm
 ("memchr"
__ibu_pu__
 
	`__nnu
 ((1));

73 cڡ *
	`memchr
 (cڡ *
__s
, 
__c
, 
size_t
 
__n
)

74 
__THROW
 
	`__asm
 ("memchr"
__ibu_pu__
 
	`__nnu
 ((1));

76 #ifde
__OPTIMIZE__


77 
__ex_ways_le
 *

78 
	`memchr
 (*
__s
, 
__c
, 
size_t
 
__n

__THROW


80  
	`__but_memchr
 (
__s
, 
__c
, 
__n
);

83 
__ex_ways_le
 const *

84 
	`memchr
 (cڡ *
__s
, 
__c
, 
size_t
 
__n

__THROW


86  
	`__but_memchr
 (
__s
, 
__c
, 
__n
);

89 
	}
}

91 *
	$memchr
 (cڡ *
__s
, 
__c
, 
size_t
 
__n
)

92 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1));

95 #ifde
__USE_GNU


98 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


99 "C++" *
	$wmemchr
 (*
__s
, 
__c
)

100 
__THROW
 
	`__asm
 ("wmemchr"
__ibu_pu__
 
	`__nnu
 ((1));

101 "C++" cڡ *
	$wmemchr
 (cڡ *
__s
, 
__c
)

102 
__THROW
 
	`__asm
 ("wmemchr"
__ibu_pu__
 
	`__nnu
 ((1));

104 *
	$wmemchr
 (cڡ *
__s
, 
__c
)

105 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1));

109 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


110 "C++" *
	$memrchr
 (*
__s
, 
__c
, 
size_t
 
__n
)

111 
__THROW
 
	`__asm
 ("memrchr"
__ibu_pu__
 
	`__nnu
 ((1));

112 "C++" cڡ *
	$memrchr
 (cڡ *
__s
, 
__c
, 
size_t
 
__n
)

113 
__THROW
 
	`__asm
 ("memrchr"
__ibu_pu__
 
	`__nnu
 ((1));

115 *
	$memrchr
 (cڡ *
__s
, 
__c
, 
size_t
 
__n
)

116 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1));

122 *
	$ry
 (*
__ri
 
__de
, cڡ *__ri 
__c
)

123 
__THROW
 
	`__nnu
 ((1, 2));

125 *
	$y
 (*
__ri
 
__de
,

126 cڡ *
__ri
 
__c
, 
size_t
 
__n
)

127 
__THROW
 
	`__nnu
 ((1, 2));

130 *
	$rt
 (*
__ri
 
__de
, cڡ *__ri 
__c
)

131 
__THROW
 
	`__nnu
 ((1, 2));

133 *
	$t
 (*
__ri
 
__de
, cڡ *__ri 
__c
,

134 
size_t
 
__n

__THROW
 
	`__nnu
 ((1, 2));

137 
	$rcmp
 (cڡ *
__s1
, cڡ *
__s2
)

138 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

140 
	$cmp
 (cڡ *
__s1
, cڡ *
__s2
, 
size_t
 
__n
)

141 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

144 
	$rcl
 (cڡ *
__s1
, cڡ *
__s2
)

145 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

147 
size_t
 
	$rxm
 (*
__ri
 
__de
,

148 cڡ *
__ri
 
__c
, 
size_t
 
__n
)

149 
__THROW
 
	`__nnu
 ((2));

151 #ifde
__USE_XOPEN2K8


153 
	~<bs/tys/lo_t.h
>

156 
	$rcl_l
 (cڡ *
__s1
, cڡ *
__s2
, 
lo_t
 
__l
)

157 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2, 3));

160 
size_t
 
	$rxm_l
 (*
__de
, cڡ *
__c
, 
size_t
 
__n
,

161 
lo_t
 
__l

__THROW
 
	`__nnu
 ((2, 4));

164 #i(
defed
 
__USE_XOPEN_EXTENDED
 || defed 
__USE_XOPEN2K8
 \

165 || 
	`__GLIBC_USE
 (
LIB_EXT2
|| 
	$__GLIBC_USE
 (
ISOC2X
))

167 *
	$rdup
 (cڡ *
__s
)

168 
__THROW
 
__ibu_mloc__
 
	`__nnu
 ((1));

174 #i
defed
 
__USE_XOPEN2K8
 || 
	`__GLIBC_USE
 (
LIB_EXT2
|| __GLIBC_USE (
ISOC2X
)

175 *
	$dup
 (cڡ *
__rg
, 
size_t
 
__n
)

176 
__THROW
 
__ibu_mloc__
 
	`__nnu
 ((1));

179 #i
defed
 
__USE_GNU
 && defed 
__GNUC__


181 
	#rdu
(
s
) \

182 (
__exnsi__
 \

184 cڡ *
__d
 = (
s
); \

185 
size_t
 
__n
 = 
	`
 (
__d
) + 1; \

186 *
__w
 = (*
	`__but_lo
 (
__n
); \

187 (*
	`memy
 (
__w
, 
__d
, 
__n
); \

188 
	}
}))

	)

191 
	#du
(
s
, 
n
) \

192 (
__exnsi__
 \

194 cڡ *
__d
 = (
s
); \

195 
size_t
 
__n
 = 
	`n
 (
__d
, (
n
)); \

196 *
__w
 = (*
	`__but_lo
 (
__n
 + 1); \

197 
__w
[
__n
] = '\0'; \

198 (*
	`memy
 (
__w
, 
__d
, 
__n
); \

199 }))

	)

203 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


206 *
rchr
 (*
__s
, 
__c
)

207 
__THROW
 
__asm
 ("rchr"
__ibu_pu__
 
__nnu
 ((1));

208 cڡ *
rchr
 (cڡ *
__s
, 
__c
)

209 
__THROW
 
__asm
 ("rchr"
__ibu_pu__
 
__nnu
 ((1));

211 #ifde
__OPTIMIZE__


212 
__ex_ways_le
 *

213 
rchr
 (*
__s
, 
__c

	g__THROW


215  
__but_rchr
 (
__s
, 
__c
);

218 
__ex_ways_le
 const *

219 
rchr
 (cڡ *
__s
, 
__c

	g__THROW


221  
__but_rchr
 (
__s
, 
__c
);

226 *
	$rchr
 (cڡ *
__s
, 
__c
)

227 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1));

230 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


233 *
	`chr
 (*
__s
, 
__c
)

234 
__THROW
 
	`__asm
 ("chr"
__ibu_pu__
 
	`__nnu
 ((1));

235 cڡ *
	`chr
 (cڡ *
__s
, 
__c
)

236 
__THROW
 
	`__asm
 ("chr"
__ibu_pu__
 
	`__nnu
 ((1));

238 #ifde
__OPTIMIZE__


239 
__ex_ways_le
 *

240 
	`chr
 (*
__s
, 
__c

__THROW


242  
	`__but_chr
 (
__s
, 
__c
);

245 
__ex_ways_le
 const *

246 
	`chr
 (cڡ *
__s
, 
__c

__THROW


248  
	`__but_chr
 (
__s
, 
__c
);

251 
	}
}

253 *
	$chr
 (cڡ *
__s
, 
__c
)

254 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1));

257 #ifde
__USE_GNU


260 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


261 "C++" *
	$rchul
 (*
__s
, 
__c
)

262 
__THROW
 
	`__asm
 ("rchul"
__ibu_pu__
 
	`__nnu
 ((1));

263 "C++" cڡ *
	$rchul
 (cڡ *
__s
, 
__c
)

264 
__THROW
 
	`__asm
 ("rchul"
__ibu_pu__
 
	`__nnu
 ((1));

266 *
	$rchul
 (cڡ *
__s
, 
__c
)

267 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1));

273 
size_t
 
	$rcn
 (cڡ *
__s
, cڡ *
__je
)

274 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

277 
size_t
 
	$rn
 (cڡ *
__s
, cڡ *
__ac
)

278 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

280 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


283 *
	`brk
 (*
__s
, cڡ *
__ac
)

284 
__THROW
 
	`__asm
 ("brk"
__ibu_pu__
 
	`__nnu
 ((1, 2));

285 cڡ *
	`brk
 (cڡ *
__s
, cڡ *
__ac
)

286 
__THROW
 
	`__asm
 ("brk"
__ibu_pu__
 
	`__nnu
 ((1, 2));

288 #ifde
__OPTIMIZE__


289 
__ex_ways_le
 *

290 
	`brk
 (*
__s
, cڡ *
__ac

__THROW


292  
	`__but_brk
 (
__s
, 
__ac
);

295 
__ex_ways_le
 const *

296 
	`brk
 (cڡ *
__s
, cڡ *
__ac

__THROW


298  
	`__but_brk
 (
__s
, 
__ac
);

301 
	}
}

303 *
	$brk
 (cڡ *
__s
, cڡ *
__ac
)

304 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

307 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


310 *
	`rr
 (*
__hayack
, cڡ *
__ed
)

311 
__THROW
 
	`__asm
 ("rr"
__ibu_pu__
 
	`__nnu
 ((1, 2));

312 cڡ *
	`rr
 (cڡ *
__hayack
, cڡ *
__ed
)

313 
__THROW
 
	`__asm
 ("rr"
__ibu_pu__
 
	`__nnu
 ((1, 2));

315 #ifde
__OPTIMIZE__


316 
__ex_ways_le
 *

317 
	`rr
 (*
__hayack
, cڡ *
__ed

__THROW


319  
	`__but_rr
 (
__hayack
, 
__ed
);

322 
__ex_ways_le
 const *

323 
	`rr
 (cڡ *
__hayack
, cڡ *
__ed

__THROW


325  
	`__but_rr
 (
__hayack
, 
__ed
);

328 
	}
}

330 *
	$rr
 (cڡ *
__hayack
, cڡ *
__ed
)

331 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

336 *
	$ok
 (*
__ri
 
__s
, cڡ *__ri 
__dim
)

337 
__THROW
 
	`__nnu
 ((2));

341 *
	$__ok_r
 (*
__ri
 
__s
,

342 cڡ *
__ri
 
__dim
,

343 **
__ri
 
__ve_r
)

344 
__THROW
 
	`__nnu
 ((2, 3));

345 #ifde
__USE_POSIX


346 *
	$ok_r
 (*
__ri
 
__s
, cڡ *__ri 
__dim
,

347 **
__ri
 
__ve_r
)

348 
__THROW
 
	`__nnu
 ((2, 3));

351 #ifde
__USE_GNU


353 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


354 "C++" *
	$rr
 (*
__hayack
, cڡ *
__ed
)

355 
__THROW
 
	`__asm
 ("rr"
__ibu_pu__
 
	`__nnu
 ((1, 2));

356 "C++" cڡ *
	$rr
 (cڡ *
__hayack
,

357 cڡ *
__ed
)

358 
__THROW
 
	`__asm
 ("rr"
__ibu_pu__
 
	`__nnu
 ((1, 2));

360 *
	$rr
 (cڡ *
__hayack
, cڡ *
__ed
)

361 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

365 #ifde
__USE_GNU


369 *
	$memmem
 (cڡ *
__hayack
, 
size_t
 
__hayackn
,

370 cڡ *
__ed
, 
size_t
 
__edn
)

371 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 3));

375 *
	$__mempy
 (*
__ri
 
__de
,

376 cڡ *
__ri
 
__c
, 
size_t
 
__n
)

377 
__THROW
 
	`__nnu
 ((1, 2));

378 *
	$mempy
 (*
__ri
 
__de
,

379 cڡ *
__ri
 
__c
, 
size_t
 
__n
)

380 
__THROW
 
	`__nnu
 ((1, 2));

385 
size_t
 
	$
 (cڡ *
__s
)

386 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1));

388 #ifdef 
__USE_XOPEN2K8


391 
size_t
 
	$n
 (cڡ *
__rg
, 
size_t
 
__maxn
)

392 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1));

397 *
	$
 (
__um

__THROW
;

398 #ifde
__USE_XOPEN2K


406 #i
defed
 
__USE_XOPEN2K
 && !defed 
__USE_GNU


409 #ifde
__REDIRECT_NTH


410 
	`__REDIRECT_NTH
 (
_r
,

411 (
__um
, *
__buf
, 
size_t
 
__bu
),

412 
__xpg__r

	`__nnu
 ((2));

414 
	$__xpg__r
 (
__um
, *
__buf
, 
size_t
 
__bu
)

415 
__THROW
 
	`__nnu
 ((2));

416 
	#_r
 
__xpg__r


	)

421 *
	$_r
 (
__um
, *
__buf
, 
size_t
 
__bu
)

422 
__THROW
 
	`__nnu
 ((2)
__wur
;

426 #ifde
__USE_XOPEN2K8


428 *
	$_l
 (
__um
, 
lo_t
 
__l

__THROW
;

431 #ifde
__USE_MISC


432 
	~<rgs.h
>

436 
	$exic_bzo
 (*
__s
, 
size_t
 
__n

__THROW
 
	`__nnu
 ((1));

440 *
	$rp
 (**
__ri
 
__rgp
,

441 cڡ *
__ri
 
__dim
)

442 
__THROW
 
	`__nnu
 ((1, 2));

445 #ifdef 
__USE_XOPEN2K8


447 *
	$rsigl
 (
__sig

__THROW
;

450 *
	$__py
 (*
__ri
 
__de
, cڡ *__ri 
__c
)

451 
__THROW
 
	`__nnu
 ((1, 2));

452 *
	$py
 (*
__ri
 
__de
, cڡ *__ri 
__c
)

453 
__THROW
 
	`__nnu
 ((1, 2));

457 *
	$__y
 (*
__ri
 
__de
,

458 cڡ *
__ri
 
__c
, 
size_t
 
__n
)

459 
__THROW
 
	`__nnu
 ((1, 2));

460 *
	$y
 (*
__ri
 
__de
,

461 cڡ *
__ri
 
__c
, 
size_t
 
__n
)

462 
__THROW
 
	`__nnu
 ((1, 2));

465 #ifdef 
__USE_GNU


467 
	$rvscmp
 (cڡ *
__s1
, cڡ *
__s2
)

468 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

471 *
	$ry
 (*
__rg

__THROW
 
	`__nnu
 ((1));

474 *
	$memob
 (*
__s
, 
size_t
 
__n

__THROW
 
	`__nnu
 ((1));

476 #ide
bame


481 #ifde
__CORRECT_ISO_CPP_STRING_H_PROTO


482 "C++" *
	$bame
 (*
__fame
)

483 
__THROW
 
	`__asm
 ("bame"
	`__nnu
 ((1));

484 "C++" cڡ *
	$bame
 (cڡ *
__fame
)

485 
__THROW
 
	`__asm
 ("bame"
	`__nnu
 ((1));

487 *
	$bame
 (cڡ *
__fame

__THROW
 
	`__nnu
 ((1));

492 #i
	`__GNUC_PREREQ
 (3,4)

493 #i
__USE_FORTIFY_LEVEL
 > 0 && 
defed
 
__ftify_funi


495 
	~<bs/rg_ftifd.h
>

499 
__END_DECLS


	@/usr/include/features.h

18 #idef 
_FEATURES_H


19 
	#_FEATURES_H
 1

	)

120 #unde
__USE_ISOC11


121 #unde
__USE_ISOC99


122 #unde
__USE_ISOC95


123 #unde
__USE_ISOCXX11


124 #unde
__USE_POSIX


125 #unde
__USE_POSIX2


126 #unde
__USE_POSIX199309


127 #unde
__USE_POSIX199506


128 #unde
__USE_XOPEN


129 #unde
__USE_XOPEN_EXTENDED


130 #unde
__USE_UNIX98


131 #unde
__USE_XOPEN2K


132 #unde
__USE_XOPEN2KXSI


133 #unde
__USE_XOPEN2K8


134 #unde
__USE_XOPEN2K8XSI


135 #unde
__USE_LARGEFILE


136 #unde
__USE_LARGEFILE64


137 #unde
__USE_FILE_OFFSET64


138 #unde
__USE_MISC


139 #unde
__USE_ATFILE


140 #unde
__USE_GNU


141 #unde
__USE_FORTIFY_LEVEL


142 #unde
__KERNEL_STRICT_NAMES


143 #unde
__GLIBC_USE_ISOC2X


144 #unde
__GLIBC_USE_DEPRECATED_GETS


145 #unde
__GLIBC_USE_DEPRECATED_SCANF


149 #ide
_LOOSE_KERNEL_NAMES


150 
	#__KERNEL_STRICT_NAMES


	)

160 #i
defed
 
__GNUC__
 && defed 
__GNUC_MINOR__


161 
	#__GNUC_PREREQ
(
maj
, 
m
) \

162 ((
__GNUC__
 << 16+ 
__GNUC_MINOR__
 >((
maj
<< 16+ (
m
))

	)

164 
	#__GNUC_PREREQ
(
maj
, 
m
0

	)

171 #i
defed
 
__g_maj__
 && defed 
__g_m__


172 
	#__glibc_g_eq
(
maj
, 
m
) \

173 ((
__g_maj__
 << 16+ 
__g_m__
 >((
maj
<< 16+ (
m
))

	)

175 
	#__glibc_g_eq
(
maj
, 
m
0

	)

179 
	#__GLIBC_USE
(
F

__GLIBC_USE_
 ## 
	)
F

185 #i(
defed
 
_BSD_SOURCE
 || defed 
_SVID_SOURCE
) \

186 && !
defed
 
	g_DEFAULT_SOURCE


188 #unde
_DEFAULT_SOURCE


189 
	#_DEFAULT_SOURCE
 1

	)

193 #ifde
_GNU_SOURCE


194 #unde
_ISOC95_SOURCE


195 
	#_ISOC95_SOURCE
 1

	)

196 #unde
_ISOC99_SOURCE


197 
	#_ISOC99_SOURCE
 1

	)

198 #unde
_ISOC11_SOURCE


199 
	#_ISOC11_SOURCE
 1

	)

200 #unde
_ISOC2X_SOURCE


201 
	#_ISOC2X_SOURCE
 1

	)

202 #unde
_POSIX_SOURCE


203 
	#_POSIX_SOURCE
 1

	)

204 #unde
_POSIX_C_SOURCE


205 
	#_POSIX_C_SOURCE
 200809L

	)

206 #unde
_XOPEN_SOURCE


207 
	#_XOPEN_SOURCE
 700

	)

208 #unde
_XOPEN_SOURCE_EXTENDED


209 
	#_XOPEN_SOURCE_EXTENDED
 1

	)

210 #unde
_LARGEFILE64_SOURCE


211 
	#_LARGEFILE64_SOURCE
 1

	)

212 #unde
_DEFAULT_SOURCE


213 
	#_DEFAULT_SOURCE
 1

	)

214 #unde
_ATFILE_SOURCE


215 
	#_ATFILE_SOURCE
 1

	)

220 #i(
defed
 
_DEFAULT_SOURCE
 \

221 || (!
defed
 
	g__STRICT_ANSI__
 \

222 && !
defed
 
	g_ISOC99_SOURCE
 && !defed 
	g_ISOC11_SOURCE
 \

223 && !
defed
 
	g_ISOC2X_SOURCE
 \

224 && !
defed
 
	g_POSIX_SOURCE
 && !defed 
	g_POSIX_C_SOURCE
 \

225 && !
defed
 
	g_XOPEN_SOURCE
))

226 #unde
_DEFAULT_SOURCE


227 
	#_DEFAULT_SOURCE
 1

	)

231 #i(
defed
 
_ISOC2X_SOURCE
 \

232 || (
defed
 
	g__STDC_VERSION__
 && __STDC_VERSION__ > 201710L))

233 
	#__GLIBC_USE_ISOC2X
 1

	)

235 
	#__GLIBC_USE_ISOC2X
 0

	)

239 #i(
defed
 
_ISOC11_SOURCE
 || defed 
_ISOC2X_SOURCE
 \

240 || (
defed
 
	g__STDC_VERSION__
 && __STDC_VERSION__ >= 201112L))

241 
	#__USE_ISOC11
 1

	)

245 #i(
defed
 
_ISOC99_SOURCE
 || defed 
_ISOC11_SOURCE
 \

246 || 
defed
 
_ISOC2X_SOURCE
 \

247 || (
defed
 
__STDC_VERSION__
 && __STDC_VERSION__ >= 199901L))

248 
	#__USE_ISOC99
 1

	)

252 #i(
defed
 
_ISOC99_SOURCE
 || defed 
_ISOC11_SOURCE
 \

253 || 
defed
 
_ISOC2X_SOURCE
 \

254 || (
defed
 
__STDC_VERSION__
 && __STDC_VERSION__ >= 199409L))

255 
	#__USE_ISOC95
 1

	)

258 #ifde
__lulus


260 #i
__lulus
 >= 201703L

261 
	#__USE_ISOC11
 1

	)

265 #i
__lulus
 >201103L || 
defed
 
__GXX_EXPERIMENTAL_CXX0X__


266 
	#__USE_ISOCXX11
 1

	)

267 
	#__USE_ISOC99
 1

	)

274 #ifde
_DEFAULT_SOURCE


275 #i!
defed
 
_POSIX_SOURCE
 && !defed 
_POSIX_C_SOURCE


276 
	#__USE_POSIX_IMPLICITLY
 1

	)

278 #unde
_POSIX_SOURCE


279 
	#_POSIX_SOURCE
 1

	)

280 #unde
_POSIX_C_SOURCE


281 
	#_POSIX_C_SOURCE
 200809L

	)

284 #i((!
defed
 
__STRICT_ANSI__
 \

285 || (
defed
 
_XOPEN_SOURCE
 && (_XOPEN_SOURCE - 0) >= 500)) \

286 && !
defed
 
_POSIX_SOURCE
 && !defed 
_POSIX_C_SOURCE
)

287 
	#_POSIX_SOURCE
 1

	)

288 #i
defed
 
_XOPEN_SOURCE
 && (_XOPEN_SOURCE - 0) < 500

289 
	#_POSIX_C_SOURCE
 2

	)

290 #i
defed
 
_XOPEN_SOURCE
 && (_XOPEN_SOURCE - 0) < 600

291 
	#_POSIX_C_SOURCE
 199506L

	)

292 #i
defed
 
_XOPEN_SOURCE
 && (_XOPEN_SOURCE - 0) < 700

293 
	#_POSIX_C_SOURCE
 200112L

	)

295 
	#_POSIX_C_SOURCE
 200809L

	)

297 
	#__USE_POSIX_IMPLICITLY
 1

	)

306 #i((!
defed
 
_POSIX_C_SOURCE
 || (_POSIX_C_SOURCE - 0) < 199506L) \

307 && (
defed
 
_REENTRANT
 || defed 
_THREAD_SAFE
))

308 
	#_POSIX_SOURCE
 1

	)

309 #unde
_POSIX_C_SOURCE


310 
	#_POSIX_C_SOURCE
 199506L

	)

313 #i(
defed
 
_POSIX_SOURCE
 \

314 || (
defed
 
_POSIX_C_SOURCE
 && _POSIX_C_SOURCE >= 1) \

315 || 
defed
 
_XOPEN_SOURCE
)

316 
	#__USE_POSIX
 1

	)

319 #i
defed
 
_POSIX_C_SOURCE
 && _POSIX_C_SOURCE >2 || defed 
_XOPEN_SOURCE


320 
	#__USE_POSIX2
 1

	)

323 #i
defed
 
_POSIX_C_SOURCE
 && (_POSIX_C_SOURCE - 0) >= 199309L

324 
	#__USE_POSIX199309
 1

	)

327 #i
defed
 
_POSIX_C_SOURCE
 && (_POSIX_C_SOURCE - 0) >= 199506L

328 
	#__USE_POSIX199506
 1

	)

331 #i
defed
 
_POSIX_C_SOURCE
 && (_POSIX_C_SOURCE - 0) >= 200112L

332 
	#__USE_XOPEN2K
 1

	)

333 #unde
__USE_ISOC95


334 
	#__USE_ISOC95
 1

	)

335 #unde
__USE_ISOC99


336 
	#__USE_ISOC99
 1

	)

339 #i
defed
 
_POSIX_C_SOURCE
 && (_POSIX_C_SOURCE - 0) >= 200809L

340 
	#__USE_XOPEN2K8
 1

	)

341 #unde
_ATFILE_SOURCE


342 
	#_ATFILE_SOURCE
 1

	)

345 #ifdef 
_XOPEN_SOURCE


346 
	#__USE_XOPEN
 1

	)

347 #i(
_XOPEN_SOURCE
 - 0) >= 500

348 
	#__USE_XOPEN_EXTENDED
 1

	)

349 
	#__USE_UNIX98
 1

	)

350 #unde
_LARGEFILE_SOURCE


351 
	#_LARGEFILE_SOURCE
 1

	)

352 #i(
_XOPEN_SOURCE
 - 0) >= 600

353 #i(
_XOPEN_SOURCE
 - 0) >= 700

354 
	#__USE_XOPEN2K8
 1

	)

355 
	#__USE_XOPEN2K8XSI
 1

	)

357 
	#__USE_XOPEN2K
 1

	)

358 
	#__USE_XOPEN2KXSI
 1

	)

359 #unde
__USE_ISOC95


360 
	#__USE_ISOC95
 1

	)

361 #unde
__USE_ISOC99


362 
	#__USE_ISOC99
 1

	)

365 #ifde
_XOPEN_SOURCE_EXTENDED


366 
	#__USE_XOPEN_EXTENDED
 1

	)

371 #ifde
_LARGEFILE_SOURCE


372 
	#__USE_LARGEFILE
 1

	)

375 #ifde
_LARGEFILE64_SOURCE


376 
	#__USE_LARGEFILE64
 1

	)

379 #i
defed
 
_FILE_OFFSET_BITS
 && _FILE_OFFSET_BITS == 64

380 
	#__USE_FILE_OFFSET64
 1

	)

383 #i
defed
 
_DEFAULT_SOURCE


384 
	#__USE_MISC
 1

	)

387 #ifdef 
_ATFILE_SOURCE


388 
	#__USE_ATFILE
 1

	)

391 #ifdef 
_GNU_SOURCE


392 
	#__USE_GNU
 1

	)

395 #i
defed
 
_FORTIFY_SOURCE
 && _FORTIFY_SOURCE > 0 \

396 && 
__GNUC_PREREQ
 (4, 1&& 
defed
 
	g__OPTIMIZE__
 && __OPTIMIZE__ > 0

397 #i
_FORTIFY_SOURCE
 > 1

398 
	#__USE_FORTIFY_LEVEL
 2

	)

400 
	#__USE_FORTIFY_LEVEL
 1

	)

403 
	#__USE_FORTIFY_LEVEL
 0

	)

410 #i
defed
 
__lulus
 ? __lulu>201402L : defed 
__USE_ISOC11


411 
	#__GLIBC_USE_DEPRECATED_GETS
 0

	)

413 
	#__GLIBC_USE_DEPRECATED_GETS
 1

	)

428 #i(
defed
 
__USE_GNU
 \

429 && (
defed
 
	g__lulus
 \

430 ? (
	g__lulus
 < 201103L && !
defed
 
	g__GXX_EXPERIMENTAL_CXX0X__
) \

431 : (!
defed
 
__STDC_VERSION__
 || __STDC_VERSION__ < 199901L)))

432 
	#__GLIBC_USE_DEPRECATED_SCANF
 1

	)

434 
	#__GLIBC_USE_DEPRECATED_SCANF
 0

	)

439 
	~<dc-edef.h
>

447 #unde
__GNU_LIBRARY__


448 
	#__GNU_LIBRARY__
 6

	)

452 
	#__GLIBC__
 2

	)

453 
	#__GLIBC_MINOR__
 31

	)

455 
	#__GLIBC_PREREQ
(
maj
, 
m
) \

456 ((
__GLIBC__
 << 16+ 
__GLIBC_MINOR__
 >((
maj
<< 16+ (
m
))

	)

459 #ide
__ASSEMBLER__


460 #ide
_SYS_CDEFS_H


461 
	~<sys/cdefs.h
>

466 #i
defed
 
__USE_FILE_OFFSET64
 && !defed 
__REDIRECT


467 
	#__USE_LARGEFILE
 1

	)

468 
	#__USE_LARGEFILE64
 1

	)

474 #i
__GNUC_PREREQ
 (2, 7&& 
defed
 
__OPTIMIZE__
 \

475 && !
defed
 
	g__OPTIMIZE_SIZE__
 && !defed 
	g__NO_INLINE__
 \

476 && 
defed
 
	g__ex_le


477 
	#__USE_EXTERN_INLINES
 1

	)

485 
	~<gnu/ubs.h
>

	@/usr/include/stdint.h

22 #ide
_STDINT_H


23 
	#_STDINT_H
 1

	)

25 
	#__GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION


	)

26 
	~<bs/libc-hd-t.h
>

27 
	~<bs/tys.h
>

28 
	~<bs/wch.h
>

29 
	~<bs/wdsize.h
>

34 
	~<bs/dt-.h
>

37 
	~<bs/dt-u.h
>

43 
__t_a8_t
 
	tt_a8_t
;

44 
__t_a16_t
 
	tt_a16_t
;

45 
__t_a32_t
 
	tt_a32_t
;

46 
__t_a64_t
 
	tt_a64_t
;

49 
__ut_a8_t
 
	tut_a8_t
;

50 
__ut_a16_t
 
	tut_a16_t
;

51 
__ut_a32_t
 
	tut_a32_t
;

52 
__ut_a64_t
 
	tut_a64_t
;

58 sigd 
	tt_8_t
;

59 #i
__WORDSIZE
 == 64

60 
	tt_16_t
;

61 
	tt_32_t
;

62 
	tt_64_t
;

64 
	tt_16_t
;

65 
	tt_32_t
;

66 
__exnsi__


67 
	tt_64_t
;

71 
	tut_8_t
;

72 #i
__WORDSIZE
 == 64

73 
	tut_16_t
;

74 
	tut_32_t
;

75 
	tut_64_t
;

77 
	tut_16_t
;

78 
	tut_32_t
;

79 
__exnsi__


80 
	tut_64_t
;

85 #i
__WORDSIZE
 == 64

86 #ide
___t_defed


87 
	t_t
;

88 
	#___t_defed


	)

90 
	tu_t
;

92 #ide
___t_defed


93 
	t_t
;

94 
	#___t_defed


	)

96 
	tu_t
;

101 
__tmax_t
 
	ttmax_t
;

102 
__utmax_t
 
	tutmax_t
;

105 #i
__WORDSIZE
 == 64

106 
	#__INT64_C
(
c
## 
L


	)

107 
	#__UINT64_C
(
c
## 
UL


	)

109 
	#__INT64_C
(
c
## 
LL


	)

110 
	#__UINT64_C
(
c
## 
ULL


	)

116 
	#INT8_MIN
 (-128)

	)

117 
	#INT16_MIN
 (-32767-1)

	)

118 
	#INT32_MIN
 (-2147483647-1)

	)

119 
	#INT64_MIN
 (-
	`__INT64_C
(9223372036854775807)-1)

	)

121 
	#INT8_MAX
 (127)

	)

122 
	#INT16_MAX
 (32767)

	)

123 
	#INT32_MAX
 (2147483647)

	)

124 
	#INT64_MAX
 (
	`__INT64_C
(9223372036854775807))

	)

127 
	#UINT8_MAX
 (255)

	)

128 
	#UINT16_MAX
 (65535)

	)

129 
	#UINT32_MAX
 (4294967295U)

	)

130 
	#UINT64_MAX
 (
	`__UINT64_C
(18446744073709551615))

	)

134 
	#INT_LEAST8_MIN
 (-128)

	)

135 
	#INT_LEAST16_MIN
 (-32767-1)

	)

136 
	#INT_LEAST32_MIN
 (-2147483647-1)

	)

137 
	#INT_LEAST64_MIN
 (-
	`__INT64_C
(9223372036854775807)-1)

	)

139 
	#INT_LEAST8_MAX
 (127)

	)

140 
	#INT_LEAST16_MAX
 (32767)

	)

141 
	#INT_LEAST32_MAX
 (2147483647)

	)

142 
	#INT_LEAST64_MAX
 (
	`__INT64_C
(9223372036854775807))

	)

145 
	#UINT_LEAST8_MAX
 (255)

	)

146 
	#UINT_LEAST16_MAX
 (65535)

	)

147 
	#UINT_LEAST32_MAX
 (4294967295U)

	)

148 
	#UINT_LEAST64_MAX
 (
	`__UINT64_C
(18446744073709551615))

	)

152 
	#INT_FAST8_MIN
 (-128)

	)

153 #i
__WORDSIZE
 == 64

154 
	#INT_FAST16_MIN
 (-9223372036854775807L-1)

	)

155 
	#INT_FAST32_MIN
 (-9223372036854775807L-1)

	)

157 
	#INT_FAST16_MIN
 (-2147483647-1)

	)

158 
	#INT_FAST32_MIN
 (-2147483647-1)

	)

160 
	#INT_FAST64_MIN
 (-
	`__INT64_C
(9223372036854775807)-1)

	)

162 
	#INT_FAST8_MAX
 (127)

	)

163 #i
__WORDSIZE
 == 64

164 
	#INT_FAST16_MAX
 (9223372036854775807L)

	)

165 
	#INT_FAST32_MAX
 (9223372036854775807L)

	)

167 
	#INT_FAST16_MAX
 (2147483647)

	)

168 
	#INT_FAST32_MAX
 (2147483647)

	)

170 
	#INT_FAST64_MAX
 (
	`__INT64_C
(9223372036854775807))

	)

173 
	#UINT_FAST8_MAX
 (255)

	)

174 #i
__WORDSIZE
 == 64

175 
	#UINT_FAST16_MAX
 (18446744073709551615UL)

	)

176 
	#UINT_FAST32_MAX
 (18446744073709551615UL)

	)

178 
	#UINT_FAST16_MAX
 (4294967295U)

	)

179 
	#UINT_FAST32_MAX
 (4294967295U)

	)

181 
	#UINT_FAST64_MAX
 (
	`__UINT64_C
(18446744073709551615))

	)

185 #i
__WORDSIZE
 == 64

186 
	#INTPTR_MIN
 (-9223372036854775807L-1)

	)

187 
	#INTPTR_MAX
 (9223372036854775807L)

	)

188 
	#UINTPTR_MAX
 (18446744073709551615UL)

	)

190 
	#INTPTR_MIN
 (-2147483647-1)

	)

191 
	#INTPTR_MAX
 (2147483647)

	)

192 
	#UINTPTR_MAX
 (4294967295U)

	)

197 
	#INTMAX_MIN
 (-
	`__INT64_C
(9223372036854775807)-1)

	)

199 
	#INTMAX_MAX
 (
	`__INT64_C
(9223372036854775807))

	)

202 
	#UINTMAX_MAX
 (
	`__UINT64_C
(18446744073709551615))

	)

208 #i
__WORDSIZE
 == 64

209 
	#PTRDIFF_MIN
 (-9223372036854775807L-1)

	)

210 
	#PTRDIFF_MAX
 (9223372036854775807L)

	)

212 #i
__WORDSIZE32_PTRDIFF_LONG


213 
	#PTRDIFF_MIN
 (-2147483647L-1)

	)

214 
	#PTRDIFF_MAX
 (2147483647L)

	)

216 
	#PTRDIFF_MIN
 (-2147483647-1)

	)

217 
	#PTRDIFF_MAX
 (2147483647)

	)

222 
	#SIG_ATOMIC_MIN
 (-2147483647-1)

	)

223 
	#SIG_ATOMIC_MAX
 (2147483647)

	)

226 #i
__WORDSIZE
 == 64

227 
	#SIZE_MAX
 (18446744073709551615UL)

	)

229 #i
__WORDSIZE32_SIZE_ULONG


230 
	#SIZE_MAX
 (4294967295UL)

	)

232 
	#SIZE_MAX
 (4294967295U)

	)

237 #ide
WCHAR_MIN


239 
	#WCHAR_MIN
 
__WCHAR_MIN


	)

240 
	#WCHAR_MAX
 
__WCHAR_MAX


	)

244 
	#WINT_MIN
 (0u)

	)

245 
	#WINT_MAX
 (4294967295u)

	)

248 
	#INT8_C
(
c

	)
c

249 
	#INT16_C
(
c

	)
c

250 
	#INT32_C
(
c

	)
c

251 #i
__WORDSIZE
 == 64

252 
	#INT64_C
(
c
## 
L


	)

254 
	#INT64_C
(
c
## 
LL


	)

258 
	#UINT8_C
(
c

	)
c

259 
	#UINT16_C
(
c

	)
c

260 
	#UINT32_C
(
c
## 
U


	)

261 #i
__WORDSIZE
 == 64

262 
	#UINT64_C
(
c
## 
UL


	)

264 
	#UINT64_C
(
c
## 
ULL


	)

268 #i
__WORDSIZE
 == 64

269 
	#INTMAX_C
(
c
## 
L


	)

270 
	#UINTMAX_C
(
c
## 
UL


	)

272 
	#INTMAX_C
(
c
## 
LL


	)

273 
	#UINTMAX_C
(
c
## 
ULL


	)

276 #i
__GLIBC_USE
 (
IEC_60559_BFP_EXT_C2X
)

278 
	#INT8_WIDTH
 8

	)

279 
	#UINT8_WIDTH
 8

	)

280 
	#INT16_WIDTH
 16

	)

281 
	#UINT16_WIDTH
 16

	)

282 
	#INT32_WIDTH
 32

	)

283 
	#UINT32_WIDTH
 32

	)

284 
	#INT64_WIDTH
 64

	)

285 
	#UINT64_WIDTH
 64

	)

287 
	#INT_LEAST8_WIDTH
 8

	)

288 
	#UINT_LEAST8_WIDTH
 8

	)

289 
	#INT_LEAST16_WIDTH
 16

	)

290 
	#UINT_LEAST16_WIDTH
 16

	)

291 
	#INT_LEAST32_WIDTH
 32

	)

292 
	#UINT_LEAST32_WIDTH
 32

	)

293 
	#INT_LEAST64_WIDTH
 64

	)

294 
	#UINT_LEAST64_WIDTH
 64

	)

296 
	#INT_FAST8_WIDTH
 8

	)

297 
	#UINT_FAST8_WIDTH
 8

	)

298 
	#INT_FAST16_WIDTH
 
__WORDSIZE


	)

299 
	#UINT_FAST16_WIDTH
 
__WORDSIZE


	)

300 
	#INT_FAST32_WIDTH
 
__WORDSIZE


	)

301 
	#UINT_FAST32_WIDTH
 
__WORDSIZE


	)

302 
	#INT_FAST64_WIDTH
 64

	)

303 
	#UINT_FAST64_WIDTH
 64

	)

305 
	#INTPTR_WIDTH
 
__WORDSIZE


	)

306 
	#UINTPTR_WIDTH
 
__WORDSIZE


	)

308 
	#INTMAX_WIDTH
 64

	)

309 
	#UINTMAX_WIDTH
 64

	)

311 
	#PTRDIFF_WIDTH
 
__WORDSIZE


	)

312 
	#SIG_ATOMIC_WIDTH
 32

	)

313 
	#SIZE_WIDTH
 
__WORDSIZE


	)

314 
	#WCHAR_WIDTH
 32

	)

315 
	#WINT_WIDTH
 32

	)

	@/usr/include/strings.h

18 #idef 
_STRINGS_H


19 
	#_STRINGS_H
 1

	)

21 
	~<us.h
>

22 
	#__ed_size_t


	)

23 
	~<ddef.h
>

26 #i
defed
 
__lulus
 && 
__GNUC_PREREQ
 (4, 4)

27 
	#__CORRECT_ISO_CPP_STRINGS_H_PROTO


	)

30 
	g__BEGIN_DECLS


32 #i
defed
 
__USE_MISC
 || !defed 
__USE_XOPEN2K8


34 
	$bcmp
 (cڡ *
__s1
, cڡ *
__s2
, 
size_t
 
__n
)

35 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

38 
	$bcy
 (cڡ *
__c
, *
__de
, 
size_t
 
__n
)

39 
__THROW
 
	`__nnu
 ((1, 2));

42 
	$bzo
 (*
__s
, 
size_t
 
__n

__THROW
 
	`__nnu
 ((1));

45 #ifde
__CORRECT_ISO_CPP_STRINGS_H_PROTO


48 *
	`dex
 (*
__s
, 
__c
)

49 
__THROW
 
	`__asm
 ("dex"
__ibu_pu__
 
	`__nnu
 ((1));

50 cڡ *
	`dex
 (cڡ *
__s
, 
__c
)

51 
__THROW
 
	`__asm
 ("dex"
__ibu_pu__
 
	`__nnu
 ((1));

53 #i
defed
 
__OPTIMIZE__


54 
__ex_ways_le
 *

55 
	`dex
 (*
__s
, 
__c

__THROW


57  
	`__but_dex
 (
__s
, 
__c
);

60 
__ex_ways_le
 const *

61 
	`dex
 (cڡ *
__s
, 
__c

__THROW


63  
	`__but_dex
 (
__s
, 
__c
);

66 
	}
}

68 *
	$dex
 (cڡ *
__s
, 
__c
)

69 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1));

73 #ifde
__CORRECT_ISO_CPP_STRINGS_H_PROTO


76 *
	`rdex
 (*
__s
, 
__c
)

77 
__THROW
 
	`__asm
 ("rdex"
__ibu_pu__
 
	`__nnu
 ((1));

78 cڡ *
	`rdex
 (cڡ *
__s
, 
__c
)

79 
__THROW
 
	`__asm
 ("rdex"
__ibu_pu__
 
	`__nnu
 ((1));

81 #i
defed
 
__OPTIMIZE__


82 
__ex_ways_le
 *

83 
	`rdex
 (*
__s
, 
__c

__THROW


85  
	`__but_rdex
 (
__s
, 
__c
);

88 
__ex_ways_le
 const *

89 
	`rdex
 (cڡ *
__s
, 
__c

__THROW


91  
	`__but_rdex
 (
__s
, 
__c
);

94 
	}
}

96 *
	$rdex
 (cڡ *
__s
, 
__c
)

97 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1));

101 #i
defed
 
__USE_MISC
 || !defed 
__USE_XOPEN2K8
 || defed 
__USE_XOPEN2K8XSI


104 
	$ffs
 (
__i

__THROW
 
__ibu_cڡ__
;

109 #ifdef 
__USE_MISC


110 
	$ff
 (
__l

__THROW
 
__ibu_cڡ__
;

111 
__exnsi__
 
	$ffl
 (
__
)

112 
__THROW
 
__ibu_cڡ__
;

116 
	$rcmp
 (cڡ *
__s1
, cڡ *
__s2
)

117 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

120 
	$cmp
 (cڡ *
__s1
, cڡ *
__s2
, 
size_t
 
__n
)

121 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2));

123 #ifdef 
__USE_XOPEN2K8


125 
	~<bs/tys/lo_t.h
>

128 
	$rcmp_l
 (cڡ *
__s1
, cڡ *
__s2
, 
lo_t
 
__loc
)

129 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2, 3));

133 
	$cmp_l
 (cڡ *
__s1
, cڡ *
__s2
,

134 
size_t
 
__n
, 
lo_t
 
__loc
)

135 
__THROW
 
__ibu_pu__
 
	`__nnu
 ((1, 2, 4));

138 
__END_DECLS


140 #i
	`__GNUC_PREREQ
 (3,4&& 
__USE_FORTIFY_LEVEL
 > 0 \

141 && 
defed
 
__ftify_funi


143 #i
defed
 
__USE_MISC
 || !defed 
__USE_XOPEN2K8


144 
	~<bs/rgs_ftifd.h
>

	@/usr/include/stdc-predef.h

18 #idef 
_STDC_PREDEF_H


19 
	#_STDC_PREDEF_H
 1

	)

36 #ifde
__GCC_IEC_559


37 #i
__GCC_IEC_559
 > 0

38 
	#__STDC_IEC_559__
 1

	)

41 
	#__STDC_IEC_559__
 1

	)

44 #ifde
__GCC_IEC_559_COMPLEX


45 #i
__GCC_IEC_559_COMPLEX
 > 0

46 
	#__STDC_IEC_559_COMPLEX__
 1

	)

49 
	#__STDC_IEC_559_COMPLEX__
 1

	)

58 
	#__STDC_ISO_10646__
 201706L

	)

	@
1
.
1
/usr/include
45
809
address_translation.c
address_translation.h
data_buffer.c
data_buffer.h
ftl_config.c
ftl_config.h
garbage_collection.c
garbage_collection.h
main.c
memory_map.h
nsc_driver.c
nsc_driver.h
nvme/debug.h
nvme/host_lld.c
nvme/host_lld.h
nvme/io_access.h
nvme/nvme.h
nvme/nvme_admin_cmd.c
nvme/nvme_admin_cmd.h
nvme/nvme_identify.c
nvme/nvme_identify.h
nvme/nvme_io_cmd.c
nvme/nvme_io_cmd.h
nvme/nvme_main.c
nvme/nvme_main.h
request_allocation.c
request_allocation.h
request_format.h
request_queue.h
request_schedule.c
request_schedule.h
request_transform.c
request_transform.h
share/share.c
share/share.h
t4nsc_pm.h
t4nsc_ucode.h
/usr/include/assert.h
/usr/include/inttypes.h
/usr/include/stdio.h
/usr/include/string.h
/usr/include/features.h
/usr/include/stdint.h
/usr/include/strings.h
/usr/include/stdc-predef.h
